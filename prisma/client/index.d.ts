
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Serial
 * 
 */
export type Serial = $Result.DefaultSelection<Prisma.$SerialPayload>
/**
 * Model ClassificationType
 * 
 */
export type ClassificationType = $Result.DefaultSelection<Prisma.$ClassificationTypePayload>
/**
 * Model Concepts
 * 
 */
export type Concepts = $Result.DefaultSelection<Prisma.$ConceptsPayload>
/**
 * Model RequestStatus
 * 
 */
export type RequestStatus = $Result.DefaultSelection<Prisma.$RequestStatusPayload>
/**
 * Model Requests
 * 
 */
export type Requests = $Result.DefaultSelection<Prisma.$RequestsPayload>
/**
 * Model Documents
 * 
 */
export type Documents = $Result.DefaultSelection<Prisma.$DocumentsPayload>
/**
 * Model PurchasesOrExpenses
 * 
 */
export type PurchasesOrExpenses = $Result.DefaultSelection<Prisma.$PurchasesOrExpensesPayload>
/**
 * Model TaxPayerTypes
 * 
 */
export type TaxPayerTypes = $Result.DefaultSelection<Prisma.$TaxPayerTypesPayload>
/**
 * Model InvoiceType
 * 
 */
export type InvoiceType = $Result.DefaultSelection<Prisma.$InvoiceTypePayload>
/**
 * Model PaymentsMethods
 * 
 */
export type PaymentsMethods = $Result.DefaultSelection<Prisma.$PaymentsMethodsPayload>
/**
 * Model NcfsTypes
 * 
 */
export type NcfsTypes = $Result.DefaultSelection<Prisma.$NcfsTypesPayload>
/**
 * Model RetentionTax
 * 
 */
export type RetentionTax = $Result.DefaultSelection<Prisma.$RetentionTaxPayload>
/**
 * Model RetentionIsr
 * 
 */
export type RetentionIsr = $Result.DefaultSelection<Prisma.$RetentionIsrPayload>
/**
 * Model CostTaxStatus
 * 
 */
export type CostTaxStatus = $Result.DefaultSelection<Prisma.$CostTaxStatusPayload>
/**
 * Model TaxPayer
 * 
 */
export type TaxPayer = $Result.DefaultSelection<Prisma.$TaxPayerPayload>
/**
 * Model DocumentType
 * 
 */
export type DocumentType = $Result.DefaultSelection<Prisma.$DocumentTypePayload>
/**
 * Model EmailVerifications
 * 
 */
export type EmailVerifications = $Result.DefaultSelection<Prisma.$EmailVerificationsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs>;

  /**
   * `prisma.serial`: Exposes CRUD operations for the **Serial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serials
    * const serials = await prisma.serial.findMany()
    * ```
    */
  get serial(): Prisma.SerialDelegate<ExtArgs>;

  /**
   * `prisma.classificationType`: Exposes CRUD operations for the **ClassificationType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassificationTypes
    * const classificationTypes = await prisma.classificationType.findMany()
    * ```
    */
  get classificationType(): Prisma.ClassificationTypeDelegate<ExtArgs>;

  /**
   * `prisma.concepts`: Exposes CRUD operations for the **Concepts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Concepts
    * const concepts = await prisma.concepts.findMany()
    * ```
    */
  get concepts(): Prisma.ConceptsDelegate<ExtArgs>;

  /**
   * `prisma.requestStatus`: Exposes CRUD operations for the **RequestStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestStatuses
    * const requestStatuses = await prisma.requestStatus.findMany()
    * ```
    */
  get requestStatus(): Prisma.RequestStatusDelegate<ExtArgs>;

  /**
   * `prisma.requests`: Exposes CRUD operations for the **Requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.requests.findMany()
    * ```
    */
  get requests(): Prisma.RequestsDelegate<ExtArgs>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **Documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.DocumentsDelegate<ExtArgs>;

  /**
   * `prisma.purchasesOrExpenses`: Exposes CRUD operations for the **PurchasesOrExpenses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasesOrExpenses
    * const purchasesOrExpenses = await prisma.purchasesOrExpenses.findMany()
    * ```
    */
  get purchasesOrExpenses(): Prisma.PurchasesOrExpensesDelegate<ExtArgs>;

  /**
   * `prisma.taxPayerTypes`: Exposes CRUD operations for the **TaxPayerTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxPayerTypes
    * const taxPayerTypes = await prisma.taxPayerTypes.findMany()
    * ```
    */
  get taxPayerTypes(): Prisma.TaxPayerTypesDelegate<ExtArgs>;

  /**
   * `prisma.invoiceType`: Exposes CRUD operations for the **InvoiceType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceTypes
    * const invoiceTypes = await prisma.invoiceType.findMany()
    * ```
    */
  get invoiceType(): Prisma.InvoiceTypeDelegate<ExtArgs>;

  /**
   * `prisma.paymentsMethods`: Exposes CRUD operations for the **PaymentsMethods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentsMethods
    * const paymentsMethods = await prisma.paymentsMethods.findMany()
    * ```
    */
  get paymentsMethods(): Prisma.PaymentsMethodsDelegate<ExtArgs>;

  /**
   * `prisma.ncfsTypes`: Exposes CRUD operations for the **NcfsTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NcfsTypes
    * const ncfsTypes = await prisma.ncfsTypes.findMany()
    * ```
    */
  get ncfsTypes(): Prisma.NcfsTypesDelegate<ExtArgs>;

  /**
   * `prisma.retentionTax`: Exposes CRUD operations for the **RetentionTax** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RetentionTaxes
    * const retentionTaxes = await prisma.retentionTax.findMany()
    * ```
    */
  get retentionTax(): Prisma.RetentionTaxDelegate<ExtArgs>;

  /**
   * `prisma.retentionIsr`: Exposes CRUD operations for the **RetentionIsr** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RetentionIsrs
    * const retentionIsrs = await prisma.retentionIsr.findMany()
    * ```
    */
  get retentionIsr(): Prisma.RetentionIsrDelegate<ExtArgs>;

  /**
   * `prisma.costTaxStatus`: Exposes CRUD operations for the **CostTaxStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostTaxStatuses
    * const costTaxStatuses = await prisma.costTaxStatus.findMany()
    * ```
    */
  get costTaxStatus(): Prisma.CostTaxStatusDelegate<ExtArgs>;

  /**
   * `prisma.taxPayer`: Exposes CRUD operations for the **TaxPayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxPayers
    * const taxPayers = await prisma.taxPayer.findMany()
    * ```
    */
  get taxPayer(): Prisma.TaxPayerDelegate<ExtArgs>;

  /**
   * `prisma.documentType`: Exposes CRUD operations for the **DocumentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentTypes
    * const documentTypes = await prisma.documentType.findMany()
    * ```
    */
  get documentType(): Prisma.DocumentTypeDelegate<ExtArgs>;

  /**
   * `prisma.emailVerifications`: Exposes CRUD operations for the **EmailVerifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerifications
    * const emailVerifications = await prisma.emailVerifications.findMany()
    * ```
    */
  get emailVerifications(): Prisma.EmailVerificationsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    Serial: 'Serial',
    ClassificationType: 'ClassificationType',
    Concepts: 'Concepts',
    RequestStatus: 'RequestStatus',
    Requests: 'Requests',
    Documents: 'Documents',
    PurchasesOrExpenses: 'PurchasesOrExpenses',
    TaxPayerTypes: 'TaxPayerTypes',
    InvoiceType: 'InvoiceType',
    PaymentsMethods: 'PaymentsMethods',
    NcfsTypes: 'NcfsTypes',
    RetentionTax: 'RetentionTax',
    RetentionIsr: 'RetentionIsr',
    CostTaxStatus: 'CostTaxStatus',
    TaxPayer: 'TaxPayer',
    DocumentType: 'DocumentType',
    EmailVerifications: 'EmailVerifications'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "users" | "serial" | "classificationType" | "concepts" | "requestStatus" | "requests" | "documents" | "purchasesOrExpenses" | "taxPayerTypes" | "invoiceType" | "paymentsMethods" | "ncfsTypes" | "retentionTax" | "retentionIsr" | "costTaxStatus" | "taxPayer" | "documentType" | "emailVerifications"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Serial: {
        payload: Prisma.$SerialPayload<ExtArgs>
        fields: Prisma.SerialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SerialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SerialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>
          }
          findFirst: {
            args: Prisma.SerialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SerialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>
          }
          findMany: {
            args: Prisma.SerialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>[]
          }
          create: {
            args: Prisma.SerialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>
          }
          createMany: {
            args: Prisma.SerialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SerialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>[]
          }
          delete: {
            args: Prisma.SerialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>
          }
          update: {
            args: Prisma.SerialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>
          }
          deleteMany: {
            args: Prisma.SerialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SerialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SerialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerialPayload>
          }
          aggregate: {
            args: Prisma.SerialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSerial>
          }
          groupBy: {
            args: Prisma.SerialGroupByArgs<ExtArgs>
            result: $Utils.Optional<SerialGroupByOutputType>[]
          }
          count: {
            args: Prisma.SerialCountArgs<ExtArgs>
            result: $Utils.Optional<SerialCountAggregateOutputType> | number
          }
        }
      }
      ClassificationType: {
        payload: Prisma.$ClassificationTypePayload<ExtArgs>
        fields: Prisma.ClassificationTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassificationTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassificationTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>
          }
          findFirst: {
            args: Prisma.ClassificationTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassificationTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>
          }
          findMany: {
            args: Prisma.ClassificationTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>[]
          }
          create: {
            args: Prisma.ClassificationTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>
          }
          createMany: {
            args: Prisma.ClassificationTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassificationTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>[]
          }
          delete: {
            args: Prisma.ClassificationTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>
          }
          update: {
            args: Prisma.ClassificationTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>
          }
          deleteMany: {
            args: Prisma.ClassificationTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassificationTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassificationTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationTypePayload>
          }
          aggregate: {
            args: Prisma.ClassificationTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassificationType>
          }
          groupBy: {
            args: Prisma.ClassificationTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassificationTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassificationTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ClassificationTypeCountAggregateOutputType> | number
          }
        }
      }
      Concepts: {
        payload: Prisma.$ConceptsPayload<ExtArgs>
        fields: Prisma.ConceptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>
          }
          findFirst: {
            args: Prisma.ConceptsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>
          }
          findMany: {
            args: Prisma.ConceptsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>[]
          }
          create: {
            args: Prisma.ConceptsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>
          }
          createMany: {
            args: Prisma.ConceptsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConceptsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>[]
          }
          delete: {
            args: Prisma.ConceptsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>
          }
          update: {
            args: Prisma.ConceptsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>
          }
          deleteMany: {
            args: Prisma.ConceptsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConceptsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptsPayload>
          }
          aggregate: {
            args: Prisma.ConceptsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConcepts>
          }
          groupBy: {
            args: Prisma.ConceptsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConceptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptsCountArgs<ExtArgs>
            result: $Utils.Optional<ConceptsCountAggregateOutputType> | number
          }
        }
      }
      RequestStatus: {
        payload: Prisma.$RequestStatusPayload<ExtArgs>
        fields: Prisma.RequestStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>
          }
          findFirst: {
            args: Prisma.RequestStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>
          }
          findMany: {
            args: Prisma.RequestStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>[]
          }
          create: {
            args: Prisma.RequestStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>
          }
          createMany: {
            args: Prisma.RequestStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>[]
          }
          delete: {
            args: Prisma.RequestStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>
          }
          update: {
            args: Prisma.RequestStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>
          }
          deleteMany: {
            args: Prisma.RequestStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RequestStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusPayload>
          }
          aggregate: {
            args: Prisma.RequestStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestStatus>
          }
          groupBy: {
            args: Prisma.RequestStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestStatusCountArgs<ExtArgs>
            result: $Utils.Optional<RequestStatusCountAggregateOutputType> | number
          }
        }
      }
      Requests: {
        payload: Prisma.$RequestsPayload<ExtArgs>
        fields: Prisma.RequestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>
          }
          findFirst: {
            args: Prisma.RequestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>
          }
          findMany: {
            args: Prisma.RequestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>[]
          }
          create: {
            args: Prisma.RequestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>
          }
          createMany: {
            args: Prisma.RequestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>[]
          }
          delete: {
            args: Prisma.RequestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>
          }
          update: {
            args: Prisma.RequestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>
          }
          deleteMany: {
            args: Prisma.RequestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RequestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestsPayload>
          }
          aggregate: {
            args: Prisma.RequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequests>
          }
          groupBy: {
            args: Prisma.RequestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestsCountArgs<ExtArgs>
            result: $Utils.Optional<RequestsCountAggregateOutputType> | number
          }
        }
      }
      Documents: {
        payload: Prisma.$DocumentsPayload<ExtArgs>
        fields: Prisma.DocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          findFirst: {
            args: Prisma.DocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          findMany: {
            args: Prisma.DocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>[]
          }
          create: {
            args: Prisma.DocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          createMany: {
            args: Prisma.DocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>[]
          }
          delete: {
            args: Prisma.DocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          update: {
            args: Prisma.DocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          deleteMany: {
            args: Prisma.DocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.DocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      PurchasesOrExpenses: {
        payload: Prisma.$PurchasesOrExpensesPayload<ExtArgs>
        fields: Prisma.PurchasesOrExpensesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasesOrExpensesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasesOrExpensesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>
          }
          findFirst: {
            args: Prisma.PurchasesOrExpensesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasesOrExpensesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>
          }
          findMany: {
            args: Prisma.PurchasesOrExpensesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>[]
          }
          create: {
            args: Prisma.PurchasesOrExpensesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>
          }
          createMany: {
            args: Prisma.PurchasesOrExpensesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasesOrExpensesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>[]
          }
          delete: {
            args: Prisma.PurchasesOrExpensesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>
          }
          update: {
            args: Prisma.PurchasesOrExpensesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>
          }
          deleteMany: {
            args: Prisma.PurchasesOrExpensesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasesOrExpensesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchasesOrExpensesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesOrExpensesPayload>
          }
          aggregate: {
            args: Prisma.PurchasesOrExpensesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasesOrExpenses>
          }
          groupBy: {
            args: Prisma.PurchasesOrExpensesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasesOrExpensesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasesOrExpensesCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasesOrExpensesCountAggregateOutputType> | number
          }
        }
      }
      TaxPayerTypes: {
        payload: Prisma.$TaxPayerTypesPayload<ExtArgs>
        fields: Prisma.TaxPayerTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxPayerTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxPayerTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>
          }
          findFirst: {
            args: Prisma.TaxPayerTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxPayerTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>
          }
          findMany: {
            args: Prisma.TaxPayerTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>[]
          }
          create: {
            args: Prisma.TaxPayerTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>
          }
          createMany: {
            args: Prisma.TaxPayerTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxPayerTypesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>[]
          }
          delete: {
            args: Prisma.TaxPayerTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>
          }
          update: {
            args: Prisma.TaxPayerTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>
          }
          deleteMany: {
            args: Prisma.TaxPayerTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxPayerTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaxPayerTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerTypesPayload>
          }
          aggregate: {
            args: Prisma.TaxPayerTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxPayerTypes>
          }
          groupBy: {
            args: Prisma.TaxPayerTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxPayerTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxPayerTypesCountArgs<ExtArgs>
            result: $Utils.Optional<TaxPayerTypesCountAggregateOutputType> | number
          }
        }
      }
      InvoiceType: {
        payload: Prisma.$InvoiceTypePayload<ExtArgs>
        fields: Prisma.InvoiceTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>
          }
          findFirst: {
            args: Prisma.InvoiceTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>
          }
          findMany: {
            args: Prisma.InvoiceTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>[]
          }
          create: {
            args: Prisma.InvoiceTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>
          }
          createMany: {
            args: Prisma.InvoiceTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>[]
          }
          delete: {
            args: Prisma.InvoiceTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>
          }
          update: {
            args: Prisma.InvoiceTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTypePayload>
          }
          aggregate: {
            args: Prisma.InvoiceTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceType>
          }
          groupBy: {
            args: Prisma.InvoiceTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceTypeCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceTypeCountAggregateOutputType> | number
          }
        }
      }
      PaymentsMethods: {
        payload: Prisma.$PaymentsMethodsPayload<ExtArgs>
        fields: Prisma.PaymentsMethodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentsMethodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentsMethodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>
          }
          findFirst: {
            args: Prisma.PaymentsMethodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentsMethodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>
          }
          findMany: {
            args: Prisma.PaymentsMethodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>[]
          }
          create: {
            args: Prisma.PaymentsMethodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>
          }
          createMany: {
            args: Prisma.PaymentsMethodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentsMethodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>[]
          }
          delete: {
            args: Prisma.PaymentsMethodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>
          }
          update: {
            args: Prisma.PaymentsMethodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentsMethodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentsMethodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentsMethodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsMethodsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsMethodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentsMethods>
          }
          groupBy: {
            args: Prisma.PaymentsMethodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsMethodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentsMethodsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsMethodsCountAggregateOutputType> | number
          }
        }
      }
      NcfsTypes: {
        payload: Prisma.$NcfsTypesPayload<ExtArgs>
        fields: Prisma.NcfsTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NcfsTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NcfsTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>
          }
          findFirst: {
            args: Prisma.NcfsTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NcfsTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>
          }
          findMany: {
            args: Prisma.NcfsTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>[]
          }
          create: {
            args: Prisma.NcfsTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>
          }
          createMany: {
            args: Prisma.NcfsTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NcfsTypesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>[]
          }
          delete: {
            args: Prisma.NcfsTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>
          }
          update: {
            args: Prisma.NcfsTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>
          }
          deleteMany: {
            args: Prisma.NcfsTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NcfsTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NcfsTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NcfsTypesPayload>
          }
          aggregate: {
            args: Prisma.NcfsTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNcfsTypes>
          }
          groupBy: {
            args: Prisma.NcfsTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NcfsTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.NcfsTypesCountArgs<ExtArgs>
            result: $Utils.Optional<NcfsTypesCountAggregateOutputType> | number
          }
        }
      }
      RetentionTax: {
        payload: Prisma.$RetentionTaxPayload<ExtArgs>
        fields: Prisma.RetentionTaxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetentionTaxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetentionTaxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>
          }
          findFirst: {
            args: Prisma.RetentionTaxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetentionTaxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>
          }
          findMany: {
            args: Prisma.RetentionTaxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>[]
          }
          create: {
            args: Prisma.RetentionTaxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>
          }
          createMany: {
            args: Prisma.RetentionTaxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetentionTaxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>[]
          }
          delete: {
            args: Prisma.RetentionTaxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>
          }
          update: {
            args: Prisma.RetentionTaxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>
          }
          deleteMany: {
            args: Prisma.RetentionTaxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetentionTaxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RetentionTaxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionTaxPayload>
          }
          aggregate: {
            args: Prisma.RetentionTaxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetentionTax>
          }
          groupBy: {
            args: Prisma.RetentionTaxGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetentionTaxGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetentionTaxCountArgs<ExtArgs>
            result: $Utils.Optional<RetentionTaxCountAggregateOutputType> | number
          }
        }
      }
      RetentionIsr: {
        payload: Prisma.$RetentionIsrPayload<ExtArgs>
        fields: Prisma.RetentionIsrFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetentionIsrFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetentionIsrFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>
          }
          findFirst: {
            args: Prisma.RetentionIsrFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetentionIsrFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>
          }
          findMany: {
            args: Prisma.RetentionIsrFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>[]
          }
          create: {
            args: Prisma.RetentionIsrCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>
          }
          createMany: {
            args: Prisma.RetentionIsrCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetentionIsrCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>[]
          }
          delete: {
            args: Prisma.RetentionIsrDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>
          }
          update: {
            args: Prisma.RetentionIsrUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>
          }
          deleteMany: {
            args: Prisma.RetentionIsrDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetentionIsrUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RetentionIsrUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetentionIsrPayload>
          }
          aggregate: {
            args: Prisma.RetentionIsrAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetentionIsr>
          }
          groupBy: {
            args: Prisma.RetentionIsrGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetentionIsrGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetentionIsrCountArgs<ExtArgs>
            result: $Utils.Optional<RetentionIsrCountAggregateOutputType> | number
          }
        }
      }
      CostTaxStatus: {
        payload: Prisma.$CostTaxStatusPayload<ExtArgs>
        fields: Prisma.CostTaxStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostTaxStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostTaxStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>
          }
          findFirst: {
            args: Prisma.CostTaxStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostTaxStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>
          }
          findMany: {
            args: Prisma.CostTaxStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>[]
          }
          create: {
            args: Prisma.CostTaxStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>
          }
          createMany: {
            args: Prisma.CostTaxStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostTaxStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>[]
          }
          delete: {
            args: Prisma.CostTaxStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>
          }
          update: {
            args: Prisma.CostTaxStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>
          }
          deleteMany: {
            args: Prisma.CostTaxStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostTaxStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostTaxStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTaxStatusPayload>
          }
          aggregate: {
            args: Prisma.CostTaxStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostTaxStatus>
          }
          groupBy: {
            args: Prisma.CostTaxStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostTaxStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostTaxStatusCountArgs<ExtArgs>
            result: $Utils.Optional<CostTaxStatusCountAggregateOutputType> | number
          }
        }
      }
      TaxPayer: {
        payload: Prisma.$TaxPayerPayload<ExtArgs>
        fields: Prisma.TaxPayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxPayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxPayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>
          }
          findFirst: {
            args: Prisma.TaxPayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxPayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>
          }
          findMany: {
            args: Prisma.TaxPayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>[]
          }
          create: {
            args: Prisma.TaxPayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>
          }
          createMany: {
            args: Prisma.TaxPayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxPayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>[]
          }
          delete: {
            args: Prisma.TaxPayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>
          }
          update: {
            args: Prisma.TaxPayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>
          }
          deleteMany: {
            args: Prisma.TaxPayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxPayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaxPayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayerPayload>
          }
          aggregate: {
            args: Prisma.TaxPayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxPayer>
          }
          groupBy: {
            args: Prisma.TaxPayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxPayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxPayerCountArgs<ExtArgs>
            result: $Utils.Optional<TaxPayerCountAggregateOutputType> | number
          }
        }
      }
      DocumentType: {
        payload: Prisma.$DocumentTypePayload<ExtArgs>
        fields: Prisma.DocumentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          findFirst: {
            args: Prisma.DocumentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          findMany: {
            args: Prisma.DocumentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>[]
          }
          create: {
            args: Prisma.DocumentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          createMany: {
            args: Prisma.DocumentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>[]
          }
          delete: {
            args: Prisma.DocumentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          update: {
            args: Prisma.DocumentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          deleteMany: {
            args: Prisma.DocumentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          aggregate: {
            args: Prisma.DocumentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentType>
          }
          groupBy: {
            args: Prisma.DocumentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentTypeCountAggregateOutputType> | number
          }
        }
      }
      EmailVerifications: {
        payload: Prisma.$EmailVerificationsPayload<ExtArgs>
        fields: Prisma.EmailVerificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailVerificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>[]
          }
          delete: {
            args: Prisma.EmailVerificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>
          }
          update: {
            args: Prisma.EmailVerificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailVerificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationsPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerifications>
          }
          groupBy: {
            args: Prisma.EmailVerificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationsCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Concepts: number
    PurchasesOrExpenses: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Concepts?: boolean | UsersCountOutputTypeCountConceptsArgs
    PurchasesOrExpenses?: boolean | UsersCountOutputTypeCountPurchasesOrExpensesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type SerialCountOutputType
   */

  export type SerialCountOutputType = {
    NcfsTypes: number
  }

  export type SerialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NcfsTypes?: boolean | SerialCountOutputTypeCountNcfsTypesArgs
  }

  // Custom InputTypes
  /**
   * SerialCountOutputType without action
   */
  export type SerialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerialCountOutputType
     */
    select?: SerialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SerialCountOutputType without action
   */
  export type SerialCountOutputTypeCountNcfsTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NcfsTypesWhereInput
  }


  /**
   * Count Type ClassificationTypeCountOutputType
   */

  export type ClassificationTypeCountOutputType = {
    Concepts: number
  }

  export type ClassificationTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Concepts?: boolean | ClassificationTypeCountOutputTypeCountConceptsArgs
  }

  // Custom InputTypes
  /**
   * ClassificationTypeCountOutputType without action
   */
  export type ClassificationTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationTypeCountOutputType
     */
    select?: ClassificationTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassificationTypeCountOutputType without action
   */
  export type ClassificationTypeCountOutputTypeCountConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptsWhereInput
  }


  /**
   * Count Type ConceptsCountOutputType
   */

  export type ConceptsCountOutputType = {
    PurchasesOrExpenses: number
  }

  export type ConceptsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | ConceptsCountOutputTypeCountPurchasesOrExpensesArgs
  }

  // Custom InputTypes
  /**
   * ConceptsCountOutputType without action
   */
  export type ConceptsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptsCountOutputType
     */
    select?: ConceptsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptsCountOutputType without action
   */
  export type ConceptsCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type RequestStatusCountOutputType
   */

  export type RequestStatusCountOutputType = {
    Requests: number
  }

  export type RequestStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Requests?: boolean | RequestStatusCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * RequestStatusCountOutputType without action
   */
  export type RequestStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusCountOutputType
     */
    select?: RequestStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestStatusCountOutputType without action
   */
  export type RequestStatusCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestsWhereInput
  }


  /**
   * Count Type RequestsCountOutputType
   */

  export type RequestsCountOutputType = {
    Documents: number
  }

  export type RequestsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Documents?: boolean | RequestsCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * RequestsCountOutputType without action
   */
  export type RequestsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestsCountOutputType
     */
    select?: RequestsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestsCountOutputType without action
   */
  export type RequestsCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
  }


  /**
   * Count Type TaxPayerTypesCountOutputType
   */

  export type TaxPayerTypesCountOutputType = {
    PurchasesOrExpenses: number
  }

  export type TaxPayerTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | TaxPayerTypesCountOutputTypeCountPurchasesOrExpensesArgs
  }

  // Custom InputTypes
  /**
   * TaxPayerTypesCountOutputType without action
   */
  export type TaxPayerTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypesCountOutputType
     */
    select?: TaxPayerTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxPayerTypesCountOutputType without action
   */
  export type TaxPayerTypesCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type InvoiceTypeCountOutputType
   */

  export type InvoiceTypeCountOutputType = {
    Concepts: number
  }

  export type InvoiceTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Concepts?: boolean | InvoiceTypeCountOutputTypeCountConceptsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceTypeCountOutputType without action
   */
  export type InvoiceTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTypeCountOutputType
     */
    select?: InvoiceTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceTypeCountOutputType without action
   */
  export type InvoiceTypeCountOutputTypeCountConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptsWhereInput
  }


  /**
   * Count Type PaymentsMethodsCountOutputType
   */

  export type PaymentsMethodsCountOutputType = {
    PurchasesOrExpenses: number
  }

  export type PaymentsMethodsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | PaymentsMethodsCountOutputTypeCountPurchasesOrExpensesArgs
  }

  // Custom InputTypes
  /**
   * PaymentsMethodsCountOutputType without action
   */
  export type PaymentsMethodsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethodsCountOutputType
     */
    select?: PaymentsMethodsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentsMethodsCountOutputType without action
   */
  export type PaymentsMethodsCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type NcfsTypesCountOutputType
   */

  export type NcfsTypesCountOutputType = {
    PurchasesOrExpenses: number
    PurchasesOrExpensesOfNcfAffected: number
  }

  export type NcfsTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | NcfsTypesCountOutputTypeCountPurchasesOrExpensesArgs
    PurchasesOrExpensesOfNcfAffected?: boolean | NcfsTypesCountOutputTypeCountPurchasesOrExpensesOfNcfAffectedArgs
  }

  // Custom InputTypes
  /**
   * NcfsTypesCountOutputType without action
   */
  export type NcfsTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypesCountOutputType
     */
    select?: NcfsTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NcfsTypesCountOutputType without action
   */
  export type NcfsTypesCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }

  /**
   * NcfsTypesCountOutputType without action
   */
  export type NcfsTypesCountOutputTypeCountPurchasesOrExpensesOfNcfAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type RetentionTaxCountOutputType
   */

  export type RetentionTaxCountOutputType = {
    PurchasesOrExpenses: number
  }

  export type RetentionTaxCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | RetentionTaxCountOutputTypeCountPurchasesOrExpensesArgs
  }

  // Custom InputTypes
  /**
   * RetentionTaxCountOutputType without action
   */
  export type RetentionTaxCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTaxCountOutputType
     */
    select?: RetentionTaxCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RetentionTaxCountOutputType without action
   */
  export type RetentionTaxCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type RetentionIsrCountOutputType
   */

  export type RetentionIsrCountOutputType = {
    PurchasesOrExpenses: number
  }

  export type RetentionIsrCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | RetentionIsrCountOutputTypeCountPurchasesOrExpensesArgs
  }

  // Custom InputTypes
  /**
   * RetentionIsrCountOutputType without action
   */
  export type RetentionIsrCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsrCountOutputType
     */
    select?: RetentionIsrCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RetentionIsrCountOutputType without action
   */
  export type RetentionIsrCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type CostTaxStatusCountOutputType
   */

  export type CostTaxStatusCountOutputType = {
    PurchasesOrExpenses: number
  }

  export type CostTaxStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | CostTaxStatusCountOutputTypeCountPurchasesOrExpensesArgs
  }

  // Custom InputTypes
  /**
   * CostTaxStatusCountOutputType without action
   */
  export type CostTaxStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatusCountOutputType
     */
    select?: CostTaxStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostTaxStatusCountOutputType without action
   */
  export type CostTaxStatusCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }


  /**
   * Count Type TaxPayerCountOutputType
   */

  export type TaxPayerCountOutputType = {
    PurchasesOrExpenses: number
    Requests: number
    Users: number
  }

  export type TaxPayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | TaxPayerCountOutputTypeCountPurchasesOrExpensesArgs
    Requests?: boolean | TaxPayerCountOutputTypeCountRequestsArgs
    Users?: boolean | TaxPayerCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * TaxPayerCountOutputType without action
   */
  export type TaxPayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerCountOutputType
     */
    select?: TaxPayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxPayerCountOutputType without action
   */
  export type TaxPayerCountOutputTypeCountPurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
  }

  /**
   * TaxPayerCountOutputType without action
   */
  export type TaxPayerCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestsWhereInput
  }

  /**
   * TaxPayerCountOutputType without action
   */
  export type TaxPayerCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type DocumentTypeCountOutputType
   */

  export type DocumentTypeCountOutputType = {
    Documents: number
  }

  export type DocumentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Documents?: boolean | DocumentTypeCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentTypeCountOutputType without action
   */
  export type DocumentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTypeCountOutputType
     */
    select?: DocumentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentTypeCountOutputType without action
   */
  export type DocumentTypeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    email: string | null
    passwordChangeMode: boolean | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    email: string | null
    passwordChangeMode: boolean | null
    enabled: boolean | null
    createdAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    password: number
    email: number
    passwordChangeMode: number
    enabled: number
    createdAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    passwordChangeMode?: true
    enabled?: true
    createdAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    passwordChangeMode?: true
    enabled?: true
    createdAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    passwordChangeMode?: true
    enabled?: true
    createdAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    username: string
    password: string
    email: string
    passwordChangeMode: boolean
    enabled: boolean
    createdAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: boolean
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    Concepts?: boolean | Users$ConceptsArgs<ExtArgs>
    PurchasesOrExpenses?: boolean | Users$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: boolean
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: boolean
  }

  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    Concepts?: boolean | Users$ConceptsArgs<ExtArgs>
    PurchasesOrExpenses?: boolean | Users$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      taxPayer: Prisma.$TaxPayerPayload<ExtArgs>
      Concepts: Prisma.$ConceptsPayload<ExtArgs>[]
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      email: string
      passwordChangeMode: boolean
      enabled: boolean
      createdAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxPayer<T extends TaxPayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayerDefaultArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Concepts<T extends Users$ConceptsArgs<ExtArgs> = {}>(args?: Subset<T, Users$ConceptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findMany"> | Null>
    PurchasesOrExpenses<T extends Users$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, Users$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly username: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly passwordChangeMode: FieldRef<"Users", 'Boolean'>
    readonly enabled: FieldRef<"Users", 'Boolean'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
  }

  /**
   * Users.Concepts
   */
  export type Users$ConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    where?: ConceptsWhereInput
    orderBy?: ConceptsOrderByWithRelationInput | ConceptsOrderByWithRelationInput[]
    cursor?: ConceptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptsScalarFieldEnum | ConceptsScalarFieldEnum[]
  }

  /**
   * Users.PurchasesOrExpenses
   */
  export type Users$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Serial
   */

  export type AggregateSerial = {
    _count: SerialCountAggregateOutputType | null
    _avg: SerialAvgAggregateOutputType | null
    _sum: SerialSumAggregateOutputType | null
    _min: SerialMinAggregateOutputType | null
    _max: SerialMaxAggregateOutputType | null
  }

  export type SerialAvgAggregateOutputType = {
    id: number | null
  }

  export type SerialSumAggregateOutputType = {
    id: number | null
  }

  export type SerialMinAggregateOutputType = {
    id: number | null
    code: string | null
  }

  export type SerialMaxAggregateOutputType = {
    id: number | null
    code: string | null
  }

  export type SerialCountAggregateOutputType = {
    id: number
    code: number
    _all: number
  }


  export type SerialAvgAggregateInputType = {
    id?: true
  }

  export type SerialSumAggregateInputType = {
    id?: true
  }

  export type SerialMinAggregateInputType = {
    id?: true
    code?: true
  }

  export type SerialMaxAggregateInputType = {
    id?: true
    code?: true
  }

  export type SerialCountAggregateInputType = {
    id?: true
    code?: true
    _all?: true
  }

  export type SerialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Serial to aggregate.
     */
    where?: SerialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Serials to fetch.
     */
    orderBy?: SerialOrderByWithRelationInput | SerialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SerialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Serials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Serials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Serials
    **/
    _count?: true | SerialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SerialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SerialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SerialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SerialMaxAggregateInputType
  }

  export type GetSerialAggregateType<T extends SerialAggregateArgs> = {
        [P in keyof T & keyof AggregateSerial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSerial[P]>
      : GetScalarType<T[P], AggregateSerial[P]>
  }




  export type SerialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SerialWhereInput
    orderBy?: SerialOrderByWithAggregationInput | SerialOrderByWithAggregationInput[]
    by: SerialScalarFieldEnum[] | SerialScalarFieldEnum
    having?: SerialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SerialCountAggregateInputType | true
    _avg?: SerialAvgAggregateInputType
    _sum?: SerialSumAggregateInputType
    _min?: SerialMinAggregateInputType
    _max?: SerialMaxAggregateInputType
  }

  export type SerialGroupByOutputType = {
    id: number
    code: string
    _count: SerialCountAggregateOutputType | null
    _avg: SerialAvgAggregateOutputType | null
    _sum: SerialSumAggregateOutputType | null
    _min: SerialMinAggregateOutputType | null
    _max: SerialMaxAggregateOutputType | null
  }

  type GetSerialGroupByPayload<T extends SerialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SerialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SerialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SerialGroupByOutputType[P]>
            : GetScalarType<T[P], SerialGroupByOutputType[P]>
        }
      >
    >


  export type SerialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    NcfsTypes?: boolean | Serial$NcfsTypesArgs<ExtArgs>
    _count?: boolean | SerialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serial"]>

  export type SerialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
  }, ExtArgs["result"]["serial"]>

  export type SerialSelectScalar = {
    id?: boolean
    code?: boolean
  }

  export type SerialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    NcfsTypes?: boolean | Serial$NcfsTypesArgs<ExtArgs>
    _count?: boolean | SerialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SerialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SerialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Serial"
    objects: {
      NcfsTypes: Prisma.$NcfsTypesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
    }, ExtArgs["result"]["serial"]>
    composites: {}
  }

  type SerialGetPayload<S extends boolean | null | undefined | SerialDefaultArgs> = $Result.GetResult<Prisma.$SerialPayload, S>

  type SerialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SerialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SerialCountAggregateInputType | true
    }

  export interface SerialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Serial'], meta: { name: 'Serial' } }
    /**
     * Find zero or one Serial that matches the filter.
     * @param {SerialFindUniqueArgs} args - Arguments to find a Serial
     * @example
     * // Get one Serial
     * const serial = await prisma.serial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SerialFindUniqueArgs>(args: SelectSubset<T, SerialFindUniqueArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Serial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SerialFindUniqueOrThrowArgs} args - Arguments to find a Serial
     * @example
     * // Get one Serial
     * const serial = await prisma.serial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SerialFindUniqueOrThrowArgs>(args: SelectSubset<T, SerialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Serial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialFindFirstArgs} args - Arguments to find a Serial
     * @example
     * // Get one Serial
     * const serial = await prisma.serial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SerialFindFirstArgs>(args?: SelectSubset<T, SerialFindFirstArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Serial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialFindFirstOrThrowArgs} args - Arguments to find a Serial
     * @example
     * // Get one Serial
     * const serial = await prisma.serial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SerialFindFirstOrThrowArgs>(args?: SelectSubset<T, SerialFindFirstOrThrowArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Serials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serials
     * const serials = await prisma.serial.findMany()
     * 
     * // Get first 10 Serials
     * const serials = await prisma.serial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serialWithIdOnly = await prisma.serial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SerialFindManyArgs>(args?: SelectSubset<T, SerialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Serial.
     * @param {SerialCreateArgs} args - Arguments to create a Serial.
     * @example
     * // Create one Serial
     * const Serial = await prisma.serial.create({
     *   data: {
     *     // ... data to create a Serial
     *   }
     * })
     * 
     */
    create<T extends SerialCreateArgs>(args: SelectSubset<T, SerialCreateArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Serials.
     * @param {SerialCreateManyArgs} args - Arguments to create many Serials.
     * @example
     * // Create many Serials
     * const serial = await prisma.serial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SerialCreateManyArgs>(args?: SelectSubset<T, SerialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Serials and returns the data saved in the database.
     * @param {SerialCreateManyAndReturnArgs} args - Arguments to create many Serials.
     * @example
     * // Create many Serials
     * const serial = await prisma.serial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Serials and only return the `id`
     * const serialWithIdOnly = await prisma.serial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SerialCreateManyAndReturnArgs>(args?: SelectSubset<T, SerialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Serial.
     * @param {SerialDeleteArgs} args - Arguments to delete one Serial.
     * @example
     * // Delete one Serial
     * const Serial = await prisma.serial.delete({
     *   where: {
     *     // ... filter to delete one Serial
     *   }
     * })
     * 
     */
    delete<T extends SerialDeleteArgs>(args: SelectSubset<T, SerialDeleteArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Serial.
     * @param {SerialUpdateArgs} args - Arguments to update one Serial.
     * @example
     * // Update one Serial
     * const serial = await prisma.serial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SerialUpdateArgs>(args: SelectSubset<T, SerialUpdateArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Serials.
     * @param {SerialDeleteManyArgs} args - Arguments to filter Serials to delete.
     * @example
     * // Delete a few Serials
     * const { count } = await prisma.serial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SerialDeleteManyArgs>(args?: SelectSubset<T, SerialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serials
     * const serial = await prisma.serial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SerialUpdateManyArgs>(args: SelectSubset<T, SerialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serial.
     * @param {SerialUpsertArgs} args - Arguments to update or create a Serial.
     * @example
     * // Update or create a Serial
     * const serial = await prisma.serial.upsert({
     *   create: {
     *     // ... data to create a Serial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serial we want to update
     *   }
     * })
     */
    upsert<T extends SerialUpsertArgs>(args: SelectSubset<T, SerialUpsertArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Serials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialCountArgs} args - Arguments to filter Serials to count.
     * @example
     * // Count the number of Serials
     * const count = await prisma.serial.count({
     *   where: {
     *     // ... the filter for the Serials we want to count
     *   }
     * })
    **/
    count<T extends SerialCountArgs>(
      args?: Subset<T, SerialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SerialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SerialAggregateArgs>(args: Subset<T, SerialAggregateArgs>): Prisma.PrismaPromise<GetSerialAggregateType<T>>

    /**
     * Group by Serial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SerialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SerialGroupByArgs['orderBy'] }
        : { orderBy?: SerialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SerialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSerialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Serial model
   */
  readonly fields: SerialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Serial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SerialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    NcfsTypes<T extends Serial$NcfsTypesArgs<ExtArgs> = {}>(args?: Subset<T, Serial$NcfsTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Serial model
   */ 
  interface SerialFieldRefs {
    readonly id: FieldRef<"Serial", 'Int'>
    readonly code: FieldRef<"Serial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Serial findUnique
   */
  export type SerialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * Filter, which Serial to fetch.
     */
    where: SerialWhereUniqueInput
  }

  /**
   * Serial findUniqueOrThrow
   */
  export type SerialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * Filter, which Serial to fetch.
     */
    where: SerialWhereUniqueInput
  }

  /**
   * Serial findFirst
   */
  export type SerialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * Filter, which Serial to fetch.
     */
    where?: SerialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Serials to fetch.
     */
    orderBy?: SerialOrderByWithRelationInput | SerialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Serials.
     */
    cursor?: SerialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Serials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Serials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Serials.
     */
    distinct?: SerialScalarFieldEnum | SerialScalarFieldEnum[]
  }

  /**
   * Serial findFirstOrThrow
   */
  export type SerialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * Filter, which Serial to fetch.
     */
    where?: SerialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Serials to fetch.
     */
    orderBy?: SerialOrderByWithRelationInput | SerialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Serials.
     */
    cursor?: SerialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Serials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Serials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Serials.
     */
    distinct?: SerialScalarFieldEnum | SerialScalarFieldEnum[]
  }

  /**
   * Serial findMany
   */
  export type SerialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * Filter, which Serials to fetch.
     */
    where?: SerialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Serials to fetch.
     */
    orderBy?: SerialOrderByWithRelationInput | SerialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Serials.
     */
    cursor?: SerialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Serials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Serials.
     */
    skip?: number
    distinct?: SerialScalarFieldEnum | SerialScalarFieldEnum[]
  }

  /**
   * Serial create
   */
  export type SerialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * The data needed to create a Serial.
     */
    data: XOR<SerialCreateInput, SerialUncheckedCreateInput>
  }

  /**
   * Serial createMany
   */
  export type SerialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Serials.
     */
    data: SerialCreateManyInput | SerialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Serial createManyAndReturn
   */
  export type SerialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Serials.
     */
    data: SerialCreateManyInput | SerialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Serial update
   */
  export type SerialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * The data needed to update a Serial.
     */
    data: XOR<SerialUpdateInput, SerialUncheckedUpdateInput>
    /**
     * Choose, which Serial to update.
     */
    where: SerialWhereUniqueInput
  }

  /**
   * Serial updateMany
   */
  export type SerialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Serials.
     */
    data: XOR<SerialUpdateManyMutationInput, SerialUncheckedUpdateManyInput>
    /**
     * Filter which Serials to update
     */
    where?: SerialWhereInput
  }

  /**
   * Serial upsert
   */
  export type SerialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * The filter to search for the Serial to update in case it exists.
     */
    where: SerialWhereUniqueInput
    /**
     * In case the Serial found by the `where` argument doesn't exist, create a new Serial with this data.
     */
    create: XOR<SerialCreateInput, SerialUncheckedCreateInput>
    /**
     * In case the Serial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SerialUpdateInput, SerialUncheckedUpdateInput>
  }

  /**
   * Serial delete
   */
  export type SerialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
    /**
     * Filter which Serial to delete.
     */
    where: SerialWhereUniqueInput
  }

  /**
   * Serial deleteMany
   */
  export type SerialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Serials to delete
     */
    where?: SerialWhereInput
  }

  /**
   * Serial.NcfsTypes
   */
  export type Serial$NcfsTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    where?: NcfsTypesWhereInput
    orderBy?: NcfsTypesOrderByWithRelationInput | NcfsTypesOrderByWithRelationInput[]
    cursor?: NcfsTypesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NcfsTypesScalarFieldEnum | NcfsTypesScalarFieldEnum[]
  }

  /**
   * Serial without action
   */
  export type SerialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Serial
     */
    select?: SerialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerialInclude<ExtArgs> | null
  }


  /**
   * Model ClassificationType
   */

  export type AggregateClassificationType = {
    _count: ClassificationTypeCountAggregateOutputType | null
    _avg: ClassificationTypeAvgAggregateOutputType | null
    _sum: ClassificationTypeSumAggregateOutputType | null
    _min: ClassificationTypeMinAggregateOutputType | null
    _max: ClassificationTypeMaxAggregateOutputType | null
  }

  export type ClassificationTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ClassificationTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ClassificationTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ClassificationTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ClassificationTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ClassificationTypeAvgAggregateInputType = {
    id?: true
  }

  export type ClassificationTypeSumAggregateInputType = {
    id?: true
  }

  export type ClassificationTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ClassificationTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ClassificationTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ClassificationTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassificationType to aggregate.
     */
    where?: ClassificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificationTypes to fetch.
     */
    orderBy?: ClassificationTypeOrderByWithRelationInput | ClassificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassificationTypes
    **/
    _count?: true | ClassificationTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassificationTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassificationTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassificationTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassificationTypeMaxAggregateInputType
  }

  export type GetClassificationTypeAggregateType<T extends ClassificationTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateClassificationType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassificationType[P]>
      : GetScalarType<T[P], AggregateClassificationType[P]>
  }




  export type ClassificationTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassificationTypeWhereInput
    orderBy?: ClassificationTypeOrderByWithAggregationInput | ClassificationTypeOrderByWithAggregationInput[]
    by: ClassificationTypeScalarFieldEnum[] | ClassificationTypeScalarFieldEnum
    having?: ClassificationTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassificationTypeCountAggregateInputType | true
    _avg?: ClassificationTypeAvgAggregateInputType
    _sum?: ClassificationTypeSumAggregateInputType
    _min?: ClassificationTypeMinAggregateInputType
    _max?: ClassificationTypeMaxAggregateInputType
  }

  export type ClassificationTypeGroupByOutputType = {
    id: number
    name: string
    _count: ClassificationTypeCountAggregateOutputType | null
    _avg: ClassificationTypeAvgAggregateOutputType | null
    _sum: ClassificationTypeSumAggregateOutputType | null
    _min: ClassificationTypeMinAggregateOutputType | null
    _max: ClassificationTypeMaxAggregateOutputType | null
  }

  type GetClassificationTypeGroupByPayload<T extends ClassificationTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassificationTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassificationTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassificationTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ClassificationTypeGroupByOutputType[P]>
        }
      >
    >


  export type ClassificationTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    Concepts?: boolean | ClassificationType$ConceptsArgs<ExtArgs>
    _count?: boolean | ClassificationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classificationType"]>

  export type ClassificationTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["classificationType"]>

  export type ClassificationTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ClassificationTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Concepts?: boolean | ClassificationType$ConceptsArgs<ExtArgs>
    _count?: boolean | ClassificationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassificationTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassificationTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassificationType"
    objects: {
      Concepts: Prisma.$ConceptsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["classificationType"]>
    composites: {}
  }

  type ClassificationTypeGetPayload<S extends boolean | null | undefined | ClassificationTypeDefaultArgs> = $Result.GetResult<Prisma.$ClassificationTypePayload, S>

  type ClassificationTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassificationTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassificationTypeCountAggregateInputType | true
    }

  export interface ClassificationTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassificationType'], meta: { name: 'ClassificationType' } }
    /**
     * Find zero or one ClassificationType that matches the filter.
     * @param {ClassificationTypeFindUniqueArgs} args - Arguments to find a ClassificationType
     * @example
     * // Get one ClassificationType
     * const classificationType = await prisma.classificationType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassificationTypeFindUniqueArgs>(args: SelectSubset<T, ClassificationTypeFindUniqueArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassificationType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassificationTypeFindUniqueOrThrowArgs} args - Arguments to find a ClassificationType
     * @example
     * // Get one ClassificationType
     * const classificationType = await prisma.classificationType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassificationTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassificationTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassificationType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationTypeFindFirstArgs} args - Arguments to find a ClassificationType
     * @example
     * // Get one ClassificationType
     * const classificationType = await prisma.classificationType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassificationTypeFindFirstArgs>(args?: SelectSubset<T, ClassificationTypeFindFirstArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassificationType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationTypeFindFirstOrThrowArgs} args - Arguments to find a ClassificationType
     * @example
     * // Get one ClassificationType
     * const classificationType = await prisma.classificationType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassificationTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassificationTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassificationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassificationTypes
     * const classificationTypes = await prisma.classificationType.findMany()
     * 
     * // Get first 10 ClassificationTypes
     * const classificationTypes = await prisma.classificationType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classificationTypeWithIdOnly = await prisma.classificationType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassificationTypeFindManyArgs>(args?: SelectSubset<T, ClassificationTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassificationType.
     * @param {ClassificationTypeCreateArgs} args - Arguments to create a ClassificationType.
     * @example
     * // Create one ClassificationType
     * const ClassificationType = await prisma.classificationType.create({
     *   data: {
     *     // ... data to create a ClassificationType
     *   }
     * })
     * 
     */
    create<T extends ClassificationTypeCreateArgs>(args: SelectSubset<T, ClassificationTypeCreateArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassificationTypes.
     * @param {ClassificationTypeCreateManyArgs} args - Arguments to create many ClassificationTypes.
     * @example
     * // Create many ClassificationTypes
     * const classificationType = await prisma.classificationType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassificationTypeCreateManyArgs>(args?: SelectSubset<T, ClassificationTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassificationTypes and returns the data saved in the database.
     * @param {ClassificationTypeCreateManyAndReturnArgs} args - Arguments to create many ClassificationTypes.
     * @example
     * // Create many ClassificationTypes
     * const classificationType = await prisma.classificationType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassificationTypes and only return the `id`
     * const classificationTypeWithIdOnly = await prisma.classificationType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassificationTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassificationTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassificationType.
     * @param {ClassificationTypeDeleteArgs} args - Arguments to delete one ClassificationType.
     * @example
     * // Delete one ClassificationType
     * const ClassificationType = await prisma.classificationType.delete({
     *   where: {
     *     // ... filter to delete one ClassificationType
     *   }
     * })
     * 
     */
    delete<T extends ClassificationTypeDeleteArgs>(args: SelectSubset<T, ClassificationTypeDeleteArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassificationType.
     * @param {ClassificationTypeUpdateArgs} args - Arguments to update one ClassificationType.
     * @example
     * // Update one ClassificationType
     * const classificationType = await prisma.classificationType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassificationTypeUpdateArgs>(args: SelectSubset<T, ClassificationTypeUpdateArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassificationTypes.
     * @param {ClassificationTypeDeleteManyArgs} args - Arguments to filter ClassificationTypes to delete.
     * @example
     * // Delete a few ClassificationTypes
     * const { count } = await prisma.classificationType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassificationTypeDeleteManyArgs>(args?: SelectSubset<T, ClassificationTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassificationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassificationTypes
     * const classificationType = await prisma.classificationType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassificationTypeUpdateManyArgs>(args: SelectSubset<T, ClassificationTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassificationType.
     * @param {ClassificationTypeUpsertArgs} args - Arguments to update or create a ClassificationType.
     * @example
     * // Update or create a ClassificationType
     * const classificationType = await prisma.classificationType.upsert({
     *   create: {
     *     // ... data to create a ClassificationType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassificationType we want to update
     *   }
     * })
     */
    upsert<T extends ClassificationTypeUpsertArgs>(args: SelectSubset<T, ClassificationTypeUpsertArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassificationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationTypeCountArgs} args - Arguments to filter ClassificationTypes to count.
     * @example
     * // Count the number of ClassificationTypes
     * const count = await prisma.classificationType.count({
     *   where: {
     *     // ... the filter for the ClassificationTypes we want to count
     *   }
     * })
    **/
    count<T extends ClassificationTypeCountArgs>(
      args?: Subset<T, ClassificationTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassificationTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassificationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassificationTypeAggregateArgs>(args: Subset<T, ClassificationTypeAggregateArgs>): Prisma.PrismaPromise<GetClassificationTypeAggregateType<T>>

    /**
     * Group by ClassificationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassificationTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassificationTypeGroupByArgs['orderBy'] }
        : { orderBy?: ClassificationTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassificationTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassificationTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassificationType model
   */
  readonly fields: ClassificationTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassificationType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassificationTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Concepts<T extends ClassificationType$ConceptsArgs<ExtArgs> = {}>(args?: Subset<T, ClassificationType$ConceptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassificationType model
   */ 
  interface ClassificationTypeFieldRefs {
    readonly id: FieldRef<"ClassificationType", 'Int'>
    readonly name: FieldRef<"ClassificationType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassificationType findUnique
   */
  export type ClassificationTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClassificationType to fetch.
     */
    where: ClassificationTypeWhereUniqueInput
  }

  /**
   * ClassificationType findUniqueOrThrow
   */
  export type ClassificationTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClassificationType to fetch.
     */
    where: ClassificationTypeWhereUniqueInput
  }

  /**
   * ClassificationType findFirst
   */
  export type ClassificationTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClassificationType to fetch.
     */
    where?: ClassificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificationTypes to fetch.
     */
    orderBy?: ClassificationTypeOrderByWithRelationInput | ClassificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassificationTypes.
     */
    cursor?: ClassificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassificationTypes.
     */
    distinct?: ClassificationTypeScalarFieldEnum | ClassificationTypeScalarFieldEnum[]
  }

  /**
   * ClassificationType findFirstOrThrow
   */
  export type ClassificationTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClassificationType to fetch.
     */
    where?: ClassificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificationTypes to fetch.
     */
    orderBy?: ClassificationTypeOrderByWithRelationInput | ClassificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassificationTypes.
     */
    cursor?: ClassificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassificationTypes.
     */
    distinct?: ClassificationTypeScalarFieldEnum | ClassificationTypeScalarFieldEnum[]
  }

  /**
   * ClassificationType findMany
   */
  export type ClassificationTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClassificationTypes to fetch.
     */
    where?: ClassificationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificationTypes to fetch.
     */
    orderBy?: ClassificationTypeOrderByWithRelationInput | ClassificationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassificationTypes.
     */
    cursor?: ClassificationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificationTypes.
     */
    skip?: number
    distinct?: ClassificationTypeScalarFieldEnum | ClassificationTypeScalarFieldEnum[]
  }

  /**
   * ClassificationType create
   */
  export type ClassificationTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassificationType.
     */
    data: XOR<ClassificationTypeCreateInput, ClassificationTypeUncheckedCreateInput>
  }

  /**
   * ClassificationType createMany
   */
  export type ClassificationTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassificationTypes.
     */
    data: ClassificationTypeCreateManyInput | ClassificationTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassificationType createManyAndReturn
   */
  export type ClassificationTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassificationTypes.
     */
    data: ClassificationTypeCreateManyInput | ClassificationTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassificationType update
   */
  export type ClassificationTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassificationType.
     */
    data: XOR<ClassificationTypeUpdateInput, ClassificationTypeUncheckedUpdateInput>
    /**
     * Choose, which ClassificationType to update.
     */
    where: ClassificationTypeWhereUniqueInput
  }

  /**
   * ClassificationType updateMany
   */
  export type ClassificationTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassificationTypes.
     */
    data: XOR<ClassificationTypeUpdateManyMutationInput, ClassificationTypeUncheckedUpdateManyInput>
    /**
     * Filter which ClassificationTypes to update
     */
    where?: ClassificationTypeWhereInput
  }

  /**
   * ClassificationType upsert
   */
  export type ClassificationTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassificationType to update in case it exists.
     */
    where: ClassificationTypeWhereUniqueInput
    /**
     * In case the ClassificationType found by the `where` argument doesn't exist, create a new ClassificationType with this data.
     */
    create: XOR<ClassificationTypeCreateInput, ClassificationTypeUncheckedCreateInput>
    /**
     * In case the ClassificationType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassificationTypeUpdateInput, ClassificationTypeUncheckedUpdateInput>
  }

  /**
   * ClassificationType delete
   */
  export type ClassificationTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
    /**
     * Filter which ClassificationType to delete.
     */
    where: ClassificationTypeWhereUniqueInput
  }

  /**
   * ClassificationType deleteMany
   */
  export type ClassificationTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassificationTypes to delete
     */
    where?: ClassificationTypeWhereInput
  }

  /**
   * ClassificationType.Concepts
   */
  export type ClassificationType$ConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    where?: ConceptsWhereInput
    orderBy?: ConceptsOrderByWithRelationInput | ConceptsOrderByWithRelationInput[]
    cursor?: ConceptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptsScalarFieldEnum | ConceptsScalarFieldEnum[]
  }

  /**
   * ClassificationType without action
   */
  export type ClassificationTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationType
     */
    select?: ClassificationTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationTypeInclude<ExtArgs> | null
  }


  /**
   * Model Concepts
   */

  export type AggregateConcepts = {
    _count: ConceptsCountAggregateOutputType | null
    _avg: ConceptsAvgAggregateOutputType | null
    _sum: ConceptsSumAggregateOutputType | null
    _min: ConceptsMinAggregateOutputType | null
    _max: ConceptsMaxAggregateOutputType | null
  }

  export type ConceptsAvgAggregateOutputType = {
    id: number | null
    classificationTypeId: number | null
  }

  export type ConceptsSumAggregateOutputType = {
    id: number | null
    classificationTypeId: number | null
  }

  export type ConceptsMinAggregateOutputType = {
    id: number | null
    name: string | null
    authorId: string | null
    invoiceTypeId: string | null
    classificationTypeId: number | null
  }

  export type ConceptsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    authorId: string | null
    invoiceTypeId: string | null
    classificationTypeId: number | null
  }

  export type ConceptsCountAggregateOutputType = {
    id: number
    name: number
    authorId: number
    invoiceTypeId: number
    classificationTypeId: number
    _all: number
  }


  export type ConceptsAvgAggregateInputType = {
    id?: true
    classificationTypeId?: true
  }

  export type ConceptsSumAggregateInputType = {
    id?: true
    classificationTypeId?: true
  }

  export type ConceptsMinAggregateInputType = {
    id?: true
    name?: true
    authorId?: true
    invoiceTypeId?: true
    classificationTypeId?: true
  }

  export type ConceptsMaxAggregateInputType = {
    id?: true
    name?: true
    authorId?: true
    invoiceTypeId?: true
    classificationTypeId?: true
  }

  export type ConceptsCountAggregateInputType = {
    id?: true
    name?: true
    authorId?: true
    invoiceTypeId?: true
    classificationTypeId?: true
    _all?: true
  }

  export type ConceptsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concepts to aggregate.
     */
    where?: ConceptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptsOrderByWithRelationInput | ConceptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Concepts
    **/
    _count?: true | ConceptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConceptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConceptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptsMaxAggregateInputType
  }

  export type GetConceptsAggregateType<T extends ConceptsAggregateArgs> = {
        [P in keyof T & keyof AggregateConcepts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConcepts[P]>
      : GetScalarType<T[P], AggregateConcepts[P]>
  }




  export type ConceptsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptsWhereInput
    orderBy?: ConceptsOrderByWithAggregationInput | ConceptsOrderByWithAggregationInput[]
    by: ConceptsScalarFieldEnum[] | ConceptsScalarFieldEnum
    having?: ConceptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptsCountAggregateInputType | true
    _avg?: ConceptsAvgAggregateInputType
    _sum?: ConceptsSumAggregateInputType
    _min?: ConceptsMinAggregateInputType
    _max?: ConceptsMaxAggregateInputType
  }

  export type ConceptsGroupByOutputType = {
    id: number
    name: string
    authorId: string
    invoiceTypeId: string
    classificationTypeId: number
    _count: ConceptsCountAggregateOutputType | null
    _avg: ConceptsAvgAggregateOutputType | null
    _sum: ConceptsSumAggregateOutputType | null
    _min: ConceptsMinAggregateOutputType | null
    _max: ConceptsMaxAggregateOutputType | null
  }

  type GetConceptsGroupByPayload<T extends ConceptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptsGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptsGroupByOutputType[P]>
        }
      >
    >


  export type ConceptsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    authorId?: boolean
    invoiceTypeId?: boolean
    classificationTypeId?: boolean
    classificationType?: boolean | ClassificationTypeDefaultArgs<ExtArgs>
    invoiceType?: boolean | InvoiceTypeDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
    PurchasesOrExpenses?: boolean | Concepts$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | ConceptsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["concepts"]>

  export type ConceptsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    authorId?: boolean
    invoiceTypeId?: boolean
    classificationTypeId?: boolean
    classificationType?: boolean | ClassificationTypeDefaultArgs<ExtArgs>
    invoiceType?: boolean | InvoiceTypeDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["concepts"]>

  export type ConceptsSelectScalar = {
    id?: boolean
    name?: boolean
    authorId?: boolean
    invoiceTypeId?: boolean
    classificationTypeId?: boolean
  }

  export type ConceptsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classificationType?: boolean | ClassificationTypeDefaultArgs<ExtArgs>
    invoiceType?: boolean | InvoiceTypeDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
    PurchasesOrExpenses?: boolean | Concepts$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | ConceptsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConceptsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classificationType?: boolean | ClassificationTypeDefaultArgs<ExtArgs>
    invoiceType?: boolean | InvoiceTypeDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConceptsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Concepts"
    objects: {
      classificationType: Prisma.$ClassificationTypePayload<ExtArgs>
      invoiceType: Prisma.$InvoiceTypePayload<ExtArgs>
      author: Prisma.$UsersPayload<ExtArgs>
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      authorId: string
      invoiceTypeId: string
      classificationTypeId: number
    }, ExtArgs["result"]["concepts"]>
    composites: {}
  }

  type ConceptsGetPayload<S extends boolean | null | undefined | ConceptsDefaultArgs> = $Result.GetResult<Prisma.$ConceptsPayload, S>

  type ConceptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptsCountAggregateInputType | true
    }

  export interface ConceptsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Concepts'], meta: { name: 'Concepts' } }
    /**
     * Find zero or one Concepts that matches the filter.
     * @param {ConceptsFindUniqueArgs} args - Arguments to find a Concepts
     * @example
     * // Get one Concepts
     * const concepts = await prisma.concepts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConceptsFindUniqueArgs>(args: SelectSubset<T, ConceptsFindUniqueArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Concepts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConceptsFindUniqueOrThrowArgs} args - Arguments to find a Concepts
     * @example
     * // Get one Concepts
     * const concepts = await prisma.concepts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConceptsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConceptsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Concepts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptsFindFirstArgs} args - Arguments to find a Concepts
     * @example
     * // Get one Concepts
     * const concepts = await prisma.concepts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConceptsFindFirstArgs>(args?: SelectSubset<T, ConceptsFindFirstArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Concepts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptsFindFirstOrThrowArgs} args - Arguments to find a Concepts
     * @example
     * // Get one Concepts
     * const concepts = await prisma.concepts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConceptsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConceptsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Concepts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Concepts
     * const concepts = await prisma.concepts.findMany()
     * 
     * // Get first 10 Concepts
     * const concepts = await prisma.concepts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptsWithIdOnly = await prisma.concepts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConceptsFindManyArgs>(args?: SelectSubset<T, ConceptsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Concepts.
     * @param {ConceptsCreateArgs} args - Arguments to create a Concepts.
     * @example
     * // Create one Concepts
     * const Concepts = await prisma.concepts.create({
     *   data: {
     *     // ... data to create a Concepts
     *   }
     * })
     * 
     */
    create<T extends ConceptsCreateArgs>(args: SelectSubset<T, ConceptsCreateArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Concepts.
     * @param {ConceptsCreateManyArgs} args - Arguments to create many Concepts.
     * @example
     * // Create many Concepts
     * const concepts = await prisma.concepts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConceptsCreateManyArgs>(args?: SelectSubset<T, ConceptsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Concepts and returns the data saved in the database.
     * @param {ConceptsCreateManyAndReturnArgs} args - Arguments to create many Concepts.
     * @example
     * // Create many Concepts
     * const concepts = await prisma.concepts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Concepts and only return the `id`
     * const conceptsWithIdOnly = await prisma.concepts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConceptsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConceptsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Concepts.
     * @param {ConceptsDeleteArgs} args - Arguments to delete one Concepts.
     * @example
     * // Delete one Concepts
     * const Concepts = await prisma.concepts.delete({
     *   where: {
     *     // ... filter to delete one Concepts
     *   }
     * })
     * 
     */
    delete<T extends ConceptsDeleteArgs>(args: SelectSubset<T, ConceptsDeleteArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Concepts.
     * @param {ConceptsUpdateArgs} args - Arguments to update one Concepts.
     * @example
     * // Update one Concepts
     * const concepts = await prisma.concepts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConceptsUpdateArgs>(args: SelectSubset<T, ConceptsUpdateArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Concepts.
     * @param {ConceptsDeleteManyArgs} args - Arguments to filter Concepts to delete.
     * @example
     * // Delete a few Concepts
     * const { count } = await prisma.concepts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConceptsDeleteManyArgs>(args?: SelectSubset<T, ConceptsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Concepts
     * const concepts = await prisma.concepts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConceptsUpdateManyArgs>(args: SelectSubset<T, ConceptsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Concepts.
     * @param {ConceptsUpsertArgs} args - Arguments to update or create a Concepts.
     * @example
     * // Update or create a Concepts
     * const concepts = await prisma.concepts.upsert({
     *   create: {
     *     // ... data to create a Concepts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Concepts we want to update
     *   }
     * })
     */
    upsert<T extends ConceptsUpsertArgs>(args: SelectSubset<T, ConceptsUpsertArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptsCountArgs} args - Arguments to filter Concepts to count.
     * @example
     * // Count the number of Concepts
     * const count = await prisma.concepts.count({
     *   where: {
     *     // ... the filter for the Concepts we want to count
     *   }
     * })
    **/
    count<T extends ConceptsCountArgs>(
      args?: Subset<T, ConceptsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptsAggregateArgs>(args: Subset<T, ConceptsAggregateArgs>): Prisma.PrismaPromise<GetConceptsAggregateType<T>>

    /**
     * Group by Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptsGroupByArgs['orderBy'] }
        : { orderBy?: ConceptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Concepts model
   */
  readonly fields: ConceptsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Concepts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classificationType<T extends ClassificationTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassificationTypeDefaultArgs<ExtArgs>>): Prisma__ClassificationTypeClient<$Result.GetResult<Prisma.$ClassificationTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoiceType<T extends InvoiceTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceTypeDefaultArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    PurchasesOrExpenses<T extends Concepts$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, Concepts$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Concepts model
   */ 
  interface ConceptsFieldRefs {
    readonly id: FieldRef<"Concepts", 'Int'>
    readonly name: FieldRef<"Concepts", 'String'>
    readonly authorId: FieldRef<"Concepts", 'String'>
    readonly invoiceTypeId: FieldRef<"Concepts", 'String'>
    readonly classificationTypeId: FieldRef<"Concepts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Concepts findUnique
   */
  export type ConceptsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * Filter, which Concepts to fetch.
     */
    where: ConceptsWhereUniqueInput
  }

  /**
   * Concepts findUniqueOrThrow
   */
  export type ConceptsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * Filter, which Concepts to fetch.
     */
    where: ConceptsWhereUniqueInput
  }

  /**
   * Concepts findFirst
   */
  export type ConceptsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * Filter, which Concepts to fetch.
     */
    where?: ConceptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptsOrderByWithRelationInput | ConceptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concepts.
     */
    cursor?: ConceptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concepts.
     */
    distinct?: ConceptsScalarFieldEnum | ConceptsScalarFieldEnum[]
  }

  /**
   * Concepts findFirstOrThrow
   */
  export type ConceptsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * Filter, which Concepts to fetch.
     */
    where?: ConceptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptsOrderByWithRelationInput | ConceptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concepts.
     */
    cursor?: ConceptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concepts.
     */
    distinct?: ConceptsScalarFieldEnum | ConceptsScalarFieldEnum[]
  }

  /**
   * Concepts findMany
   */
  export type ConceptsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * Filter, which Concepts to fetch.
     */
    where?: ConceptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptsOrderByWithRelationInput | ConceptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Concepts.
     */
    cursor?: ConceptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    distinct?: ConceptsScalarFieldEnum | ConceptsScalarFieldEnum[]
  }

  /**
   * Concepts create
   */
  export type ConceptsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * The data needed to create a Concepts.
     */
    data: XOR<ConceptsCreateInput, ConceptsUncheckedCreateInput>
  }

  /**
   * Concepts createMany
   */
  export type ConceptsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Concepts.
     */
    data: ConceptsCreateManyInput | ConceptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Concepts createManyAndReturn
   */
  export type ConceptsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Concepts.
     */
    data: ConceptsCreateManyInput | ConceptsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Concepts update
   */
  export type ConceptsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * The data needed to update a Concepts.
     */
    data: XOR<ConceptsUpdateInput, ConceptsUncheckedUpdateInput>
    /**
     * Choose, which Concepts to update.
     */
    where: ConceptsWhereUniqueInput
  }

  /**
   * Concepts updateMany
   */
  export type ConceptsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Concepts.
     */
    data: XOR<ConceptsUpdateManyMutationInput, ConceptsUncheckedUpdateManyInput>
    /**
     * Filter which Concepts to update
     */
    where?: ConceptsWhereInput
  }

  /**
   * Concepts upsert
   */
  export type ConceptsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * The filter to search for the Concepts to update in case it exists.
     */
    where: ConceptsWhereUniqueInput
    /**
     * In case the Concepts found by the `where` argument doesn't exist, create a new Concepts with this data.
     */
    create: XOR<ConceptsCreateInput, ConceptsUncheckedCreateInput>
    /**
     * In case the Concepts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptsUpdateInput, ConceptsUncheckedUpdateInput>
  }

  /**
   * Concepts delete
   */
  export type ConceptsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    /**
     * Filter which Concepts to delete.
     */
    where: ConceptsWhereUniqueInput
  }

  /**
   * Concepts deleteMany
   */
  export type ConceptsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concepts to delete
     */
    where?: ConceptsWhereInput
  }

  /**
   * Concepts.PurchasesOrExpenses
   */
  export type Concepts$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * Concepts without action
   */
  export type ConceptsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
  }


  /**
   * Model RequestStatus
   */

  export type AggregateRequestStatus = {
    _count: RequestStatusCountAggregateOutputType | null
    _avg: RequestStatusAvgAggregateOutputType | null
    _sum: RequestStatusSumAggregateOutputType | null
    _min: RequestStatusMinAggregateOutputType | null
    _max: RequestStatusMaxAggregateOutputType | null
  }

  export type RequestStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type RequestStatusSumAggregateOutputType = {
    id: number | null
  }

  export type RequestStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type RequestStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type RequestStatusCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type RequestStatusAvgAggregateInputType = {
    id?: true
  }

  export type RequestStatusSumAggregateInputType = {
    id?: true
  }

  export type RequestStatusMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type RequestStatusMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type RequestStatusCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type RequestStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestStatus to aggregate.
     */
    where?: RequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatuses to fetch.
     */
    orderBy?: RequestStatusOrderByWithRelationInput | RequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestStatuses
    **/
    _count?: true | RequestStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestStatusMaxAggregateInputType
  }

  export type GetRequestStatusAggregateType<T extends RequestStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestStatus[P]>
      : GetScalarType<T[P], AggregateRequestStatus[P]>
  }




  export type RequestStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestStatusWhereInput
    orderBy?: RequestStatusOrderByWithAggregationInput | RequestStatusOrderByWithAggregationInput[]
    by: RequestStatusScalarFieldEnum[] | RequestStatusScalarFieldEnum
    having?: RequestStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestStatusCountAggregateInputType | true
    _avg?: RequestStatusAvgAggregateInputType
    _sum?: RequestStatusSumAggregateInputType
    _min?: RequestStatusMinAggregateInputType
    _max?: RequestStatusMaxAggregateInputType
  }

  export type RequestStatusGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: RequestStatusCountAggregateOutputType | null
    _avg: RequestStatusAvgAggregateOutputType | null
    _sum: RequestStatusSumAggregateOutputType | null
    _min: RequestStatusMinAggregateOutputType | null
    _max: RequestStatusMaxAggregateOutputType | null
  }

  type GetRequestStatusGroupByPayload<T extends RequestStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestStatusGroupByOutputType[P]>
            : GetScalarType<T[P], RequestStatusGroupByOutputType[P]>
        }
      >
    >


  export type RequestStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    Requests?: boolean | RequestStatus$RequestsArgs<ExtArgs>
    _count?: boolean | RequestStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestStatus"]>

  export type RequestStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["requestStatus"]>

  export type RequestStatusSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type RequestStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Requests?: boolean | RequestStatus$RequestsArgs<ExtArgs>
    _count?: boolean | RequestStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RequestStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestStatus"
    objects: {
      Requests: Prisma.$RequestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["requestStatus"]>
    composites: {}
  }

  type RequestStatusGetPayload<S extends boolean | null | undefined | RequestStatusDefaultArgs> = $Result.GetResult<Prisma.$RequestStatusPayload, S>

  type RequestStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RequestStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RequestStatusCountAggregateInputType | true
    }

  export interface RequestStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestStatus'], meta: { name: 'RequestStatus' } }
    /**
     * Find zero or one RequestStatus that matches the filter.
     * @param {RequestStatusFindUniqueArgs} args - Arguments to find a RequestStatus
     * @example
     * // Get one RequestStatus
     * const requestStatus = await prisma.requestStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestStatusFindUniqueArgs>(args: SelectSubset<T, RequestStatusFindUniqueArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RequestStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RequestStatusFindUniqueOrThrowArgs} args - Arguments to find a RequestStatus
     * @example
     * // Get one RequestStatus
     * const requestStatus = await prisma.requestStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RequestStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusFindFirstArgs} args - Arguments to find a RequestStatus
     * @example
     * // Get one RequestStatus
     * const requestStatus = await prisma.requestStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestStatusFindFirstArgs>(args?: SelectSubset<T, RequestStatusFindFirstArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RequestStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusFindFirstOrThrowArgs} args - Arguments to find a RequestStatus
     * @example
     * // Get one RequestStatus
     * const requestStatus = await prisma.requestStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RequestStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestStatuses
     * const requestStatuses = await prisma.requestStatus.findMany()
     * 
     * // Get first 10 RequestStatuses
     * const requestStatuses = await prisma.requestStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestStatusWithIdOnly = await prisma.requestStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestStatusFindManyArgs>(args?: SelectSubset<T, RequestStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RequestStatus.
     * @param {RequestStatusCreateArgs} args - Arguments to create a RequestStatus.
     * @example
     * // Create one RequestStatus
     * const RequestStatus = await prisma.requestStatus.create({
     *   data: {
     *     // ... data to create a RequestStatus
     *   }
     * })
     * 
     */
    create<T extends RequestStatusCreateArgs>(args: SelectSubset<T, RequestStatusCreateArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RequestStatuses.
     * @param {RequestStatusCreateManyArgs} args - Arguments to create many RequestStatuses.
     * @example
     * // Create many RequestStatuses
     * const requestStatus = await prisma.requestStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestStatusCreateManyArgs>(args?: SelectSubset<T, RequestStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestStatuses and returns the data saved in the database.
     * @param {RequestStatusCreateManyAndReturnArgs} args - Arguments to create many RequestStatuses.
     * @example
     * // Create many RequestStatuses
     * const requestStatus = await prisma.requestStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestStatuses and only return the `id`
     * const requestStatusWithIdOnly = await prisma.requestStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RequestStatus.
     * @param {RequestStatusDeleteArgs} args - Arguments to delete one RequestStatus.
     * @example
     * // Delete one RequestStatus
     * const RequestStatus = await prisma.requestStatus.delete({
     *   where: {
     *     // ... filter to delete one RequestStatus
     *   }
     * })
     * 
     */
    delete<T extends RequestStatusDeleteArgs>(args: SelectSubset<T, RequestStatusDeleteArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RequestStatus.
     * @param {RequestStatusUpdateArgs} args - Arguments to update one RequestStatus.
     * @example
     * // Update one RequestStatus
     * const requestStatus = await prisma.requestStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestStatusUpdateArgs>(args: SelectSubset<T, RequestStatusUpdateArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RequestStatuses.
     * @param {RequestStatusDeleteManyArgs} args - Arguments to filter RequestStatuses to delete.
     * @example
     * // Delete a few RequestStatuses
     * const { count } = await prisma.requestStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestStatusDeleteManyArgs>(args?: SelectSubset<T, RequestStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestStatuses
     * const requestStatus = await prisma.requestStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestStatusUpdateManyArgs>(args: SelectSubset<T, RequestStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestStatus.
     * @param {RequestStatusUpsertArgs} args - Arguments to update or create a RequestStatus.
     * @example
     * // Update or create a RequestStatus
     * const requestStatus = await prisma.requestStatus.upsert({
     *   create: {
     *     // ... data to create a RequestStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestStatus we want to update
     *   }
     * })
     */
    upsert<T extends RequestStatusUpsertArgs>(args: SelectSubset<T, RequestStatusUpsertArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RequestStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusCountArgs} args - Arguments to filter RequestStatuses to count.
     * @example
     * // Count the number of RequestStatuses
     * const count = await prisma.requestStatus.count({
     *   where: {
     *     // ... the filter for the RequestStatuses we want to count
     *   }
     * })
    **/
    count<T extends RequestStatusCountArgs>(
      args?: Subset<T, RequestStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestStatusAggregateArgs>(args: Subset<T, RequestStatusAggregateArgs>): Prisma.PrismaPromise<GetRequestStatusAggregateType<T>>

    /**
     * Group by RequestStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestStatusGroupByArgs['orderBy'] }
        : { orderBy?: RequestStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestStatus model
   */
  readonly fields: RequestStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Requests<T extends RequestStatus$RequestsArgs<ExtArgs> = {}>(args?: Subset<T, RequestStatus$RequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestStatus model
   */ 
  interface RequestStatusFieldRefs {
    readonly id: FieldRef<"RequestStatus", 'Int'>
    readonly name: FieldRef<"RequestStatus", 'String'>
    readonly createdAt: FieldRef<"RequestStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestStatus findUnique
   */
  export type RequestStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatus to fetch.
     */
    where: RequestStatusWhereUniqueInput
  }

  /**
   * RequestStatus findUniqueOrThrow
   */
  export type RequestStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatus to fetch.
     */
    where: RequestStatusWhereUniqueInput
  }

  /**
   * RequestStatus findFirst
   */
  export type RequestStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatus to fetch.
     */
    where?: RequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatuses to fetch.
     */
    orderBy?: RequestStatusOrderByWithRelationInput | RequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestStatuses.
     */
    cursor?: RequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestStatuses.
     */
    distinct?: RequestStatusScalarFieldEnum | RequestStatusScalarFieldEnum[]
  }

  /**
   * RequestStatus findFirstOrThrow
   */
  export type RequestStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatus to fetch.
     */
    where?: RequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatuses to fetch.
     */
    orderBy?: RequestStatusOrderByWithRelationInput | RequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestStatuses.
     */
    cursor?: RequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestStatuses.
     */
    distinct?: RequestStatusScalarFieldEnum | RequestStatusScalarFieldEnum[]
  }

  /**
   * RequestStatus findMany
   */
  export type RequestStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatuses to fetch.
     */
    where?: RequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatuses to fetch.
     */
    orderBy?: RequestStatusOrderByWithRelationInput | RequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestStatuses.
     */
    cursor?: RequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatuses.
     */
    skip?: number
    distinct?: RequestStatusScalarFieldEnum | RequestStatusScalarFieldEnum[]
  }

  /**
   * RequestStatus create
   */
  export type RequestStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestStatus.
     */
    data: XOR<RequestStatusCreateInput, RequestStatusUncheckedCreateInput>
  }

  /**
   * RequestStatus createMany
   */
  export type RequestStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestStatuses.
     */
    data: RequestStatusCreateManyInput | RequestStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestStatus createManyAndReturn
   */
  export type RequestStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RequestStatuses.
     */
    data: RequestStatusCreateManyInput | RequestStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestStatus update
   */
  export type RequestStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestStatus.
     */
    data: XOR<RequestStatusUpdateInput, RequestStatusUncheckedUpdateInput>
    /**
     * Choose, which RequestStatus to update.
     */
    where: RequestStatusWhereUniqueInput
  }

  /**
   * RequestStatus updateMany
   */
  export type RequestStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestStatuses.
     */
    data: XOR<RequestStatusUpdateManyMutationInput, RequestStatusUncheckedUpdateManyInput>
    /**
     * Filter which RequestStatuses to update
     */
    where?: RequestStatusWhereInput
  }

  /**
   * RequestStatus upsert
   */
  export type RequestStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestStatus to update in case it exists.
     */
    where: RequestStatusWhereUniqueInput
    /**
     * In case the RequestStatus found by the `where` argument doesn't exist, create a new RequestStatus with this data.
     */
    create: XOR<RequestStatusCreateInput, RequestStatusUncheckedCreateInput>
    /**
     * In case the RequestStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestStatusUpdateInput, RequestStatusUncheckedUpdateInput>
  }

  /**
   * RequestStatus delete
   */
  export type RequestStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
    /**
     * Filter which RequestStatus to delete.
     */
    where: RequestStatusWhereUniqueInput
  }

  /**
   * RequestStatus deleteMany
   */
  export type RequestStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestStatuses to delete
     */
    where?: RequestStatusWhereInput
  }

  /**
   * RequestStatus.Requests
   */
  export type RequestStatus$RequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    where?: RequestsWhereInput
    orderBy?: RequestsOrderByWithRelationInput | RequestsOrderByWithRelationInput[]
    cursor?: RequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * RequestStatus without action
   */
  export type RequestStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatus
     */
    select?: RequestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusInclude<ExtArgs> | null
  }


  /**
   * Model Requests
   */

  export type AggregateRequests = {
    _count: RequestsCountAggregateOutputType | null
    _avg: RequestsAvgAggregateOutputType | null
    _sum: RequestsSumAggregateOutputType | null
    _min: RequestsMinAggregateOutputType | null
    _max: RequestsMaxAggregateOutputType | null
  }

  export type RequestsAvgAggregateOutputType = {
    requestNum: number | null
    requestStatusId: number | null
  }

  export type RequestsSumAggregateOutputType = {
    requestNum: number | null
    requestStatusId: number | null
  }

  export type RequestsMinAggregateOutputType = {
    id: string | null
    requestNum: number | null
    username: string | null
    email: string | null
    createdAt: Date | null
    requestStatusId: number | null
  }

  export type RequestsMaxAggregateOutputType = {
    id: string | null
    requestNum: number | null
    username: string | null
    email: string | null
    createdAt: Date | null
    requestStatusId: number | null
  }

  export type RequestsCountAggregateOutputType = {
    id: number
    requestNum: number
    username: number
    email: number
    createdAt: number
    requestStatusId: number
    _all: number
  }


  export type RequestsAvgAggregateInputType = {
    requestNum?: true
    requestStatusId?: true
  }

  export type RequestsSumAggregateInputType = {
    requestNum?: true
    requestStatusId?: true
  }

  export type RequestsMinAggregateInputType = {
    id?: true
    requestNum?: true
    username?: true
    email?: true
    createdAt?: true
    requestStatusId?: true
  }

  export type RequestsMaxAggregateInputType = {
    id?: true
    requestNum?: true
    username?: true
    email?: true
    createdAt?: true
    requestStatusId?: true
  }

  export type RequestsCountAggregateInputType = {
    id?: true
    requestNum?: true
    username?: true
    email?: true
    createdAt?: true
    requestStatusId?: true
    _all?: true
  }

  export type RequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requests to aggregate.
     */
    where?: RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestsOrderByWithRelationInput | RequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requests
    **/
    _count?: true | RequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestsMaxAggregateInputType
  }

  export type GetRequestsAggregateType<T extends RequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequests[P]>
      : GetScalarType<T[P], AggregateRequests[P]>
  }




  export type RequestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestsWhereInput
    orderBy?: RequestsOrderByWithAggregationInput | RequestsOrderByWithAggregationInput[]
    by: RequestsScalarFieldEnum[] | RequestsScalarFieldEnum
    having?: RequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestsCountAggregateInputType | true
    _avg?: RequestsAvgAggregateInputType
    _sum?: RequestsSumAggregateInputType
    _min?: RequestsMinAggregateInputType
    _max?: RequestsMaxAggregateInputType
  }

  export type RequestsGroupByOutputType = {
    id: string
    requestNum: number
    username: string
    email: string
    createdAt: Date
    requestStatusId: number
    _count: RequestsCountAggregateOutputType | null
    _avg: RequestsAvgAggregateOutputType | null
    _sum: RequestsSumAggregateOutputType | null
    _min: RequestsMinAggregateOutputType | null
    _max: RequestsMaxAggregateOutputType | null
  }

  type GetRequestsGroupByPayload<T extends RequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestsGroupByOutputType[P]>
            : GetScalarType<T[P], RequestsGroupByOutputType[P]>
        }
      >
    >


  export type RequestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestNum?: boolean
    username?: boolean
    email?: boolean
    createdAt?: boolean
    requestStatusId?: boolean
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    status?: boolean | RequestStatusDefaultArgs<ExtArgs>
    Documents?: boolean | Requests$DocumentsArgs<ExtArgs>
    _count?: boolean | RequestsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requests"]>

  export type RequestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestNum?: boolean
    username?: boolean
    email?: boolean
    createdAt?: boolean
    requestStatusId?: boolean
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    status?: boolean | RequestStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requests"]>

  export type RequestsSelectScalar = {
    id?: boolean
    requestNum?: boolean
    username?: boolean
    email?: boolean
    createdAt?: boolean
    requestStatusId?: boolean
  }

  export type RequestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    status?: boolean | RequestStatusDefaultArgs<ExtArgs>
    Documents?: boolean | Requests$DocumentsArgs<ExtArgs>
    _count?: boolean | RequestsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    status?: boolean | RequestStatusDefaultArgs<ExtArgs>
  }

  export type $RequestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Requests"
    objects: {
      taxPayer: Prisma.$TaxPayerPayload<ExtArgs>
      status: Prisma.$RequestStatusPayload<ExtArgs>
      Documents: Prisma.$DocumentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestNum: number
      username: string
      email: string
      createdAt: Date
      requestStatusId: number
    }, ExtArgs["result"]["requests"]>
    composites: {}
  }

  type RequestsGetPayload<S extends boolean | null | undefined | RequestsDefaultArgs> = $Result.GetResult<Prisma.$RequestsPayload, S>

  type RequestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RequestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RequestsCountAggregateInputType | true
    }

  export interface RequestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Requests'], meta: { name: 'Requests' } }
    /**
     * Find zero or one Requests that matches the filter.
     * @param {RequestsFindUniqueArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestsFindUniqueArgs>(args: SelectSubset<T, RequestsFindUniqueArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Requests that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RequestsFindUniqueOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestsFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsFindFirstArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestsFindFirstArgs>(args?: SelectSubset<T, RequestsFindFirstArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsFindFirstOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestsFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.requests.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestsWithIdOnly = await prisma.requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestsFindManyArgs>(args?: SelectSubset<T, RequestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Requests.
     * @param {RequestsCreateArgs} args - Arguments to create a Requests.
     * @example
     * // Create one Requests
     * const Requests = await prisma.requests.create({
     *   data: {
     *     // ... data to create a Requests
     *   }
     * })
     * 
     */
    create<T extends RequestsCreateArgs>(args: SelectSubset<T, RequestsCreateArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Requests.
     * @param {RequestsCreateManyArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const requests = await prisma.requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestsCreateManyArgs>(args?: SelectSubset<T, RequestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requests and returns the data saved in the database.
     * @param {RequestsCreateManyAndReturnArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const requests = await prisma.requests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requests and only return the `id`
     * const requestsWithIdOnly = await prisma.requests.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestsCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Requests.
     * @param {RequestsDeleteArgs} args - Arguments to delete one Requests.
     * @example
     * // Delete one Requests
     * const Requests = await prisma.requests.delete({
     *   where: {
     *     // ... filter to delete one Requests
     *   }
     * })
     * 
     */
    delete<T extends RequestsDeleteArgs>(args: SelectSubset<T, RequestsDeleteArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Requests.
     * @param {RequestsUpdateArgs} args - Arguments to update one Requests.
     * @example
     * // Update one Requests
     * const requests = await prisma.requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestsUpdateArgs>(args: SelectSubset<T, RequestsUpdateArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Requests.
     * @param {RequestsDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestsDeleteManyArgs>(args?: SelectSubset<T, RequestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const requests = await prisma.requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestsUpdateManyArgs>(args: SelectSubset<T, RequestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Requests.
     * @param {RequestsUpsertArgs} args - Arguments to update or create a Requests.
     * @example
     * // Update or create a Requests
     * const requests = await prisma.requests.upsert({
     *   create: {
     *     // ... data to create a Requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requests we want to update
     *   }
     * })
     */
    upsert<T extends RequestsUpsertArgs>(args: SelectSubset<T, RequestsUpsertArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.requests.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends RequestsCountArgs>(
      args?: Subset<T, RequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestsAggregateArgs>(args: Subset<T, RequestsAggregateArgs>): Prisma.PrismaPromise<GetRequestsAggregateType<T>>

    /**
     * Group by Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestsGroupByArgs['orderBy'] }
        : { orderBy?: RequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Requests model
   */
  readonly fields: RequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxPayer<T extends TaxPayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayerDefaultArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    status<T extends RequestStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestStatusDefaultArgs<ExtArgs>>): Prisma__RequestStatusClient<$Result.GetResult<Prisma.$RequestStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Documents<T extends Requests$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Requests$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Requests model
   */ 
  interface RequestsFieldRefs {
    readonly id: FieldRef<"Requests", 'String'>
    readonly requestNum: FieldRef<"Requests", 'Int'>
    readonly username: FieldRef<"Requests", 'String'>
    readonly email: FieldRef<"Requests", 'String'>
    readonly createdAt: FieldRef<"Requests", 'DateTime'>
    readonly requestStatusId: FieldRef<"Requests", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Requests findUnique
   */
  export type RequestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where: RequestsWhereUniqueInput
  }

  /**
   * Requests findUniqueOrThrow
   */
  export type RequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where: RequestsWhereUniqueInput
  }

  /**
   * Requests findFirst
   */
  export type RequestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestsOrderByWithRelationInput | RequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * Requests findFirstOrThrow
   */
  export type RequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestsOrderByWithRelationInput | RequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * Requests findMany
   */
  export type RequestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestsOrderByWithRelationInput | RequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requests.
     */
    cursor?: RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * Requests create
   */
  export type RequestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * The data needed to create a Requests.
     */
    data: XOR<RequestsCreateInput, RequestsUncheckedCreateInput>
  }

  /**
   * Requests createMany
   */
  export type RequestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requests.
     */
    data: RequestsCreateManyInput | RequestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Requests createManyAndReturn
   */
  export type RequestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Requests.
     */
    data: RequestsCreateManyInput | RequestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requests update
   */
  export type RequestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * The data needed to update a Requests.
     */
    data: XOR<RequestsUpdateInput, RequestsUncheckedUpdateInput>
    /**
     * Choose, which Requests to update.
     */
    where: RequestsWhereUniqueInput
  }

  /**
   * Requests updateMany
   */
  export type RequestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestsUpdateManyMutationInput, RequestsUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestsWhereInput
  }

  /**
   * Requests upsert
   */
  export type RequestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * The filter to search for the Requests to update in case it exists.
     */
    where: RequestsWhereUniqueInput
    /**
     * In case the Requests found by the `where` argument doesn't exist, create a new Requests with this data.
     */
    create: XOR<RequestsCreateInput, RequestsUncheckedCreateInput>
    /**
     * In case the Requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestsUpdateInput, RequestsUncheckedUpdateInput>
  }

  /**
   * Requests delete
   */
  export type RequestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    /**
     * Filter which Requests to delete.
     */
    where: RequestsWhereUniqueInput
  }

  /**
   * Requests deleteMany
   */
  export type RequestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestsWhereInput
  }

  /**
   * Requests.Documents
   */
  export type Requests$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    cursor?: DocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Requests without action
   */
  export type RequestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
  }


  /**
   * Model Documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsAvgAggregateOutputType = {
    documentTypeId: number | null
  }

  export type DocumentsSumAggregateOutputType = {
    documentTypeId: number | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    downloadURL: string | null
    fileFormatType: string | null
    documentTypeId: number | null
    createdAt: Date | null
    requestId: string | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    downloadURL: string | null
    fileFormatType: string | null
    documentTypeId: number | null
    createdAt: Date | null
    requestId: string | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    fileName: number
    downloadURL: number
    fileFormatType: number
    documentTypeId: number
    createdAt: number
    requestId: number
    _all: number
  }


  export type DocumentsAvgAggregateInputType = {
    documentTypeId?: true
  }

  export type DocumentsSumAggregateInputType = {
    documentTypeId?: true
  }

  export type DocumentsMinAggregateInputType = {
    id?: true
    fileName?: true
    downloadURL?: true
    fileFormatType?: true
    documentTypeId?: true
    createdAt?: true
    requestId?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    fileName?: true
    downloadURL?: true
    fileFormatType?: true
    documentTypeId?: true
    createdAt?: true
    requestId?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    fileName?: true
    downloadURL?: true
    fileFormatType?: true
    documentTypeId?: true
    createdAt?: true
    requestId?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to aggregate.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type DocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithAggregationInput | DocumentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: DocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _avg?: DocumentsAvgAggregateInputType
    _sum?: DocumentsSumAggregateInputType
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    documentTypeId: number
    createdAt: Date
    requestId: string
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends DocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type DocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    downloadURL?: boolean
    fileFormatType?: boolean
    documentTypeId?: boolean
    createdAt?: boolean
    requestId?: boolean
    request?: boolean | RequestsDefaultArgs<ExtArgs>
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>

  export type DocumentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    downloadURL?: boolean
    fileFormatType?: boolean
    documentTypeId?: boolean
    createdAt?: boolean
    requestId?: boolean
    request?: boolean | RequestsDefaultArgs<ExtArgs>
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>

  export type DocumentsSelectScalar = {
    id?: boolean
    fileName?: boolean
    downloadURL?: boolean
    fileFormatType?: boolean
    documentTypeId?: boolean
    createdAt?: boolean
    requestId?: boolean
  }

  export type DocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestsDefaultArgs<ExtArgs>
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
  }
  export type DocumentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestsDefaultArgs<ExtArgs>
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
  }

  export type $DocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documents"
    objects: {
      request: Prisma.$RequestsPayload<ExtArgs>
      documentType: Prisma.$DocumentTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      downloadURL: string
      fileFormatType: string
      documentTypeId: number
      createdAt: Date
      requestId: string
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type DocumentsGetPayload<S extends boolean | null | undefined | DocumentsDefaultArgs> = $Result.GetResult<Prisma.$DocumentsPayload, S>

  type DocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface DocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documents'], meta: { name: 'Documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {DocumentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentsFindUniqueArgs>(args: SelectSubset<T, DocumentsFindUniqueArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentsFindFirstArgs>(args?: SelectSubset<T, DocumentsFindFirstArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentsFindManyArgs>(args?: SelectSubset<T, DocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Documents.
     * @param {DocumentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends DocumentsCreateArgs>(args: SelectSubset<T, DocumentsCreateArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentsCreateManyArgs>(args?: SelectSubset<T, DocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentsCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentsCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Documents.
     * @param {DocumentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends DocumentsDeleteArgs>(args: SelectSubset<T, DocumentsDeleteArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Documents.
     * @param {DocumentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentsUpdateArgs>(args: SelectSubset<T, DocumentsUpdateArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentsDeleteManyArgs>(args?: SelectSubset<T, DocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentsUpdateManyArgs>(args: SelectSubset<T, DocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documents.
     * @param {DocumentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends DocumentsUpsertArgs>(args: SelectSubset<T, DocumentsUpsertArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentsCountArgs>(
      args?: Subset<T, DocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentsGroupByArgs['orderBy'] }
        : { orderBy?: DocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documents model
   */
  readonly fields: DocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends RequestsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestsDefaultArgs<ExtArgs>>): Prisma__RequestsClient<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documentType<T extends DocumentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTypeDefaultArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documents model
   */ 
  interface DocumentsFieldRefs {
    readonly id: FieldRef<"Documents", 'String'>
    readonly fileName: FieldRef<"Documents", 'String'>
    readonly downloadURL: FieldRef<"Documents", 'String'>
    readonly fileFormatType: FieldRef<"Documents", 'String'>
    readonly documentTypeId: FieldRef<"Documents", 'Int'>
    readonly createdAt: FieldRef<"Documents", 'DateTime'>
    readonly requestId: FieldRef<"Documents", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Documents findUnique
   */
  export type DocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents findUniqueOrThrow
   */
  export type DocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents findFirst
   */
  export type DocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents findFirstOrThrow
   */
  export type DocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents findMany
   */
  export type DocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents create
   */
  export type DocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Documents.
     */
    data: XOR<DocumentsCreateInput, DocumentsUncheckedCreateInput>
  }

  /**
   * Documents createMany
   */
  export type DocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentsCreateManyInput | DocumentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documents createManyAndReturn
   */
  export type DocumentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentsCreateManyInput | DocumentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Documents update
   */
  export type DocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Documents.
     */
    data: XOR<DocumentsUpdateInput, DocumentsUncheckedUpdateInput>
    /**
     * Choose, which Documents to update.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents updateMany
   */
  export type DocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentsWhereInput
  }

  /**
   * Documents upsert
   */
  export type DocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Documents to update in case it exists.
     */
    where: DocumentsWhereUniqueInput
    /**
     * In case the Documents found by the `where` argument doesn't exist, create a new Documents with this data.
     */
    create: XOR<DocumentsCreateInput, DocumentsUncheckedCreateInput>
    /**
     * In case the Documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentsUpdateInput, DocumentsUncheckedUpdateInput>
  }

  /**
   * Documents delete
   */
  export type DocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter which Documents to delete.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents deleteMany
   */
  export type DocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentsWhereInput
  }

  /**
   * Documents without action
   */
  export type DocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
  }


  /**
   * Model PurchasesOrExpenses
   */

  export type AggregatePurchasesOrExpenses = {
    _count: PurchasesOrExpensesCountAggregateOutputType | null
    _avg: PurchasesOrExpensesAvgAggregateOutputType | null
    _sum: PurchasesOrExpensesSumAggregateOutputType | null
    _min: PurchasesOrExpensesMinAggregateOutputType | null
    _max: PurchasesOrExpensesMaxAggregateOutputType | null
  }

  export type PurchasesOrExpensesAvgAggregateOutputType = {
    total: Decimal | null
    tax: Decimal | null
    costTax: Decimal | null
    taxPayerTypesId: number | null
    retentionTaxId: number | null
    costTaxStatusId: number | null
    conceptId: number | null
    netAmount: Decimal | null
    retentionTaxValue: Decimal | null
    retentionIsrValue: Decimal | null
    netToPaid: Decimal | null
    taxForOvertaking: Decimal | null
  }

  export type PurchasesOrExpensesSumAggregateOutputType = {
    total: Decimal | null
    tax: Decimal | null
    costTax: Decimal | null
    taxPayerTypesId: number | null
    retentionTaxId: number | null
    costTaxStatusId: number | null
    conceptId: number | null
    netAmount: Decimal | null
    retentionTaxValue: Decimal | null
    retentionIsrValue: Decimal | null
    netToPaid: Decimal | null
    taxForOvertaking: Decimal | null
  }

  export type PurchasesOrExpensesMinAggregateOutputType = {
    id: string | null
    rncOrId: string | null
    ncf: string | null
    ncfAffected: string | null
    issueDate: Date | null
    retentionDate: Date | null
    total: Decimal | null
    tax: Decimal | null
    costTax: Decimal | null
    taxPayerTypesId: number | null
    paymentsMethodsId: string | null
    ncfsTypesId: string | null
    ncfsAffectTypeId: string | null
    retentionTaxId: number | null
    retentionIsrId: string | null
    costTaxStatusId: number | null
    conceptId: number | null
    authorId: string | null
    updatedAt: Date | null
    createdAt: Date | null
    netAmount: Decimal | null
    retentionTaxValue: Decimal | null
    retentionIsrValue: Decimal | null
    netToPaid: Decimal | null
    taxForOvertaking: Decimal | null
    manual: boolean | null
  }

  export type PurchasesOrExpensesMaxAggregateOutputType = {
    id: string | null
    rncOrId: string | null
    ncf: string | null
    ncfAffected: string | null
    issueDate: Date | null
    retentionDate: Date | null
    total: Decimal | null
    tax: Decimal | null
    costTax: Decimal | null
    taxPayerTypesId: number | null
    paymentsMethodsId: string | null
    ncfsTypesId: string | null
    ncfsAffectTypeId: string | null
    retentionTaxId: number | null
    retentionIsrId: string | null
    costTaxStatusId: number | null
    conceptId: number | null
    authorId: string | null
    updatedAt: Date | null
    createdAt: Date | null
    netAmount: Decimal | null
    retentionTaxValue: Decimal | null
    retentionIsrValue: Decimal | null
    netToPaid: Decimal | null
    taxForOvertaking: Decimal | null
    manual: boolean | null
  }

  export type PurchasesOrExpensesCountAggregateOutputType = {
    id: number
    rncOrId: number
    ncf: number
    ncfAffected: number
    issueDate: number
    retentionDate: number
    total: number
    tax: number
    costTax: number
    taxPayerTypesId: number
    paymentsMethodsId: number
    ncfsTypesId: number
    ncfsAffectTypeId: number
    retentionTaxId: number
    retentionIsrId: number
    costTaxStatusId: number
    conceptId: number
    authorId: number
    updatedAt: number
    createdAt: number
    netAmount: number
    retentionTaxValue: number
    retentionIsrValue: number
    netToPaid: number
    taxForOvertaking: number
    manual: number
    _all: number
  }


  export type PurchasesOrExpensesAvgAggregateInputType = {
    total?: true
    tax?: true
    costTax?: true
    taxPayerTypesId?: true
    retentionTaxId?: true
    costTaxStatusId?: true
    conceptId?: true
    netAmount?: true
    retentionTaxValue?: true
    retentionIsrValue?: true
    netToPaid?: true
    taxForOvertaking?: true
  }

  export type PurchasesOrExpensesSumAggregateInputType = {
    total?: true
    tax?: true
    costTax?: true
    taxPayerTypesId?: true
    retentionTaxId?: true
    costTaxStatusId?: true
    conceptId?: true
    netAmount?: true
    retentionTaxValue?: true
    retentionIsrValue?: true
    netToPaid?: true
    taxForOvertaking?: true
  }

  export type PurchasesOrExpensesMinAggregateInputType = {
    id?: true
    rncOrId?: true
    ncf?: true
    ncfAffected?: true
    issueDate?: true
    retentionDate?: true
    total?: true
    tax?: true
    costTax?: true
    taxPayerTypesId?: true
    paymentsMethodsId?: true
    ncfsTypesId?: true
    ncfsAffectTypeId?: true
    retentionTaxId?: true
    retentionIsrId?: true
    costTaxStatusId?: true
    conceptId?: true
    authorId?: true
    updatedAt?: true
    createdAt?: true
    netAmount?: true
    retentionTaxValue?: true
    retentionIsrValue?: true
    netToPaid?: true
    taxForOvertaking?: true
    manual?: true
  }

  export type PurchasesOrExpensesMaxAggregateInputType = {
    id?: true
    rncOrId?: true
    ncf?: true
    ncfAffected?: true
    issueDate?: true
    retentionDate?: true
    total?: true
    tax?: true
    costTax?: true
    taxPayerTypesId?: true
    paymentsMethodsId?: true
    ncfsTypesId?: true
    ncfsAffectTypeId?: true
    retentionTaxId?: true
    retentionIsrId?: true
    costTaxStatusId?: true
    conceptId?: true
    authorId?: true
    updatedAt?: true
    createdAt?: true
    netAmount?: true
    retentionTaxValue?: true
    retentionIsrValue?: true
    netToPaid?: true
    taxForOvertaking?: true
    manual?: true
  }

  export type PurchasesOrExpensesCountAggregateInputType = {
    id?: true
    rncOrId?: true
    ncf?: true
    ncfAffected?: true
    issueDate?: true
    retentionDate?: true
    total?: true
    tax?: true
    costTax?: true
    taxPayerTypesId?: true
    paymentsMethodsId?: true
    ncfsTypesId?: true
    ncfsAffectTypeId?: true
    retentionTaxId?: true
    retentionIsrId?: true
    costTaxStatusId?: true
    conceptId?: true
    authorId?: true
    updatedAt?: true
    createdAt?: true
    netAmount?: true
    retentionTaxValue?: true
    retentionIsrValue?: true
    netToPaid?: true
    taxForOvertaking?: true
    manual?: true
    _all?: true
  }

  export type PurchasesOrExpensesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesOrExpenses to aggregate.
     */
    where?: PurchasesOrExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesOrExpenses to fetch.
     */
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasesOrExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesOrExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesOrExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasesOrExpenses
    **/
    _count?: true | PurchasesOrExpensesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasesOrExpensesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasesOrExpensesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasesOrExpensesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasesOrExpensesMaxAggregateInputType
  }

  export type GetPurchasesOrExpensesAggregateType<T extends PurchasesOrExpensesAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasesOrExpenses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasesOrExpenses[P]>
      : GetScalarType<T[P], AggregatePurchasesOrExpenses[P]>
  }




  export type PurchasesOrExpensesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithAggregationInput | PurchasesOrExpensesOrderByWithAggregationInput[]
    by: PurchasesOrExpensesScalarFieldEnum[] | PurchasesOrExpensesScalarFieldEnum
    having?: PurchasesOrExpensesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasesOrExpensesCountAggregateInputType | true
    _avg?: PurchasesOrExpensesAvgAggregateInputType
    _sum?: PurchasesOrExpensesSumAggregateInputType
    _min?: PurchasesOrExpensesMinAggregateInputType
    _max?: PurchasesOrExpensesMaxAggregateInputType
  }

  export type PurchasesOrExpensesGroupByOutputType = {
    id: string
    rncOrId: string
    ncf: string
    ncfAffected: string | null
    issueDate: Date
    retentionDate: Date | null
    total: Decimal
    tax: Decimal
    costTax: Decimal | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId: string | null
    retentionTaxId: number | null
    retentionIsrId: string | null
    costTaxStatusId: number | null
    conceptId: number
    authorId: string
    updatedAt: Date | null
    createdAt: Date
    netAmount: Decimal | null
    retentionTaxValue: Decimal | null
    retentionIsrValue: Decimal | null
    netToPaid: Decimal | null
    taxForOvertaking: Decimal | null
    manual: boolean | null
    _count: PurchasesOrExpensesCountAggregateOutputType | null
    _avg: PurchasesOrExpensesAvgAggregateOutputType | null
    _sum: PurchasesOrExpensesSumAggregateOutputType | null
    _min: PurchasesOrExpensesMinAggregateOutputType | null
    _max: PurchasesOrExpensesMaxAggregateOutputType | null
  }

  type GetPurchasesOrExpensesGroupByPayload<T extends PurchasesOrExpensesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasesOrExpensesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasesOrExpensesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasesOrExpensesGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasesOrExpensesGroupByOutputType[P]>
        }
      >
    >


  export type PurchasesOrExpensesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rncOrId?: boolean
    ncf?: boolean
    ncfAffected?: boolean
    issueDate?: boolean
    retentionDate?: boolean
    total?: boolean
    tax?: boolean
    costTax?: boolean
    taxPayerTypesId?: boolean
    paymentsMethodsId?: boolean
    ncfsTypesId?: boolean
    ncfsAffectTypeId?: boolean
    retentionTaxId?: boolean
    retentionIsrId?: boolean
    costTaxStatusId?: boolean
    conceptId?: boolean
    authorId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    netAmount?: boolean
    retentionTaxValue?: boolean
    retentionIsrValue?: boolean
    netToPaid?: boolean
    taxForOvertaking?: boolean
    manual?: boolean
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
    concept?: boolean | ConceptsDefaultArgs<ExtArgs>
    taxPayerType?: boolean | TaxPayerTypesDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentsMethodsDefaultArgs<ExtArgs>
    ncfType?: boolean | NcfsTypesDefaultArgs<ExtArgs>
    ncfAffectType?: boolean | PurchasesOrExpenses$ncfAffectTypeArgs<ExtArgs>
    retentionTax?: boolean | PurchasesOrExpenses$retentionTaxArgs<ExtArgs>
    retentionIsr?: boolean | PurchasesOrExpenses$retentionIsrArgs<ExtArgs>
    costTaxStatus?: boolean | PurchasesOrExpenses$costTaxStatusArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesOrExpenses"]>

  export type PurchasesOrExpensesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rncOrId?: boolean
    ncf?: boolean
    ncfAffected?: boolean
    issueDate?: boolean
    retentionDate?: boolean
    total?: boolean
    tax?: boolean
    costTax?: boolean
    taxPayerTypesId?: boolean
    paymentsMethodsId?: boolean
    ncfsTypesId?: boolean
    ncfsAffectTypeId?: boolean
    retentionTaxId?: boolean
    retentionIsrId?: boolean
    costTaxStatusId?: boolean
    conceptId?: boolean
    authorId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    netAmount?: boolean
    retentionTaxValue?: boolean
    retentionIsrValue?: boolean
    netToPaid?: boolean
    taxForOvertaking?: boolean
    manual?: boolean
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
    concept?: boolean | ConceptsDefaultArgs<ExtArgs>
    taxPayerType?: boolean | TaxPayerTypesDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentsMethodsDefaultArgs<ExtArgs>
    ncfType?: boolean | NcfsTypesDefaultArgs<ExtArgs>
    ncfAffectType?: boolean | PurchasesOrExpenses$ncfAffectTypeArgs<ExtArgs>
    retentionTax?: boolean | PurchasesOrExpenses$retentionTaxArgs<ExtArgs>
    retentionIsr?: boolean | PurchasesOrExpenses$retentionIsrArgs<ExtArgs>
    costTaxStatus?: boolean | PurchasesOrExpenses$costTaxStatusArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesOrExpenses"]>

  export type PurchasesOrExpensesSelectScalar = {
    id?: boolean
    rncOrId?: boolean
    ncf?: boolean
    ncfAffected?: boolean
    issueDate?: boolean
    retentionDate?: boolean
    total?: boolean
    tax?: boolean
    costTax?: boolean
    taxPayerTypesId?: boolean
    paymentsMethodsId?: boolean
    ncfsTypesId?: boolean
    ncfsAffectTypeId?: boolean
    retentionTaxId?: boolean
    retentionIsrId?: boolean
    costTaxStatusId?: boolean
    conceptId?: boolean
    authorId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    netAmount?: boolean
    retentionTaxValue?: boolean
    retentionIsrValue?: boolean
    netToPaid?: boolean
    taxForOvertaking?: boolean
    manual?: boolean
  }

  export type PurchasesOrExpensesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
    concept?: boolean | ConceptsDefaultArgs<ExtArgs>
    taxPayerType?: boolean | TaxPayerTypesDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentsMethodsDefaultArgs<ExtArgs>
    ncfType?: boolean | NcfsTypesDefaultArgs<ExtArgs>
    ncfAffectType?: boolean | PurchasesOrExpenses$ncfAffectTypeArgs<ExtArgs>
    retentionTax?: boolean | PurchasesOrExpenses$retentionTaxArgs<ExtArgs>
    retentionIsr?: boolean | PurchasesOrExpenses$retentionIsrArgs<ExtArgs>
    costTaxStatus?: boolean | PurchasesOrExpenses$costTaxStatusArgs<ExtArgs>
  }
  export type PurchasesOrExpensesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxPayer?: boolean | TaxPayerDefaultArgs<ExtArgs>
    author?: boolean | UsersDefaultArgs<ExtArgs>
    concept?: boolean | ConceptsDefaultArgs<ExtArgs>
    taxPayerType?: boolean | TaxPayerTypesDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentsMethodsDefaultArgs<ExtArgs>
    ncfType?: boolean | NcfsTypesDefaultArgs<ExtArgs>
    ncfAffectType?: boolean | PurchasesOrExpenses$ncfAffectTypeArgs<ExtArgs>
    retentionTax?: boolean | PurchasesOrExpenses$retentionTaxArgs<ExtArgs>
    retentionIsr?: boolean | PurchasesOrExpenses$retentionIsrArgs<ExtArgs>
    costTaxStatus?: boolean | PurchasesOrExpenses$costTaxStatusArgs<ExtArgs>
  }

  export type $PurchasesOrExpensesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasesOrExpenses"
    objects: {
      taxPayer: Prisma.$TaxPayerPayload<ExtArgs>
      author: Prisma.$UsersPayload<ExtArgs>
      concept: Prisma.$ConceptsPayload<ExtArgs>
      taxPayerType: Prisma.$TaxPayerTypesPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentsMethodsPayload<ExtArgs>
      ncfType: Prisma.$NcfsTypesPayload<ExtArgs>
      ncfAffectType: Prisma.$NcfsTypesPayload<ExtArgs> | null
      retentionTax: Prisma.$RetentionTaxPayload<ExtArgs> | null
      retentionIsr: Prisma.$RetentionIsrPayload<ExtArgs> | null
      costTaxStatus: Prisma.$CostTaxStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rncOrId: string
      ncf: string
      ncfAffected: string | null
      issueDate: Date
      retentionDate: Date | null
      total: Prisma.Decimal
      tax: Prisma.Decimal
      costTax: Prisma.Decimal | null
      taxPayerTypesId: number
      paymentsMethodsId: string
      ncfsTypesId: string
      ncfsAffectTypeId: string | null
      retentionTaxId: number | null
      retentionIsrId: string | null
      costTaxStatusId: number | null
      conceptId: number
      authorId: string
      updatedAt: Date | null
      createdAt: Date
      netAmount: Prisma.Decimal | null
      retentionTaxValue: Prisma.Decimal | null
      retentionIsrValue: Prisma.Decimal | null
      netToPaid: Prisma.Decimal | null
      taxForOvertaking: Prisma.Decimal | null
      manual: boolean | null
    }, ExtArgs["result"]["purchasesOrExpenses"]>
    composites: {}
  }

  type PurchasesOrExpensesGetPayload<S extends boolean | null | undefined | PurchasesOrExpensesDefaultArgs> = $Result.GetResult<Prisma.$PurchasesOrExpensesPayload, S>

  type PurchasesOrExpensesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchasesOrExpensesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchasesOrExpensesCountAggregateInputType | true
    }

  export interface PurchasesOrExpensesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasesOrExpenses'], meta: { name: 'PurchasesOrExpenses' } }
    /**
     * Find zero or one PurchasesOrExpenses that matches the filter.
     * @param {PurchasesOrExpensesFindUniqueArgs} args - Arguments to find a PurchasesOrExpenses
     * @example
     * // Get one PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasesOrExpensesFindUniqueArgs>(args: SelectSubset<T, PurchasesOrExpensesFindUniqueArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchasesOrExpenses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchasesOrExpensesFindUniqueOrThrowArgs} args - Arguments to find a PurchasesOrExpenses
     * @example
     * // Get one PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasesOrExpensesFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasesOrExpensesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchasesOrExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesOrExpensesFindFirstArgs} args - Arguments to find a PurchasesOrExpenses
     * @example
     * // Get one PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasesOrExpensesFindFirstArgs>(args?: SelectSubset<T, PurchasesOrExpensesFindFirstArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchasesOrExpenses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesOrExpensesFindFirstOrThrowArgs} args - Arguments to find a PurchasesOrExpenses
     * @example
     * // Get one PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasesOrExpensesFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasesOrExpensesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchasesOrExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesOrExpensesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.findMany()
     * 
     * // Get first 10 PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasesOrExpensesWithIdOnly = await prisma.purchasesOrExpenses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasesOrExpensesFindManyArgs>(args?: SelectSubset<T, PurchasesOrExpensesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchasesOrExpenses.
     * @param {PurchasesOrExpensesCreateArgs} args - Arguments to create a PurchasesOrExpenses.
     * @example
     * // Create one PurchasesOrExpenses
     * const PurchasesOrExpenses = await prisma.purchasesOrExpenses.create({
     *   data: {
     *     // ... data to create a PurchasesOrExpenses
     *   }
     * })
     * 
     */
    create<T extends PurchasesOrExpensesCreateArgs>(args: SelectSubset<T, PurchasesOrExpensesCreateArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchasesOrExpenses.
     * @param {PurchasesOrExpensesCreateManyArgs} args - Arguments to create many PurchasesOrExpenses.
     * @example
     * // Create many PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasesOrExpensesCreateManyArgs>(args?: SelectSubset<T, PurchasesOrExpensesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasesOrExpenses and returns the data saved in the database.
     * @param {PurchasesOrExpensesCreateManyAndReturnArgs} args - Arguments to create many PurchasesOrExpenses.
     * @example
     * // Create many PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasesOrExpenses and only return the `id`
     * const purchasesOrExpensesWithIdOnly = await prisma.purchasesOrExpenses.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasesOrExpensesCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasesOrExpensesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchasesOrExpenses.
     * @param {PurchasesOrExpensesDeleteArgs} args - Arguments to delete one PurchasesOrExpenses.
     * @example
     * // Delete one PurchasesOrExpenses
     * const PurchasesOrExpenses = await prisma.purchasesOrExpenses.delete({
     *   where: {
     *     // ... filter to delete one PurchasesOrExpenses
     *   }
     * })
     * 
     */
    delete<T extends PurchasesOrExpensesDeleteArgs>(args: SelectSubset<T, PurchasesOrExpensesDeleteArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchasesOrExpenses.
     * @param {PurchasesOrExpensesUpdateArgs} args - Arguments to update one PurchasesOrExpenses.
     * @example
     * // Update one PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasesOrExpensesUpdateArgs>(args: SelectSubset<T, PurchasesOrExpensesUpdateArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchasesOrExpenses.
     * @param {PurchasesOrExpensesDeleteManyArgs} args - Arguments to filter PurchasesOrExpenses to delete.
     * @example
     * // Delete a few PurchasesOrExpenses
     * const { count } = await prisma.purchasesOrExpenses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasesOrExpensesDeleteManyArgs>(args?: SelectSubset<T, PurchasesOrExpensesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesOrExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesOrExpensesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasesOrExpensesUpdateManyArgs>(args: SelectSubset<T, PurchasesOrExpensesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchasesOrExpenses.
     * @param {PurchasesOrExpensesUpsertArgs} args - Arguments to update or create a PurchasesOrExpenses.
     * @example
     * // Update or create a PurchasesOrExpenses
     * const purchasesOrExpenses = await prisma.purchasesOrExpenses.upsert({
     *   create: {
     *     // ... data to create a PurchasesOrExpenses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasesOrExpenses we want to update
     *   }
     * })
     */
    upsert<T extends PurchasesOrExpensesUpsertArgs>(args: SelectSubset<T, PurchasesOrExpensesUpsertArgs<ExtArgs>>): Prisma__PurchasesOrExpensesClient<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchasesOrExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesOrExpensesCountArgs} args - Arguments to filter PurchasesOrExpenses to count.
     * @example
     * // Count the number of PurchasesOrExpenses
     * const count = await prisma.purchasesOrExpenses.count({
     *   where: {
     *     // ... the filter for the PurchasesOrExpenses we want to count
     *   }
     * })
    **/
    count<T extends PurchasesOrExpensesCountArgs>(
      args?: Subset<T, PurchasesOrExpensesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasesOrExpensesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasesOrExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesOrExpensesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasesOrExpensesAggregateArgs>(args: Subset<T, PurchasesOrExpensesAggregateArgs>): Prisma.PrismaPromise<GetPurchasesOrExpensesAggregateType<T>>

    /**
     * Group by PurchasesOrExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesOrExpensesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasesOrExpensesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasesOrExpensesGroupByArgs['orderBy'] }
        : { orderBy?: PurchasesOrExpensesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasesOrExpensesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasesOrExpensesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasesOrExpenses model
   */
  readonly fields: PurchasesOrExpensesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasesOrExpenses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasesOrExpensesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxPayer<T extends TaxPayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayerDefaultArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    concept<T extends ConceptsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptsDefaultArgs<ExtArgs>>): Prisma__ConceptsClient<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    taxPayerType<T extends TaxPayerTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayerTypesDefaultArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paymentMethod<T extends PaymentsMethodsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentsMethodsDefaultArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ncfType<T extends NcfsTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NcfsTypesDefaultArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ncfAffectType<T extends PurchasesOrExpenses$ncfAffectTypeArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesOrExpenses$ncfAffectTypeArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    retentionTax<T extends PurchasesOrExpenses$retentionTaxArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesOrExpenses$retentionTaxArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    retentionIsr<T extends PurchasesOrExpenses$retentionIsrArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesOrExpenses$retentionIsrArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    costTaxStatus<T extends PurchasesOrExpenses$costTaxStatusArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesOrExpenses$costTaxStatusArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasesOrExpenses model
   */ 
  interface PurchasesOrExpensesFieldRefs {
    readonly id: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly rncOrId: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly ncf: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly ncfAffected: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly issueDate: FieldRef<"PurchasesOrExpenses", 'DateTime'>
    readonly retentionDate: FieldRef<"PurchasesOrExpenses", 'DateTime'>
    readonly total: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly tax: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly costTax: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly taxPayerTypesId: FieldRef<"PurchasesOrExpenses", 'Int'>
    readonly paymentsMethodsId: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly ncfsTypesId: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly ncfsAffectTypeId: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly retentionTaxId: FieldRef<"PurchasesOrExpenses", 'Int'>
    readonly retentionIsrId: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly costTaxStatusId: FieldRef<"PurchasesOrExpenses", 'Int'>
    readonly conceptId: FieldRef<"PurchasesOrExpenses", 'Int'>
    readonly authorId: FieldRef<"PurchasesOrExpenses", 'String'>
    readonly updatedAt: FieldRef<"PurchasesOrExpenses", 'DateTime'>
    readonly createdAt: FieldRef<"PurchasesOrExpenses", 'DateTime'>
    readonly netAmount: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly retentionTaxValue: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly retentionIsrValue: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly netToPaid: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly taxForOvertaking: FieldRef<"PurchasesOrExpenses", 'Decimal'>
    readonly manual: FieldRef<"PurchasesOrExpenses", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PurchasesOrExpenses findUnique
   */
  export type PurchasesOrExpensesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesOrExpenses to fetch.
     */
    where: PurchasesOrExpensesWhereUniqueInput
  }

  /**
   * PurchasesOrExpenses findUniqueOrThrow
   */
  export type PurchasesOrExpensesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesOrExpenses to fetch.
     */
    where: PurchasesOrExpensesWhereUniqueInput
  }

  /**
   * PurchasesOrExpenses findFirst
   */
  export type PurchasesOrExpensesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesOrExpenses to fetch.
     */
    where?: PurchasesOrExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesOrExpenses to fetch.
     */
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesOrExpenses.
     */
    cursor?: PurchasesOrExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesOrExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesOrExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesOrExpenses.
     */
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * PurchasesOrExpenses findFirstOrThrow
   */
  export type PurchasesOrExpensesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesOrExpenses to fetch.
     */
    where?: PurchasesOrExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesOrExpenses to fetch.
     */
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesOrExpenses.
     */
    cursor?: PurchasesOrExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesOrExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesOrExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesOrExpenses.
     */
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * PurchasesOrExpenses findMany
   */
  export type PurchasesOrExpensesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesOrExpenses to fetch.
     */
    where?: PurchasesOrExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesOrExpenses to fetch.
     */
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasesOrExpenses.
     */
    cursor?: PurchasesOrExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesOrExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesOrExpenses.
     */
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * PurchasesOrExpenses create
   */
  export type PurchasesOrExpensesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasesOrExpenses.
     */
    data: XOR<PurchasesOrExpensesCreateInput, PurchasesOrExpensesUncheckedCreateInput>
  }

  /**
   * PurchasesOrExpenses createMany
   */
  export type PurchasesOrExpensesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasesOrExpenses.
     */
    data: PurchasesOrExpensesCreateManyInput | PurchasesOrExpensesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasesOrExpenses createManyAndReturn
   */
  export type PurchasesOrExpensesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchasesOrExpenses.
     */
    data: PurchasesOrExpensesCreateManyInput | PurchasesOrExpensesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasesOrExpenses update
   */
  export type PurchasesOrExpensesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasesOrExpenses.
     */
    data: XOR<PurchasesOrExpensesUpdateInput, PurchasesOrExpensesUncheckedUpdateInput>
    /**
     * Choose, which PurchasesOrExpenses to update.
     */
    where: PurchasesOrExpensesWhereUniqueInput
  }

  /**
   * PurchasesOrExpenses updateMany
   */
  export type PurchasesOrExpensesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasesOrExpenses.
     */
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesOrExpenses to update
     */
    where?: PurchasesOrExpensesWhereInput
  }

  /**
   * PurchasesOrExpenses upsert
   */
  export type PurchasesOrExpensesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasesOrExpenses to update in case it exists.
     */
    where: PurchasesOrExpensesWhereUniqueInput
    /**
     * In case the PurchasesOrExpenses found by the `where` argument doesn't exist, create a new PurchasesOrExpenses with this data.
     */
    create: XOR<PurchasesOrExpensesCreateInput, PurchasesOrExpensesUncheckedCreateInput>
    /**
     * In case the PurchasesOrExpenses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasesOrExpensesUpdateInput, PurchasesOrExpensesUncheckedUpdateInput>
  }

  /**
   * PurchasesOrExpenses delete
   */
  export type PurchasesOrExpensesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    /**
     * Filter which PurchasesOrExpenses to delete.
     */
    where: PurchasesOrExpensesWhereUniqueInput
  }

  /**
   * PurchasesOrExpenses deleteMany
   */
  export type PurchasesOrExpensesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesOrExpenses to delete
     */
    where?: PurchasesOrExpensesWhereInput
  }

  /**
   * PurchasesOrExpenses.ncfAffectType
   */
  export type PurchasesOrExpenses$ncfAffectTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    where?: NcfsTypesWhereInput
  }

  /**
   * PurchasesOrExpenses.retentionTax
   */
  export type PurchasesOrExpenses$retentionTaxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    where?: RetentionTaxWhereInput
  }

  /**
   * PurchasesOrExpenses.retentionIsr
   */
  export type PurchasesOrExpenses$retentionIsrArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    where?: RetentionIsrWhereInput
  }

  /**
   * PurchasesOrExpenses.costTaxStatus
   */
  export type PurchasesOrExpenses$costTaxStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    where?: CostTaxStatusWhereInput
  }

  /**
   * PurchasesOrExpenses without action
   */
  export type PurchasesOrExpensesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
  }


  /**
   * Model TaxPayerTypes
   */

  export type AggregateTaxPayerTypes = {
    _count: TaxPayerTypesCountAggregateOutputType | null
    _avg: TaxPayerTypesAvgAggregateOutputType | null
    _sum: TaxPayerTypesSumAggregateOutputType | null
    _min: TaxPayerTypesMinAggregateOutputType | null
    _max: TaxPayerTypesMaxAggregateOutputType | null
  }

  export type TaxPayerTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type TaxPayerTypesSumAggregateOutputType = {
    id: number | null
  }

  export type TaxPayerTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type TaxPayerTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type TaxPayerTypesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type TaxPayerTypesAvgAggregateInputType = {
    id?: true
  }

  export type TaxPayerTypesSumAggregateInputType = {
    id?: true
  }

  export type TaxPayerTypesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type TaxPayerTypesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type TaxPayerTypesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type TaxPayerTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPayerTypes to aggregate.
     */
    where?: TaxPayerTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayerTypes to fetch.
     */
    orderBy?: TaxPayerTypesOrderByWithRelationInput | TaxPayerTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxPayerTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxPayerTypes
    **/
    _count?: true | TaxPayerTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxPayerTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxPayerTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxPayerTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxPayerTypesMaxAggregateInputType
  }

  export type GetTaxPayerTypesAggregateType<T extends TaxPayerTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxPayerTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxPayerTypes[P]>
      : GetScalarType<T[P], AggregateTaxPayerTypes[P]>
  }




  export type TaxPayerTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxPayerTypesWhereInput
    orderBy?: TaxPayerTypesOrderByWithAggregationInput | TaxPayerTypesOrderByWithAggregationInput[]
    by: TaxPayerTypesScalarFieldEnum[] | TaxPayerTypesScalarFieldEnum
    having?: TaxPayerTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxPayerTypesCountAggregateInputType | true
    _avg?: TaxPayerTypesAvgAggregateInputType
    _sum?: TaxPayerTypesSumAggregateInputType
    _min?: TaxPayerTypesMinAggregateInputType
    _max?: TaxPayerTypesMaxAggregateInputType
  }

  export type TaxPayerTypesGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: TaxPayerTypesCountAggregateOutputType | null
    _avg: TaxPayerTypesAvgAggregateOutputType | null
    _sum: TaxPayerTypesSumAggregateOutputType | null
    _min: TaxPayerTypesMinAggregateOutputType | null
    _max: TaxPayerTypesMaxAggregateOutputType | null
  }

  type GetTaxPayerTypesGroupByPayload<T extends TaxPayerTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxPayerTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxPayerTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxPayerTypesGroupByOutputType[P]>
            : GetScalarType<T[P], TaxPayerTypesGroupByOutputType[P]>
        }
      >
    >


  export type TaxPayerTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    PurchasesOrExpenses?: boolean | TaxPayerTypes$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | TaxPayerTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxPayerTypes"]>

  export type TaxPayerTypesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["taxPayerTypes"]>

  export type TaxPayerTypesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type TaxPayerTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | TaxPayerTypes$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | TaxPayerTypesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaxPayerTypesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaxPayerTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxPayerTypes"
    objects: {
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["taxPayerTypes"]>
    composites: {}
  }

  type TaxPayerTypesGetPayload<S extends boolean | null | undefined | TaxPayerTypesDefaultArgs> = $Result.GetResult<Prisma.$TaxPayerTypesPayload, S>

  type TaxPayerTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaxPayerTypesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaxPayerTypesCountAggregateInputType | true
    }

  export interface TaxPayerTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxPayerTypes'], meta: { name: 'TaxPayerTypes' } }
    /**
     * Find zero or one TaxPayerTypes that matches the filter.
     * @param {TaxPayerTypesFindUniqueArgs} args - Arguments to find a TaxPayerTypes
     * @example
     * // Get one TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxPayerTypesFindUniqueArgs>(args: SelectSubset<T, TaxPayerTypesFindUniqueArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaxPayerTypes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaxPayerTypesFindUniqueOrThrowArgs} args - Arguments to find a TaxPayerTypes
     * @example
     * // Get one TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxPayerTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxPayerTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaxPayerTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerTypesFindFirstArgs} args - Arguments to find a TaxPayerTypes
     * @example
     * // Get one TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxPayerTypesFindFirstArgs>(args?: SelectSubset<T, TaxPayerTypesFindFirstArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaxPayerTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerTypesFindFirstOrThrowArgs} args - Arguments to find a TaxPayerTypes
     * @example
     * // Get one TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxPayerTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxPayerTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaxPayerTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.findMany()
     * 
     * // Get first 10 TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxPayerTypesWithIdOnly = await prisma.taxPayerTypes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxPayerTypesFindManyArgs>(args?: SelectSubset<T, TaxPayerTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaxPayerTypes.
     * @param {TaxPayerTypesCreateArgs} args - Arguments to create a TaxPayerTypes.
     * @example
     * // Create one TaxPayerTypes
     * const TaxPayerTypes = await prisma.taxPayerTypes.create({
     *   data: {
     *     // ... data to create a TaxPayerTypes
     *   }
     * })
     * 
     */
    create<T extends TaxPayerTypesCreateArgs>(args: SelectSubset<T, TaxPayerTypesCreateArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaxPayerTypes.
     * @param {TaxPayerTypesCreateManyArgs} args - Arguments to create many TaxPayerTypes.
     * @example
     * // Create many TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxPayerTypesCreateManyArgs>(args?: SelectSubset<T, TaxPayerTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxPayerTypes and returns the data saved in the database.
     * @param {TaxPayerTypesCreateManyAndReturnArgs} args - Arguments to create many TaxPayerTypes.
     * @example
     * // Create many TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxPayerTypes and only return the `id`
     * const taxPayerTypesWithIdOnly = await prisma.taxPayerTypes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxPayerTypesCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxPayerTypesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaxPayerTypes.
     * @param {TaxPayerTypesDeleteArgs} args - Arguments to delete one TaxPayerTypes.
     * @example
     * // Delete one TaxPayerTypes
     * const TaxPayerTypes = await prisma.taxPayerTypes.delete({
     *   where: {
     *     // ... filter to delete one TaxPayerTypes
     *   }
     * })
     * 
     */
    delete<T extends TaxPayerTypesDeleteArgs>(args: SelectSubset<T, TaxPayerTypesDeleteArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaxPayerTypes.
     * @param {TaxPayerTypesUpdateArgs} args - Arguments to update one TaxPayerTypes.
     * @example
     * // Update one TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxPayerTypesUpdateArgs>(args: SelectSubset<T, TaxPayerTypesUpdateArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaxPayerTypes.
     * @param {TaxPayerTypesDeleteManyArgs} args - Arguments to filter TaxPayerTypes to delete.
     * @example
     * // Delete a few TaxPayerTypes
     * const { count } = await prisma.taxPayerTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxPayerTypesDeleteManyArgs>(args?: SelectSubset<T, TaxPayerTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxPayerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxPayerTypesUpdateManyArgs>(args: SelectSubset<T, TaxPayerTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxPayerTypes.
     * @param {TaxPayerTypesUpsertArgs} args - Arguments to update or create a TaxPayerTypes.
     * @example
     * // Update or create a TaxPayerTypes
     * const taxPayerTypes = await prisma.taxPayerTypes.upsert({
     *   create: {
     *     // ... data to create a TaxPayerTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxPayerTypes we want to update
     *   }
     * })
     */
    upsert<T extends TaxPayerTypesUpsertArgs>(args: SelectSubset<T, TaxPayerTypesUpsertArgs<ExtArgs>>): Prisma__TaxPayerTypesClient<$Result.GetResult<Prisma.$TaxPayerTypesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaxPayerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerTypesCountArgs} args - Arguments to filter TaxPayerTypes to count.
     * @example
     * // Count the number of TaxPayerTypes
     * const count = await prisma.taxPayerTypes.count({
     *   where: {
     *     // ... the filter for the TaxPayerTypes we want to count
     *   }
     * })
    **/
    count<T extends TaxPayerTypesCountArgs>(
      args?: Subset<T, TaxPayerTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxPayerTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxPayerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxPayerTypesAggregateArgs>(args: Subset<T, TaxPayerTypesAggregateArgs>): Prisma.PrismaPromise<GetTaxPayerTypesAggregateType<T>>

    /**
     * Group by TaxPayerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxPayerTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxPayerTypesGroupByArgs['orderBy'] }
        : { orderBy?: TaxPayerTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxPayerTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxPayerTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxPayerTypes model
   */
  readonly fields: TaxPayerTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxPayerTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxPayerTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesOrExpenses<T extends TaxPayerTypes$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayerTypes$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxPayerTypes model
   */ 
  interface TaxPayerTypesFieldRefs {
    readonly id: FieldRef<"TaxPayerTypes", 'Int'>
    readonly name: FieldRef<"TaxPayerTypes", 'String'>
    readonly createdAt: FieldRef<"TaxPayerTypes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxPayerTypes findUnique
   */
  export type TaxPayerTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayerTypes to fetch.
     */
    where: TaxPayerTypesWhereUniqueInput
  }

  /**
   * TaxPayerTypes findUniqueOrThrow
   */
  export type TaxPayerTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayerTypes to fetch.
     */
    where: TaxPayerTypesWhereUniqueInput
  }

  /**
   * TaxPayerTypes findFirst
   */
  export type TaxPayerTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayerTypes to fetch.
     */
    where?: TaxPayerTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayerTypes to fetch.
     */
    orderBy?: TaxPayerTypesOrderByWithRelationInput | TaxPayerTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPayerTypes.
     */
    cursor?: TaxPayerTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPayerTypes.
     */
    distinct?: TaxPayerTypesScalarFieldEnum | TaxPayerTypesScalarFieldEnum[]
  }

  /**
   * TaxPayerTypes findFirstOrThrow
   */
  export type TaxPayerTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayerTypes to fetch.
     */
    where?: TaxPayerTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayerTypes to fetch.
     */
    orderBy?: TaxPayerTypesOrderByWithRelationInput | TaxPayerTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPayerTypes.
     */
    cursor?: TaxPayerTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPayerTypes.
     */
    distinct?: TaxPayerTypesScalarFieldEnum | TaxPayerTypesScalarFieldEnum[]
  }

  /**
   * TaxPayerTypes findMany
   */
  export type TaxPayerTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayerTypes to fetch.
     */
    where?: TaxPayerTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayerTypes to fetch.
     */
    orderBy?: TaxPayerTypesOrderByWithRelationInput | TaxPayerTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxPayerTypes.
     */
    cursor?: TaxPayerTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayerTypes.
     */
    skip?: number
    distinct?: TaxPayerTypesScalarFieldEnum | TaxPayerTypesScalarFieldEnum[]
  }

  /**
   * TaxPayerTypes create
   */
  export type TaxPayerTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxPayerTypes.
     */
    data: XOR<TaxPayerTypesCreateInput, TaxPayerTypesUncheckedCreateInput>
  }

  /**
   * TaxPayerTypes createMany
   */
  export type TaxPayerTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxPayerTypes.
     */
    data: TaxPayerTypesCreateManyInput | TaxPayerTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxPayerTypes createManyAndReturn
   */
  export type TaxPayerTypesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaxPayerTypes.
     */
    data: TaxPayerTypesCreateManyInput | TaxPayerTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxPayerTypes update
   */
  export type TaxPayerTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxPayerTypes.
     */
    data: XOR<TaxPayerTypesUpdateInput, TaxPayerTypesUncheckedUpdateInput>
    /**
     * Choose, which TaxPayerTypes to update.
     */
    where: TaxPayerTypesWhereUniqueInput
  }

  /**
   * TaxPayerTypes updateMany
   */
  export type TaxPayerTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxPayerTypes.
     */
    data: XOR<TaxPayerTypesUpdateManyMutationInput, TaxPayerTypesUncheckedUpdateManyInput>
    /**
     * Filter which TaxPayerTypes to update
     */
    where?: TaxPayerTypesWhereInput
  }

  /**
   * TaxPayerTypes upsert
   */
  export type TaxPayerTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxPayerTypes to update in case it exists.
     */
    where: TaxPayerTypesWhereUniqueInput
    /**
     * In case the TaxPayerTypes found by the `where` argument doesn't exist, create a new TaxPayerTypes with this data.
     */
    create: XOR<TaxPayerTypesCreateInput, TaxPayerTypesUncheckedCreateInput>
    /**
     * In case the TaxPayerTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxPayerTypesUpdateInput, TaxPayerTypesUncheckedUpdateInput>
  }

  /**
   * TaxPayerTypes delete
   */
  export type TaxPayerTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
    /**
     * Filter which TaxPayerTypes to delete.
     */
    where: TaxPayerTypesWhereUniqueInput
  }

  /**
   * TaxPayerTypes deleteMany
   */
  export type TaxPayerTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPayerTypes to delete
     */
    where?: TaxPayerTypesWhereInput
  }

  /**
   * TaxPayerTypes.PurchasesOrExpenses
   */
  export type TaxPayerTypes$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * TaxPayerTypes without action
   */
  export type TaxPayerTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayerTypes
     */
    select?: TaxPayerTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerTypesInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceType
   */

  export type AggregateInvoiceType = {
    _count: InvoiceTypeCountAggregateOutputType | null
    _min: InvoiceTypeMinAggregateOutputType | null
    _max: InvoiceTypeMaxAggregateOutputType | null
  }

  export type InvoiceTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type InvoiceTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type InvoiceTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type InvoiceTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type InvoiceTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type InvoiceTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceType to aggregate.
     */
    where?: InvoiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTypes to fetch.
     */
    orderBy?: InvoiceTypeOrderByWithRelationInput | InvoiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceTypes
    **/
    _count?: true | InvoiceTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceTypeMaxAggregateInputType
  }

  export type GetInvoiceTypeAggregateType<T extends InvoiceTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceType[P]>
      : GetScalarType<T[P], AggregateInvoiceType[P]>
  }




  export type InvoiceTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceTypeWhereInput
    orderBy?: InvoiceTypeOrderByWithAggregationInput | InvoiceTypeOrderByWithAggregationInput[]
    by: InvoiceTypeScalarFieldEnum[] | InvoiceTypeScalarFieldEnum
    having?: InvoiceTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceTypeCountAggregateInputType | true
    _min?: InvoiceTypeMinAggregateInputType
    _max?: InvoiceTypeMaxAggregateInputType
  }

  export type InvoiceTypeGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: InvoiceTypeCountAggregateOutputType | null
    _min: InvoiceTypeMinAggregateOutputType | null
    _max: InvoiceTypeMaxAggregateOutputType | null
  }

  type GetInvoiceTypeGroupByPayload<T extends InvoiceTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceTypeGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceTypeGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    Concepts?: boolean | InvoiceType$ConceptsArgs<ExtArgs>
    _count?: boolean | InvoiceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceType"]>

  export type InvoiceTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["invoiceType"]>

  export type InvoiceTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type InvoiceTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Concepts?: boolean | InvoiceType$ConceptsArgs<ExtArgs>
    _count?: boolean | InvoiceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InvoiceTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceType"
    objects: {
      Concepts: Prisma.$ConceptsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["invoiceType"]>
    composites: {}
  }

  type InvoiceTypeGetPayload<S extends boolean | null | undefined | InvoiceTypeDefaultArgs> = $Result.GetResult<Prisma.$InvoiceTypePayload, S>

  type InvoiceTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceTypeCountAggregateInputType | true
    }

  export interface InvoiceTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceType'], meta: { name: 'InvoiceType' } }
    /**
     * Find zero or one InvoiceType that matches the filter.
     * @param {InvoiceTypeFindUniqueArgs} args - Arguments to find a InvoiceType
     * @example
     * // Get one InvoiceType
     * const invoiceType = await prisma.invoiceType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceTypeFindUniqueArgs>(args: SelectSubset<T, InvoiceTypeFindUniqueArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceTypeFindUniqueOrThrowArgs} args - Arguments to find a InvoiceType
     * @example
     * // Get one InvoiceType
     * const invoiceType = await prisma.invoiceType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTypeFindFirstArgs} args - Arguments to find a InvoiceType
     * @example
     * // Get one InvoiceType
     * const invoiceType = await prisma.invoiceType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceTypeFindFirstArgs>(args?: SelectSubset<T, InvoiceTypeFindFirstArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTypeFindFirstOrThrowArgs} args - Arguments to find a InvoiceType
     * @example
     * // Get one InvoiceType
     * const invoiceType = await prisma.invoiceType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceTypes
     * const invoiceTypes = await prisma.invoiceType.findMany()
     * 
     * // Get first 10 InvoiceTypes
     * const invoiceTypes = await prisma.invoiceType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceTypeWithIdOnly = await prisma.invoiceType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceTypeFindManyArgs>(args?: SelectSubset<T, InvoiceTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceType.
     * @param {InvoiceTypeCreateArgs} args - Arguments to create a InvoiceType.
     * @example
     * // Create one InvoiceType
     * const InvoiceType = await prisma.invoiceType.create({
     *   data: {
     *     // ... data to create a InvoiceType
     *   }
     * })
     * 
     */
    create<T extends InvoiceTypeCreateArgs>(args: SelectSubset<T, InvoiceTypeCreateArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceTypes.
     * @param {InvoiceTypeCreateManyArgs} args - Arguments to create many InvoiceTypes.
     * @example
     * // Create many InvoiceTypes
     * const invoiceType = await prisma.invoiceType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceTypeCreateManyArgs>(args?: SelectSubset<T, InvoiceTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceTypes and returns the data saved in the database.
     * @param {InvoiceTypeCreateManyAndReturnArgs} args - Arguments to create many InvoiceTypes.
     * @example
     * // Create many InvoiceTypes
     * const invoiceType = await prisma.invoiceType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceTypes and only return the `id`
     * const invoiceTypeWithIdOnly = await prisma.invoiceType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceType.
     * @param {InvoiceTypeDeleteArgs} args - Arguments to delete one InvoiceType.
     * @example
     * // Delete one InvoiceType
     * const InvoiceType = await prisma.invoiceType.delete({
     *   where: {
     *     // ... filter to delete one InvoiceType
     *   }
     * })
     * 
     */
    delete<T extends InvoiceTypeDeleteArgs>(args: SelectSubset<T, InvoiceTypeDeleteArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceType.
     * @param {InvoiceTypeUpdateArgs} args - Arguments to update one InvoiceType.
     * @example
     * // Update one InvoiceType
     * const invoiceType = await prisma.invoiceType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceTypeUpdateArgs>(args: SelectSubset<T, InvoiceTypeUpdateArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceTypes.
     * @param {InvoiceTypeDeleteManyArgs} args - Arguments to filter InvoiceTypes to delete.
     * @example
     * // Delete a few InvoiceTypes
     * const { count } = await prisma.invoiceType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceTypeDeleteManyArgs>(args?: SelectSubset<T, InvoiceTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceTypes
     * const invoiceType = await prisma.invoiceType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceTypeUpdateManyArgs>(args: SelectSubset<T, InvoiceTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceType.
     * @param {InvoiceTypeUpsertArgs} args - Arguments to update or create a InvoiceType.
     * @example
     * // Update or create a InvoiceType
     * const invoiceType = await prisma.invoiceType.upsert({
     *   create: {
     *     // ... data to create a InvoiceType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceType we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceTypeUpsertArgs>(args: SelectSubset<T, InvoiceTypeUpsertArgs<ExtArgs>>): Prisma__InvoiceTypeClient<$Result.GetResult<Prisma.$InvoiceTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTypeCountArgs} args - Arguments to filter InvoiceTypes to count.
     * @example
     * // Count the number of InvoiceTypes
     * const count = await prisma.invoiceType.count({
     *   where: {
     *     // ... the filter for the InvoiceTypes we want to count
     *   }
     * })
    **/
    count<T extends InvoiceTypeCountArgs>(
      args?: Subset<T, InvoiceTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceTypeAggregateArgs>(args: Subset<T, InvoiceTypeAggregateArgs>): Prisma.PrismaPromise<GetInvoiceTypeAggregateType<T>>

    /**
     * Group by InvoiceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceTypeGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceType model
   */
  readonly fields: InvoiceTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Concepts<T extends InvoiceType$ConceptsArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceType$ConceptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceType model
   */ 
  interface InvoiceTypeFieldRefs {
    readonly id: FieldRef<"InvoiceType", 'String'>
    readonly name: FieldRef<"InvoiceType", 'String'>
    readonly createdAt: FieldRef<"InvoiceType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceType findUnique
   */
  export type InvoiceTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceType to fetch.
     */
    where: InvoiceTypeWhereUniqueInput
  }

  /**
   * InvoiceType findUniqueOrThrow
   */
  export type InvoiceTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceType to fetch.
     */
    where: InvoiceTypeWhereUniqueInput
  }

  /**
   * InvoiceType findFirst
   */
  export type InvoiceTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceType to fetch.
     */
    where?: InvoiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTypes to fetch.
     */
    orderBy?: InvoiceTypeOrderByWithRelationInput | InvoiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceTypes.
     */
    cursor?: InvoiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceTypes.
     */
    distinct?: InvoiceTypeScalarFieldEnum | InvoiceTypeScalarFieldEnum[]
  }

  /**
   * InvoiceType findFirstOrThrow
   */
  export type InvoiceTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceType to fetch.
     */
    where?: InvoiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTypes to fetch.
     */
    orderBy?: InvoiceTypeOrderByWithRelationInput | InvoiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceTypes.
     */
    cursor?: InvoiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceTypes.
     */
    distinct?: InvoiceTypeScalarFieldEnum | InvoiceTypeScalarFieldEnum[]
  }

  /**
   * InvoiceType findMany
   */
  export type InvoiceTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceTypes to fetch.
     */
    where?: InvoiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTypes to fetch.
     */
    orderBy?: InvoiceTypeOrderByWithRelationInput | InvoiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceTypes.
     */
    cursor?: InvoiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTypes.
     */
    skip?: number
    distinct?: InvoiceTypeScalarFieldEnum | InvoiceTypeScalarFieldEnum[]
  }

  /**
   * InvoiceType create
   */
  export type InvoiceTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceType.
     */
    data: XOR<InvoiceTypeCreateInput, InvoiceTypeUncheckedCreateInput>
  }

  /**
   * InvoiceType createMany
   */
  export type InvoiceTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceTypes.
     */
    data: InvoiceTypeCreateManyInput | InvoiceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceType createManyAndReturn
   */
  export type InvoiceTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceTypes.
     */
    data: InvoiceTypeCreateManyInput | InvoiceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceType update
   */
  export type InvoiceTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceType.
     */
    data: XOR<InvoiceTypeUpdateInput, InvoiceTypeUncheckedUpdateInput>
    /**
     * Choose, which InvoiceType to update.
     */
    where: InvoiceTypeWhereUniqueInput
  }

  /**
   * InvoiceType updateMany
   */
  export type InvoiceTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceTypes.
     */
    data: XOR<InvoiceTypeUpdateManyMutationInput, InvoiceTypeUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceTypes to update
     */
    where?: InvoiceTypeWhereInput
  }

  /**
   * InvoiceType upsert
   */
  export type InvoiceTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceType to update in case it exists.
     */
    where: InvoiceTypeWhereUniqueInput
    /**
     * In case the InvoiceType found by the `where` argument doesn't exist, create a new InvoiceType with this data.
     */
    create: XOR<InvoiceTypeCreateInput, InvoiceTypeUncheckedCreateInput>
    /**
     * In case the InvoiceType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceTypeUpdateInput, InvoiceTypeUncheckedUpdateInput>
  }

  /**
   * InvoiceType delete
   */
  export type InvoiceTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
    /**
     * Filter which InvoiceType to delete.
     */
    where: InvoiceTypeWhereUniqueInput
  }

  /**
   * InvoiceType deleteMany
   */
  export type InvoiceTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceTypes to delete
     */
    where?: InvoiceTypeWhereInput
  }

  /**
   * InvoiceType.Concepts
   */
  export type InvoiceType$ConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepts
     */
    select?: ConceptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptsInclude<ExtArgs> | null
    where?: ConceptsWhereInput
    orderBy?: ConceptsOrderByWithRelationInput | ConceptsOrderByWithRelationInput[]
    cursor?: ConceptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptsScalarFieldEnum | ConceptsScalarFieldEnum[]
  }

  /**
   * InvoiceType without action
   */
  export type InvoiceTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceType
     */
    select?: InvoiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTypeInclude<ExtArgs> | null
  }


  /**
   * Model PaymentsMethods
   */

  export type AggregatePaymentsMethods = {
    _count: PaymentsMethodsCountAggregateOutputType | null
    _min: PaymentsMethodsMinAggregateOutputType | null
    _max: PaymentsMethodsMaxAggregateOutputType | null
  }

  export type PaymentsMethodsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type PaymentsMethodsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type PaymentsMethodsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type PaymentsMethodsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type PaymentsMethodsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type PaymentsMethodsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentsMethodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentsMethods to aggregate.
     */
    where?: PaymentsMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentsMethods to fetch.
     */
    orderBy?: PaymentsMethodsOrderByWithRelationInput | PaymentsMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentsMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentsMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentsMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentsMethods
    **/
    _count?: true | PaymentsMethodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMethodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMethodsMaxAggregateInputType
  }

  export type GetPaymentsMethodsAggregateType<T extends PaymentsMethodsAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentsMethods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentsMethods[P]>
      : GetScalarType<T[P], AggregatePaymentsMethods[P]>
  }




  export type PaymentsMethodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsMethodsWhereInput
    orderBy?: PaymentsMethodsOrderByWithAggregationInput | PaymentsMethodsOrderByWithAggregationInput[]
    by: PaymentsMethodsScalarFieldEnum[] | PaymentsMethodsScalarFieldEnum
    having?: PaymentsMethodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsMethodsCountAggregateInputType | true
    _min?: PaymentsMethodsMinAggregateInputType
    _max?: PaymentsMethodsMaxAggregateInputType
  }

  export type PaymentsMethodsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: PaymentsMethodsCountAggregateOutputType | null
    _min: PaymentsMethodsMinAggregateOutputType | null
    _max: PaymentsMethodsMaxAggregateOutputType | null
  }

  type GetPaymentsMethodsGroupByPayload<T extends PaymentsMethodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsMethodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsMethodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsMethodsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsMethodsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentsMethodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    PurchasesOrExpenses?: boolean | PaymentsMethods$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | PaymentsMethodsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentsMethods"]>

  export type PaymentsMethodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentsMethods"]>

  export type PaymentsMethodsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type PaymentsMethodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | PaymentsMethods$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | PaymentsMethodsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentsMethodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentsMethodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentsMethods"
    objects: {
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["paymentsMethods"]>
    composites: {}
  }

  type PaymentsMethodsGetPayload<S extends boolean | null | undefined | PaymentsMethodsDefaultArgs> = $Result.GetResult<Prisma.$PaymentsMethodsPayload, S>

  type PaymentsMethodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentsMethodsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentsMethodsCountAggregateInputType | true
    }

  export interface PaymentsMethodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentsMethods'], meta: { name: 'PaymentsMethods' } }
    /**
     * Find zero or one PaymentsMethods that matches the filter.
     * @param {PaymentsMethodsFindUniqueArgs} args - Arguments to find a PaymentsMethods
     * @example
     * // Get one PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentsMethodsFindUniqueArgs>(args: SelectSubset<T, PaymentsMethodsFindUniqueArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentsMethods that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentsMethodsFindUniqueOrThrowArgs} args - Arguments to find a PaymentsMethods
     * @example
     * // Get one PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentsMethodsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentsMethodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentsMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsMethodsFindFirstArgs} args - Arguments to find a PaymentsMethods
     * @example
     * // Get one PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentsMethodsFindFirstArgs>(args?: SelectSubset<T, PaymentsMethodsFindFirstArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentsMethods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsMethodsFindFirstOrThrowArgs} args - Arguments to find a PaymentsMethods
     * @example
     * // Get one PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentsMethodsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentsMethodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentsMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsMethodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.findMany()
     * 
     * // Get first 10 PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsMethodsWithIdOnly = await prisma.paymentsMethods.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentsMethodsFindManyArgs>(args?: SelectSubset<T, PaymentsMethodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentsMethods.
     * @param {PaymentsMethodsCreateArgs} args - Arguments to create a PaymentsMethods.
     * @example
     * // Create one PaymentsMethods
     * const PaymentsMethods = await prisma.paymentsMethods.create({
     *   data: {
     *     // ... data to create a PaymentsMethods
     *   }
     * })
     * 
     */
    create<T extends PaymentsMethodsCreateArgs>(args: SelectSubset<T, PaymentsMethodsCreateArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentsMethods.
     * @param {PaymentsMethodsCreateManyArgs} args - Arguments to create many PaymentsMethods.
     * @example
     * // Create many PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentsMethodsCreateManyArgs>(args?: SelectSubset<T, PaymentsMethodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentsMethods and returns the data saved in the database.
     * @param {PaymentsMethodsCreateManyAndReturnArgs} args - Arguments to create many PaymentsMethods.
     * @example
     * // Create many PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentsMethods and only return the `id`
     * const paymentsMethodsWithIdOnly = await prisma.paymentsMethods.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentsMethodsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentsMethodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentsMethods.
     * @param {PaymentsMethodsDeleteArgs} args - Arguments to delete one PaymentsMethods.
     * @example
     * // Delete one PaymentsMethods
     * const PaymentsMethods = await prisma.paymentsMethods.delete({
     *   where: {
     *     // ... filter to delete one PaymentsMethods
     *   }
     * })
     * 
     */
    delete<T extends PaymentsMethodsDeleteArgs>(args: SelectSubset<T, PaymentsMethodsDeleteArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentsMethods.
     * @param {PaymentsMethodsUpdateArgs} args - Arguments to update one PaymentsMethods.
     * @example
     * // Update one PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentsMethodsUpdateArgs>(args: SelectSubset<T, PaymentsMethodsUpdateArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentsMethods.
     * @param {PaymentsMethodsDeleteManyArgs} args - Arguments to filter PaymentsMethods to delete.
     * @example
     * // Delete a few PaymentsMethods
     * const { count } = await prisma.paymentsMethods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentsMethodsDeleteManyArgs>(args?: SelectSubset<T, PaymentsMethodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentsMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsMethodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentsMethodsUpdateManyArgs>(args: SelectSubset<T, PaymentsMethodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentsMethods.
     * @param {PaymentsMethodsUpsertArgs} args - Arguments to update or create a PaymentsMethods.
     * @example
     * // Update or create a PaymentsMethods
     * const paymentsMethods = await prisma.paymentsMethods.upsert({
     *   create: {
     *     // ... data to create a PaymentsMethods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentsMethods we want to update
     *   }
     * })
     */
    upsert<T extends PaymentsMethodsUpsertArgs>(args: SelectSubset<T, PaymentsMethodsUpsertArgs<ExtArgs>>): Prisma__PaymentsMethodsClient<$Result.GetResult<Prisma.$PaymentsMethodsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentsMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsMethodsCountArgs} args - Arguments to filter PaymentsMethods to count.
     * @example
     * // Count the number of PaymentsMethods
     * const count = await prisma.paymentsMethods.count({
     *   where: {
     *     // ... the filter for the PaymentsMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentsMethodsCountArgs>(
      args?: Subset<T, PaymentsMethodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsMethodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentsMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsMethodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsMethodsAggregateArgs>(args: Subset<T, PaymentsMethodsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsMethodsAggregateType<T>>

    /**
     * Group by PaymentsMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsMethodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentsMethodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentsMethodsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentsMethodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentsMethodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsMethodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentsMethods model
   */
  readonly fields: PaymentsMethodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentsMethods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentsMethodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesOrExpenses<T extends PaymentsMethods$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, PaymentsMethods$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentsMethods model
   */ 
  interface PaymentsMethodsFieldRefs {
    readonly id: FieldRef<"PaymentsMethods", 'String'>
    readonly name: FieldRef<"PaymentsMethods", 'String'>
    readonly createdAt: FieldRef<"PaymentsMethods", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentsMethods findUnique
   */
  export type PaymentsMethodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentsMethods to fetch.
     */
    where: PaymentsMethodsWhereUniqueInput
  }

  /**
   * PaymentsMethods findUniqueOrThrow
   */
  export type PaymentsMethodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentsMethods to fetch.
     */
    where: PaymentsMethodsWhereUniqueInput
  }

  /**
   * PaymentsMethods findFirst
   */
  export type PaymentsMethodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentsMethods to fetch.
     */
    where?: PaymentsMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentsMethods to fetch.
     */
    orderBy?: PaymentsMethodsOrderByWithRelationInput | PaymentsMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentsMethods.
     */
    cursor?: PaymentsMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentsMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentsMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentsMethods.
     */
    distinct?: PaymentsMethodsScalarFieldEnum | PaymentsMethodsScalarFieldEnum[]
  }

  /**
   * PaymentsMethods findFirstOrThrow
   */
  export type PaymentsMethodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentsMethods to fetch.
     */
    where?: PaymentsMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentsMethods to fetch.
     */
    orderBy?: PaymentsMethodsOrderByWithRelationInput | PaymentsMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentsMethods.
     */
    cursor?: PaymentsMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentsMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentsMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentsMethods.
     */
    distinct?: PaymentsMethodsScalarFieldEnum | PaymentsMethodsScalarFieldEnum[]
  }

  /**
   * PaymentsMethods findMany
   */
  export type PaymentsMethodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentsMethods to fetch.
     */
    where?: PaymentsMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentsMethods to fetch.
     */
    orderBy?: PaymentsMethodsOrderByWithRelationInput | PaymentsMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentsMethods.
     */
    cursor?: PaymentsMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentsMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentsMethods.
     */
    skip?: number
    distinct?: PaymentsMethodsScalarFieldEnum | PaymentsMethodsScalarFieldEnum[]
  }

  /**
   * PaymentsMethods create
   */
  export type PaymentsMethodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentsMethods.
     */
    data: XOR<PaymentsMethodsCreateInput, PaymentsMethodsUncheckedCreateInput>
  }

  /**
   * PaymentsMethods createMany
   */
  export type PaymentsMethodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentsMethods.
     */
    data: PaymentsMethodsCreateManyInput | PaymentsMethodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentsMethods createManyAndReturn
   */
  export type PaymentsMethodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentsMethods.
     */
    data: PaymentsMethodsCreateManyInput | PaymentsMethodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentsMethods update
   */
  export type PaymentsMethodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentsMethods.
     */
    data: XOR<PaymentsMethodsUpdateInput, PaymentsMethodsUncheckedUpdateInput>
    /**
     * Choose, which PaymentsMethods to update.
     */
    where: PaymentsMethodsWhereUniqueInput
  }

  /**
   * PaymentsMethods updateMany
   */
  export type PaymentsMethodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentsMethods.
     */
    data: XOR<PaymentsMethodsUpdateManyMutationInput, PaymentsMethodsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentsMethods to update
     */
    where?: PaymentsMethodsWhereInput
  }

  /**
   * PaymentsMethods upsert
   */
  export type PaymentsMethodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentsMethods to update in case it exists.
     */
    where: PaymentsMethodsWhereUniqueInput
    /**
     * In case the PaymentsMethods found by the `where` argument doesn't exist, create a new PaymentsMethods with this data.
     */
    create: XOR<PaymentsMethodsCreateInput, PaymentsMethodsUncheckedCreateInput>
    /**
     * In case the PaymentsMethods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentsMethodsUpdateInput, PaymentsMethodsUncheckedUpdateInput>
  }

  /**
   * PaymentsMethods delete
   */
  export type PaymentsMethodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
    /**
     * Filter which PaymentsMethods to delete.
     */
    where: PaymentsMethodsWhereUniqueInput
  }

  /**
   * PaymentsMethods deleteMany
   */
  export type PaymentsMethodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentsMethods to delete
     */
    where?: PaymentsMethodsWhereInput
  }

  /**
   * PaymentsMethods.PurchasesOrExpenses
   */
  export type PaymentsMethods$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * PaymentsMethods without action
   */
  export type PaymentsMethodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsMethods
     */
    select?: PaymentsMethodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsMethodsInclude<ExtArgs> | null
  }


  /**
   * Model NcfsTypes
   */

  export type AggregateNcfsTypes = {
    _count: NcfsTypesCountAggregateOutputType | null
    _avg: NcfsTypesAvgAggregateOutputType | null
    _sum: NcfsTypesSumAggregateOutputType | null
    _min: NcfsTypesMinAggregateOutputType | null
    _max: NcfsTypesMaxAggregateOutputType | null
  }

  export type NcfsTypesAvgAggregateOutputType = {
    serialId: number | null
  }

  export type NcfsTypesSumAggregateOutputType = {
    serialId: number | null
  }

  export type NcfsTypesMinAggregateOutputType = {
    id: string | null
    name: string | null
    serialId: number | null
    createdAt: Date | null
  }

  export type NcfsTypesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    serialId: number | null
    createdAt: Date | null
  }

  export type NcfsTypesCountAggregateOutputType = {
    id: number
    name: number
    serialId: number
    createdAt: number
    _all: number
  }


  export type NcfsTypesAvgAggregateInputType = {
    serialId?: true
  }

  export type NcfsTypesSumAggregateInputType = {
    serialId?: true
  }

  export type NcfsTypesMinAggregateInputType = {
    id?: true
    name?: true
    serialId?: true
    createdAt?: true
  }

  export type NcfsTypesMaxAggregateInputType = {
    id?: true
    name?: true
    serialId?: true
    createdAt?: true
  }

  export type NcfsTypesCountAggregateInputType = {
    id?: true
    name?: true
    serialId?: true
    createdAt?: true
    _all?: true
  }

  export type NcfsTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NcfsTypes to aggregate.
     */
    where?: NcfsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NcfsTypes to fetch.
     */
    orderBy?: NcfsTypesOrderByWithRelationInput | NcfsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NcfsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NcfsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NcfsTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NcfsTypes
    **/
    _count?: true | NcfsTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NcfsTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NcfsTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NcfsTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NcfsTypesMaxAggregateInputType
  }

  export type GetNcfsTypesAggregateType<T extends NcfsTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateNcfsTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNcfsTypes[P]>
      : GetScalarType<T[P], AggregateNcfsTypes[P]>
  }




  export type NcfsTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NcfsTypesWhereInput
    orderBy?: NcfsTypesOrderByWithAggregationInput | NcfsTypesOrderByWithAggregationInput[]
    by: NcfsTypesScalarFieldEnum[] | NcfsTypesScalarFieldEnum
    having?: NcfsTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NcfsTypesCountAggregateInputType | true
    _avg?: NcfsTypesAvgAggregateInputType
    _sum?: NcfsTypesSumAggregateInputType
    _min?: NcfsTypesMinAggregateInputType
    _max?: NcfsTypesMaxAggregateInputType
  }

  export type NcfsTypesGroupByOutputType = {
    id: string
    name: string
    serialId: number
    createdAt: Date
    _count: NcfsTypesCountAggregateOutputType | null
    _avg: NcfsTypesAvgAggregateOutputType | null
    _sum: NcfsTypesSumAggregateOutputType | null
    _min: NcfsTypesMinAggregateOutputType | null
    _max: NcfsTypesMaxAggregateOutputType | null
  }

  type GetNcfsTypesGroupByPayload<T extends NcfsTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NcfsTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NcfsTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NcfsTypesGroupByOutputType[P]>
            : GetScalarType<T[P], NcfsTypesGroupByOutputType[P]>
        }
      >
    >


  export type NcfsTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serialId?: boolean
    createdAt?: boolean
    serial?: boolean | SerialDefaultArgs<ExtArgs>
    PurchasesOrExpenses?: boolean | NcfsTypes$PurchasesOrExpensesArgs<ExtArgs>
    PurchasesOrExpensesOfNcfAffected?: boolean | NcfsTypes$PurchasesOrExpensesOfNcfAffectedArgs<ExtArgs>
    _count?: boolean | NcfsTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ncfsTypes"]>

  export type NcfsTypesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serialId?: boolean
    createdAt?: boolean
    serial?: boolean | SerialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ncfsTypes"]>

  export type NcfsTypesSelectScalar = {
    id?: boolean
    name?: boolean
    serialId?: boolean
    createdAt?: boolean
  }

  export type NcfsTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serial?: boolean | SerialDefaultArgs<ExtArgs>
    PurchasesOrExpenses?: boolean | NcfsTypes$PurchasesOrExpensesArgs<ExtArgs>
    PurchasesOrExpensesOfNcfAffected?: boolean | NcfsTypes$PurchasesOrExpensesOfNcfAffectedArgs<ExtArgs>
    _count?: boolean | NcfsTypesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NcfsTypesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serial?: boolean | SerialDefaultArgs<ExtArgs>
  }

  export type $NcfsTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NcfsTypes"
    objects: {
      serial: Prisma.$SerialPayload<ExtArgs>
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
      PurchasesOrExpensesOfNcfAffected: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      serialId: number
      createdAt: Date
    }, ExtArgs["result"]["ncfsTypes"]>
    composites: {}
  }

  type NcfsTypesGetPayload<S extends boolean | null | undefined | NcfsTypesDefaultArgs> = $Result.GetResult<Prisma.$NcfsTypesPayload, S>

  type NcfsTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NcfsTypesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NcfsTypesCountAggregateInputType | true
    }

  export interface NcfsTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NcfsTypes'], meta: { name: 'NcfsTypes' } }
    /**
     * Find zero or one NcfsTypes that matches the filter.
     * @param {NcfsTypesFindUniqueArgs} args - Arguments to find a NcfsTypes
     * @example
     * // Get one NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NcfsTypesFindUniqueArgs>(args: SelectSubset<T, NcfsTypesFindUniqueArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NcfsTypes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NcfsTypesFindUniqueOrThrowArgs} args - Arguments to find a NcfsTypes
     * @example
     * // Get one NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NcfsTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, NcfsTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NcfsTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NcfsTypesFindFirstArgs} args - Arguments to find a NcfsTypes
     * @example
     * // Get one NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NcfsTypesFindFirstArgs>(args?: SelectSubset<T, NcfsTypesFindFirstArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NcfsTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NcfsTypesFindFirstOrThrowArgs} args - Arguments to find a NcfsTypes
     * @example
     * // Get one NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NcfsTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, NcfsTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NcfsTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NcfsTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.findMany()
     * 
     * // Get first 10 NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ncfsTypesWithIdOnly = await prisma.ncfsTypes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NcfsTypesFindManyArgs>(args?: SelectSubset<T, NcfsTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NcfsTypes.
     * @param {NcfsTypesCreateArgs} args - Arguments to create a NcfsTypes.
     * @example
     * // Create one NcfsTypes
     * const NcfsTypes = await prisma.ncfsTypes.create({
     *   data: {
     *     // ... data to create a NcfsTypes
     *   }
     * })
     * 
     */
    create<T extends NcfsTypesCreateArgs>(args: SelectSubset<T, NcfsTypesCreateArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NcfsTypes.
     * @param {NcfsTypesCreateManyArgs} args - Arguments to create many NcfsTypes.
     * @example
     * // Create many NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NcfsTypesCreateManyArgs>(args?: SelectSubset<T, NcfsTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NcfsTypes and returns the data saved in the database.
     * @param {NcfsTypesCreateManyAndReturnArgs} args - Arguments to create many NcfsTypes.
     * @example
     * // Create many NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NcfsTypes and only return the `id`
     * const ncfsTypesWithIdOnly = await prisma.ncfsTypes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NcfsTypesCreateManyAndReturnArgs>(args?: SelectSubset<T, NcfsTypesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NcfsTypes.
     * @param {NcfsTypesDeleteArgs} args - Arguments to delete one NcfsTypes.
     * @example
     * // Delete one NcfsTypes
     * const NcfsTypes = await prisma.ncfsTypes.delete({
     *   where: {
     *     // ... filter to delete one NcfsTypes
     *   }
     * })
     * 
     */
    delete<T extends NcfsTypesDeleteArgs>(args: SelectSubset<T, NcfsTypesDeleteArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NcfsTypes.
     * @param {NcfsTypesUpdateArgs} args - Arguments to update one NcfsTypes.
     * @example
     * // Update one NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NcfsTypesUpdateArgs>(args: SelectSubset<T, NcfsTypesUpdateArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NcfsTypes.
     * @param {NcfsTypesDeleteManyArgs} args - Arguments to filter NcfsTypes to delete.
     * @example
     * // Delete a few NcfsTypes
     * const { count } = await prisma.ncfsTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NcfsTypesDeleteManyArgs>(args?: SelectSubset<T, NcfsTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NcfsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NcfsTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NcfsTypesUpdateManyArgs>(args: SelectSubset<T, NcfsTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NcfsTypes.
     * @param {NcfsTypesUpsertArgs} args - Arguments to update or create a NcfsTypes.
     * @example
     * // Update or create a NcfsTypes
     * const ncfsTypes = await prisma.ncfsTypes.upsert({
     *   create: {
     *     // ... data to create a NcfsTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NcfsTypes we want to update
     *   }
     * })
     */
    upsert<T extends NcfsTypesUpsertArgs>(args: SelectSubset<T, NcfsTypesUpsertArgs<ExtArgs>>): Prisma__NcfsTypesClient<$Result.GetResult<Prisma.$NcfsTypesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NcfsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NcfsTypesCountArgs} args - Arguments to filter NcfsTypes to count.
     * @example
     * // Count the number of NcfsTypes
     * const count = await prisma.ncfsTypes.count({
     *   where: {
     *     // ... the filter for the NcfsTypes we want to count
     *   }
     * })
    **/
    count<T extends NcfsTypesCountArgs>(
      args?: Subset<T, NcfsTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NcfsTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NcfsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NcfsTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NcfsTypesAggregateArgs>(args: Subset<T, NcfsTypesAggregateArgs>): Prisma.PrismaPromise<GetNcfsTypesAggregateType<T>>

    /**
     * Group by NcfsTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NcfsTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NcfsTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NcfsTypesGroupByArgs['orderBy'] }
        : { orderBy?: NcfsTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NcfsTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNcfsTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NcfsTypes model
   */
  readonly fields: NcfsTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NcfsTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NcfsTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serial<T extends SerialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SerialDefaultArgs<ExtArgs>>): Prisma__SerialClient<$Result.GetResult<Prisma.$SerialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    PurchasesOrExpenses<T extends NcfsTypes$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, NcfsTypes$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    PurchasesOrExpensesOfNcfAffected<T extends NcfsTypes$PurchasesOrExpensesOfNcfAffectedArgs<ExtArgs> = {}>(args?: Subset<T, NcfsTypes$PurchasesOrExpensesOfNcfAffectedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NcfsTypes model
   */ 
  interface NcfsTypesFieldRefs {
    readonly id: FieldRef<"NcfsTypes", 'String'>
    readonly name: FieldRef<"NcfsTypes", 'String'>
    readonly serialId: FieldRef<"NcfsTypes", 'Int'>
    readonly createdAt: FieldRef<"NcfsTypes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NcfsTypes findUnique
   */
  export type NcfsTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NcfsTypes to fetch.
     */
    where: NcfsTypesWhereUniqueInput
  }

  /**
   * NcfsTypes findUniqueOrThrow
   */
  export type NcfsTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NcfsTypes to fetch.
     */
    where: NcfsTypesWhereUniqueInput
  }

  /**
   * NcfsTypes findFirst
   */
  export type NcfsTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NcfsTypes to fetch.
     */
    where?: NcfsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NcfsTypes to fetch.
     */
    orderBy?: NcfsTypesOrderByWithRelationInput | NcfsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NcfsTypes.
     */
    cursor?: NcfsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NcfsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NcfsTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NcfsTypes.
     */
    distinct?: NcfsTypesScalarFieldEnum | NcfsTypesScalarFieldEnum[]
  }

  /**
   * NcfsTypes findFirstOrThrow
   */
  export type NcfsTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NcfsTypes to fetch.
     */
    where?: NcfsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NcfsTypes to fetch.
     */
    orderBy?: NcfsTypesOrderByWithRelationInput | NcfsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NcfsTypes.
     */
    cursor?: NcfsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NcfsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NcfsTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NcfsTypes.
     */
    distinct?: NcfsTypesScalarFieldEnum | NcfsTypesScalarFieldEnum[]
  }

  /**
   * NcfsTypes findMany
   */
  export type NcfsTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * Filter, which NcfsTypes to fetch.
     */
    where?: NcfsTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NcfsTypes to fetch.
     */
    orderBy?: NcfsTypesOrderByWithRelationInput | NcfsTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NcfsTypes.
     */
    cursor?: NcfsTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NcfsTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NcfsTypes.
     */
    skip?: number
    distinct?: NcfsTypesScalarFieldEnum | NcfsTypesScalarFieldEnum[]
  }

  /**
   * NcfsTypes create
   */
  export type NcfsTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a NcfsTypes.
     */
    data: XOR<NcfsTypesCreateInput, NcfsTypesUncheckedCreateInput>
  }

  /**
   * NcfsTypes createMany
   */
  export type NcfsTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NcfsTypes.
     */
    data: NcfsTypesCreateManyInput | NcfsTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NcfsTypes createManyAndReturn
   */
  export type NcfsTypesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NcfsTypes.
     */
    data: NcfsTypesCreateManyInput | NcfsTypesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NcfsTypes update
   */
  export type NcfsTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a NcfsTypes.
     */
    data: XOR<NcfsTypesUpdateInput, NcfsTypesUncheckedUpdateInput>
    /**
     * Choose, which NcfsTypes to update.
     */
    where: NcfsTypesWhereUniqueInput
  }

  /**
   * NcfsTypes updateMany
   */
  export type NcfsTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NcfsTypes.
     */
    data: XOR<NcfsTypesUpdateManyMutationInput, NcfsTypesUncheckedUpdateManyInput>
    /**
     * Filter which NcfsTypes to update
     */
    where?: NcfsTypesWhereInput
  }

  /**
   * NcfsTypes upsert
   */
  export type NcfsTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the NcfsTypes to update in case it exists.
     */
    where: NcfsTypesWhereUniqueInput
    /**
     * In case the NcfsTypes found by the `where` argument doesn't exist, create a new NcfsTypes with this data.
     */
    create: XOR<NcfsTypesCreateInput, NcfsTypesUncheckedCreateInput>
    /**
     * In case the NcfsTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NcfsTypesUpdateInput, NcfsTypesUncheckedUpdateInput>
  }

  /**
   * NcfsTypes delete
   */
  export type NcfsTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
    /**
     * Filter which NcfsTypes to delete.
     */
    where: NcfsTypesWhereUniqueInput
  }

  /**
   * NcfsTypes deleteMany
   */
  export type NcfsTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NcfsTypes to delete
     */
    where?: NcfsTypesWhereInput
  }

  /**
   * NcfsTypes.PurchasesOrExpenses
   */
  export type NcfsTypes$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * NcfsTypes.PurchasesOrExpensesOfNcfAffected
   */
  export type NcfsTypes$PurchasesOrExpensesOfNcfAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * NcfsTypes without action
   */
  export type NcfsTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NcfsTypes
     */
    select?: NcfsTypesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NcfsTypesInclude<ExtArgs> | null
  }


  /**
   * Model RetentionTax
   */

  export type AggregateRetentionTax = {
    _count: RetentionTaxCountAggregateOutputType | null
    _avg: RetentionTaxAvgAggregateOutputType | null
    _sum: RetentionTaxSumAggregateOutputType | null
    _min: RetentionTaxMinAggregateOutputType | null
    _max: RetentionTaxMaxAggregateOutputType | null
  }

  export type RetentionTaxAvgAggregateOutputType = {
    id: number | null
    rate: Decimal | null
  }

  export type RetentionTaxSumAggregateOutputType = {
    id: number | null
    rate: Decimal | null
  }

  export type RetentionTaxMinAggregateOutputType = {
    id: number | null
    name: string | null
    rate: Decimal | null
    createdAt: Date | null
  }

  export type RetentionTaxMaxAggregateOutputType = {
    id: number | null
    name: string | null
    rate: Decimal | null
    createdAt: Date | null
  }

  export type RetentionTaxCountAggregateOutputType = {
    id: number
    name: number
    rate: number
    createdAt: number
    _all: number
  }


  export type RetentionTaxAvgAggregateInputType = {
    id?: true
    rate?: true
  }

  export type RetentionTaxSumAggregateInputType = {
    id?: true
    rate?: true
  }

  export type RetentionTaxMinAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    createdAt?: true
  }

  export type RetentionTaxMaxAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    createdAt?: true
  }

  export type RetentionTaxCountAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    createdAt?: true
    _all?: true
  }

  export type RetentionTaxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetentionTax to aggregate.
     */
    where?: RetentionTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionTaxes to fetch.
     */
    orderBy?: RetentionTaxOrderByWithRelationInput | RetentionTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetentionTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RetentionTaxes
    **/
    _count?: true | RetentionTaxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RetentionTaxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RetentionTaxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetentionTaxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetentionTaxMaxAggregateInputType
  }

  export type GetRetentionTaxAggregateType<T extends RetentionTaxAggregateArgs> = {
        [P in keyof T & keyof AggregateRetentionTax]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetentionTax[P]>
      : GetScalarType<T[P], AggregateRetentionTax[P]>
  }




  export type RetentionTaxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetentionTaxWhereInput
    orderBy?: RetentionTaxOrderByWithAggregationInput | RetentionTaxOrderByWithAggregationInput[]
    by: RetentionTaxScalarFieldEnum[] | RetentionTaxScalarFieldEnum
    having?: RetentionTaxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetentionTaxCountAggregateInputType | true
    _avg?: RetentionTaxAvgAggregateInputType
    _sum?: RetentionTaxSumAggregateInputType
    _min?: RetentionTaxMinAggregateInputType
    _max?: RetentionTaxMaxAggregateInputType
  }

  export type RetentionTaxGroupByOutputType = {
    id: number
    name: string
    rate: Decimal
    createdAt: Date
    _count: RetentionTaxCountAggregateOutputType | null
    _avg: RetentionTaxAvgAggregateOutputType | null
    _sum: RetentionTaxSumAggregateOutputType | null
    _min: RetentionTaxMinAggregateOutputType | null
    _max: RetentionTaxMaxAggregateOutputType | null
  }

  type GetRetentionTaxGroupByPayload<T extends RetentionTaxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetentionTaxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetentionTaxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetentionTaxGroupByOutputType[P]>
            : GetScalarType<T[P], RetentionTaxGroupByOutputType[P]>
        }
      >
    >


  export type RetentionTaxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    createdAt?: boolean
    PurchasesOrExpenses?: boolean | RetentionTax$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | RetentionTaxCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retentionTax"]>

  export type RetentionTaxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["retentionTax"]>

  export type RetentionTaxSelectScalar = {
    id?: boolean
    name?: boolean
    rate?: boolean
    createdAt?: boolean
  }

  export type RetentionTaxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | RetentionTax$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | RetentionTaxCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RetentionTaxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RetentionTaxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RetentionTax"
    objects: {
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      rate: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["retentionTax"]>
    composites: {}
  }

  type RetentionTaxGetPayload<S extends boolean | null | undefined | RetentionTaxDefaultArgs> = $Result.GetResult<Prisma.$RetentionTaxPayload, S>

  type RetentionTaxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RetentionTaxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RetentionTaxCountAggregateInputType | true
    }

  export interface RetentionTaxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RetentionTax'], meta: { name: 'RetentionTax' } }
    /**
     * Find zero or one RetentionTax that matches the filter.
     * @param {RetentionTaxFindUniqueArgs} args - Arguments to find a RetentionTax
     * @example
     * // Get one RetentionTax
     * const retentionTax = await prisma.retentionTax.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetentionTaxFindUniqueArgs>(args: SelectSubset<T, RetentionTaxFindUniqueArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RetentionTax that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RetentionTaxFindUniqueOrThrowArgs} args - Arguments to find a RetentionTax
     * @example
     * // Get one RetentionTax
     * const retentionTax = await prisma.retentionTax.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetentionTaxFindUniqueOrThrowArgs>(args: SelectSubset<T, RetentionTaxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RetentionTax that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionTaxFindFirstArgs} args - Arguments to find a RetentionTax
     * @example
     * // Get one RetentionTax
     * const retentionTax = await prisma.retentionTax.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetentionTaxFindFirstArgs>(args?: SelectSubset<T, RetentionTaxFindFirstArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RetentionTax that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionTaxFindFirstOrThrowArgs} args - Arguments to find a RetentionTax
     * @example
     * // Get one RetentionTax
     * const retentionTax = await prisma.retentionTax.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetentionTaxFindFirstOrThrowArgs>(args?: SelectSubset<T, RetentionTaxFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RetentionTaxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionTaxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RetentionTaxes
     * const retentionTaxes = await prisma.retentionTax.findMany()
     * 
     * // Get first 10 RetentionTaxes
     * const retentionTaxes = await prisma.retentionTax.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retentionTaxWithIdOnly = await prisma.retentionTax.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RetentionTaxFindManyArgs>(args?: SelectSubset<T, RetentionTaxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RetentionTax.
     * @param {RetentionTaxCreateArgs} args - Arguments to create a RetentionTax.
     * @example
     * // Create one RetentionTax
     * const RetentionTax = await prisma.retentionTax.create({
     *   data: {
     *     // ... data to create a RetentionTax
     *   }
     * })
     * 
     */
    create<T extends RetentionTaxCreateArgs>(args: SelectSubset<T, RetentionTaxCreateArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RetentionTaxes.
     * @param {RetentionTaxCreateManyArgs} args - Arguments to create many RetentionTaxes.
     * @example
     * // Create many RetentionTaxes
     * const retentionTax = await prisma.retentionTax.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetentionTaxCreateManyArgs>(args?: SelectSubset<T, RetentionTaxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RetentionTaxes and returns the data saved in the database.
     * @param {RetentionTaxCreateManyAndReturnArgs} args - Arguments to create many RetentionTaxes.
     * @example
     * // Create many RetentionTaxes
     * const retentionTax = await prisma.retentionTax.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RetentionTaxes and only return the `id`
     * const retentionTaxWithIdOnly = await prisma.retentionTax.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetentionTaxCreateManyAndReturnArgs>(args?: SelectSubset<T, RetentionTaxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RetentionTax.
     * @param {RetentionTaxDeleteArgs} args - Arguments to delete one RetentionTax.
     * @example
     * // Delete one RetentionTax
     * const RetentionTax = await prisma.retentionTax.delete({
     *   where: {
     *     // ... filter to delete one RetentionTax
     *   }
     * })
     * 
     */
    delete<T extends RetentionTaxDeleteArgs>(args: SelectSubset<T, RetentionTaxDeleteArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RetentionTax.
     * @param {RetentionTaxUpdateArgs} args - Arguments to update one RetentionTax.
     * @example
     * // Update one RetentionTax
     * const retentionTax = await prisma.retentionTax.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetentionTaxUpdateArgs>(args: SelectSubset<T, RetentionTaxUpdateArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RetentionTaxes.
     * @param {RetentionTaxDeleteManyArgs} args - Arguments to filter RetentionTaxes to delete.
     * @example
     * // Delete a few RetentionTaxes
     * const { count } = await prisma.retentionTax.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetentionTaxDeleteManyArgs>(args?: SelectSubset<T, RetentionTaxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RetentionTaxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionTaxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RetentionTaxes
     * const retentionTax = await prisma.retentionTax.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetentionTaxUpdateManyArgs>(args: SelectSubset<T, RetentionTaxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RetentionTax.
     * @param {RetentionTaxUpsertArgs} args - Arguments to update or create a RetentionTax.
     * @example
     * // Update or create a RetentionTax
     * const retentionTax = await prisma.retentionTax.upsert({
     *   create: {
     *     // ... data to create a RetentionTax
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RetentionTax we want to update
     *   }
     * })
     */
    upsert<T extends RetentionTaxUpsertArgs>(args: SelectSubset<T, RetentionTaxUpsertArgs<ExtArgs>>): Prisma__RetentionTaxClient<$Result.GetResult<Prisma.$RetentionTaxPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RetentionTaxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionTaxCountArgs} args - Arguments to filter RetentionTaxes to count.
     * @example
     * // Count the number of RetentionTaxes
     * const count = await prisma.retentionTax.count({
     *   where: {
     *     // ... the filter for the RetentionTaxes we want to count
     *   }
     * })
    **/
    count<T extends RetentionTaxCountArgs>(
      args?: Subset<T, RetentionTaxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetentionTaxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RetentionTax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionTaxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetentionTaxAggregateArgs>(args: Subset<T, RetentionTaxAggregateArgs>): Prisma.PrismaPromise<GetRetentionTaxAggregateType<T>>

    /**
     * Group by RetentionTax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionTaxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetentionTaxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetentionTaxGroupByArgs['orderBy'] }
        : { orderBy?: RetentionTaxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetentionTaxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetentionTaxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RetentionTax model
   */
  readonly fields: RetentionTaxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RetentionTax.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetentionTaxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesOrExpenses<T extends RetentionTax$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, RetentionTax$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RetentionTax model
   */ 
  interface RetentionTaxFieldRefs {
    readonly id: FieldRef<"RetentionTax", 'Int'>
    readonly name: FieldRef<"RetentionTax", 'String'>
    readonly rate: FieldRef<"RetentionTax", 'Decimal'>
    readonly createdAt: FieldRef<"RetentionTax", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RetentionTax findUnique
   */
  export type RetentionTaxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * Filter, which RetentionTax to fetch.
     */
    where: RetentionTaxWhereUniqueInput
  }

  /**
   * RetentionTax findUniqueOrThrow
   */
  export type RetentionTaxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * Filter, which RetentionTax to fetch.
     */
    where: RetentionTaxWhereUniqueInput
  }

  /**
   * RetentionTax findFirst
   */
  export type RetentionTaxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * Filter, which RetentionTax to fetch.
     */
    where?: RetentionTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionTaxes to fetch.
     */
    orderBy?: RetentionTaxOrderByWithRelationInput | RetentionTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetentionTaxes.
     */
    cursor?: RetentionTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetentionTaxes.
     */
    distinct?: RetentionTaxScalarFieldEnum | RetentionTaxScalarFieldEnum[]
  }

  /**
   * RetentionTax findFirstOrThrow
   */
  export type RetentionTaxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * Filter, which RetentionTax to fetch.
     */
    where?: RetentionTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionTaxes to fetch.
     */
    orderBy?: RetentionTaxOrderByWithRelationInput | RetentionTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetentionTaxes.
     */
    cursor?: RetentionTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetentionTaxes.
     */
    distinct?: RetentionTaxScalarFieldEnum | RetentionTaxScalarFieldEnum[]
  }

  /**
   * RetentionTax findMany
   */
  export type RetentionTaxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * Filter, which RetentionTaxes to fetch.
     */
    where?: RetentionTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionTaxes to fetch.
     */
    orderBy?: RetentionTaxOrderByWithRelationInput | RetentionTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RetentionTaxes.
     */
    cursor?: RetentionTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionTaxes.
     */
    skip?: number
    distinct?: RetentionTaxScalarFieldEnum | RetentionTaxScalarFieldEnum[]
  }

  /**
   * RetentionTax create
   */
  export type RetentionTaxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * The data needed to create a RetentionTax.
     */
    data: XOR<RetentionTaxCreateInput, RetentionTaxUncheckedCreateInput>
  }

  /**
   * RetentionTax createMany
   */
  export type RetentionTaxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RetentionTaxes.
     */
    data: RetentionTaxCreateManyInput | RetentionTaxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetentionTax createManyAndReturn
   */
  export type RetentionTaxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RetentionTaxes.
     */
    data: RetentionTaxCreateManyInput | RetentionTaxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetentionTax update
   */
  export type RetentionTaxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * The data needed to update a RetentionTax.
     */
    data: XOR<RetentionTaxUpdateInput, RetentionTaxUncheckedUpdateInput>
    /**
     * Choose, which RetentionTax to update.
     */
    where: RetentionTaxWhereUniqueInput
  }

  /**
   * RetentionTax updateMany
   */
  export type RetentionTaxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RetentionTaxes.
     */
    data: XOR<RetentionTaxUpdateManyMutationInput, RetentionTaxUncheckedUpdateManyInput>
    /**
     * Filter which RetentionTaxes to update
     */
    where?: RetentionTaxWhereInput
  }

  /**
   * RetentionTax upsert
   */
  export type RetentionTaxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * The filter to search for the RetentionTax to update in case it exists.
     */
    where: RetentionTaxWhereUniqueInput
    /**
     * In case the RetentionTax found by the `where` argument doesn't exist, create a new RetentionTax with this data.
     */
    create: XOR<RetentionTaxCreateInput, RetentionTaxUncheckedCreateInput>
    /**
     * In case the RetentionTax was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetentionTaxUpdateInput, RetentionTaxUncheckedUpdateInput>
  }

  /**
   * RetentionTax delete
   */
  export type RetentionTaxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
    /**
     * Filter which RetentionTax to delete.
     */
    where: RetentionTaxWhereUniqueInput
  }

  /**
   * RetentionTax deleteMany
   */
  export type RetentionTaxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetentionTaxes to delete
     */
    where?: RetentionTaxWhereInput
  }

  /**
   * RetentionTax.PurchasesOrExpenses
   */
  export type RetentionTax$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * RetentionTax without action
   */
  export type RetentionTaxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionTax
     */
    select?: RetentionTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionTaxInclude<ExtArgs> | null
  }


  /**
   * Model RetentionIsr
   */

  export type AggregateRetentionIsr = {
    _count: RetentionIsrCountAggregateOutputType | null
    _avg: RetentionIsrAvgAggregateOutputType | null
    _sum: RetentionIsrSumAggregateOutputType | null
    _min: RetentionIsrMinAggregateOutputType | null
    _max: RetentionIsrMaxAggregateOutputType | null
  }

  export type RetentionIsrAvgAggregateOutputType = {
    rate: Decimal | null
  }

  export type RetentionIsrSumAggregateOutputType = {
    rate: Decimal | null
  }

  export type RetentionIsrMinAggregateOutputType = {
    id: string | null
    name: string | null
    rate: Decimal | null
    createdAt: Date | null
  }

  export type RetentionIsrMaxAggregateOutputType = {
    id: string | null
    name: string | null
    rate: Decimal | null
    createdAt: Date | null
  }

  export type RetentionIsrCountAggregateOutputType = {
    id: number
    name: number
    rate: number
    createdAt: number
    _all: number
  }


  export type RetentionIsrAvgAggregateInputType = {
    rate?: true
  }

  export type RetentionIsrSumAggregateInputType = {
    rate?: true
  }

  export type RetentionIsrMinAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    createdAt?: true
  }

  export type RetentionIsrMaxAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    createdAt?: true
  }

  export type RetentionIsrCountAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    createdAt?: true
    _all?: true
  }

  export type RetentionIsrAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetentionIsr to aggregate.
     */
    where?: RetentionIsrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionIsrs to fetch.
     */
    orderBy?: RetentionIsrOrderByWithRelationInput | RetentionIsrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetentionIsrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionIsrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionIsrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RetentionIsrs
    **/
    _count?: true | RetentionIsrCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RetentionIsrAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RetentionIsrSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetentionIsrMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetentionIsrMaxAggregateInputType
  }

  export type GetRetentionIsrAggregateType<T extends RetentionIsrAggregateArgs> = {
        [P in keyof T & keyof AggregateRetentionIsr]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetentionIsr[P]>
      : GetScalarType<T[P], AggregateRetentionIsr[P]>
  }




  export type RetentionIsrGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetentionIsrWhereInput
    orderBy?: RetentionIsrOrderByWithAggregationInput | RetentionIsrOrderByWithAggregationInput[]
    by: RetentionIsrScalarFieldEnum[] | RetentionIsrScalarFieldEnum
    having?: RetentionIsrScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetentionIsrCountAggregateInputType | true
    _avg?: RetentionIsrAvgAggregateInputType
    _sum?: RetentionIsrSumAggregateInputType
    _min?: RetentionIsrMinAggregateInputType
    _max?: RetentionIsrMaxAggregateInputType
  }

  export type RetentionIsrGroupByOutputType = {
    id: string
    name: string
    rate: Decimal
    createdAt: Date
    _count: RetentionIsrCountAggregateOutputType | null
    _avg: RetentionIsrAvgAggregateOutputType | null
    _sum: RetentionIsrSumAggregateOutputType | null
    _min: RetentionIsrMinAggregateOutputType | null
    _max: RetentionIsrMaxAggregateOutputType | null
  }

  type GetRetentionIsrGroupByPayload<T extends RetentionIsrGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetentionIsrGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetentionIsrGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetentionIsrGroupByOutputType[P]>
            : GetScalarType<T[P], RetentionIsrGroupByOutputType[P]>
        }
      >
    >


  export type RetentionIsrSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    createdAt?: boolean
    PurchasesOrExpenses?: boolean | RetentionIsr$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | RetentionIsrCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retentionIsr"]>

  export type RetentionIsrSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["retentionIsr"]>

  export type RetentionIsrSelectScalar = {
    id?: boolean
    name?: boolean
    rate?: boolean
    createdAt?: boolean
  }

  export type RetentionIsrInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | RetentionIsr$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | RetentionIsrCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RetentionIsrIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RetentionIsrPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RetentionIsr"
    objects: {
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      rate: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["retentionIsr"]>
    composites: {}
  }

  type RetentionIsrGetPayload<S extends boolean | null | undefined | RetentionIsrDefaultArgs> = $Result.GetResult<Prisma.$RetentionIsrPayload, S>

  type RetentionIsrCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RetentionIsrFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RetentionIsrCountAggregateInputType | true
    }

  export interface RetentionIsrDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RetentionIsr'], meta: { name: 'RetentionIsr' } }
    /**
     * Find zero or one RetentionIsr that matches the filter.
     * @param {RetentionIsrFindUniqueArgs} args - Arguments to find a RetentionIsr
     * @example
     * // Get one RetentionIsr
     * const retentionIsr = await prisma.retentionIsr.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetentionIsrFindUniqueArgs>(args: SelectSubset<T, RetentionIsrFindUniqueArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RetentionIsr that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RetentionIsrFindUniqueOrThrowArgs} args - Arguments to find a RetentionIsr
     * @example
     * // Get one RetentionIsr
     * const retentionIsr = await prisma.retentionIsr.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetentionIsrFindUniqueOrThrowArgs>(args: SelectSubset<T, RetentionIsrFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RetentionIsr that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionIsrFindFirstArgs} args - Arguments to find a RetentionIsr
     * @example
     * // Get one RetentionIsr
     * const retentionIsr = await prisma.retentionIsr.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetentionIsrFindFirstArgs>(args?: SelectSubset<T, RetentionIsrFindFirstArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RetentionIsr that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionIsrFindFirstOrThrowArgs} args - Arguments to find a RetentionIsr
     * @example
     * // Get one RetentionIsr
     * const retentionIsr = await prisma.retentionIsr.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetentionIsrFindFirstOrThrowArgs>(args?: SelectSubset<T, RetentionIsrFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RetentionIsrs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionIsrFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RetentionIsrs
     * const retentionIsrs = await prisma.retentionIsr.findMany()
     * 
     * // Get first 10 RetentionIsrs
     * const retentionIsrs = await prisma.retentionIsr.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retentionIsrWithIdOnly = await prisma.retentionIsr.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RetentionIsrFindManyArgs>(args?: SelectSubset<T, RetentionIsrFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RetentionIsr.
     * @param {RetentionIsrCreateArgs} args - Arguments to create a RetentionIsr.
     * @example
     * // Create one RetentionIsr
     * const RetentionIsr = await prisma.retentionIsr.create({
     *   data: {
     *     // ... data to create a RetentionIsr
     *   }
     * })
     * 
     */
    create<T extends RetentionIsrCreateArgs>(args: SelectSubset<T, RetentionIsrCreateArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RetentionIsrs.
     * @param {RetentionIsrCreateManyArgs} args - Arguments to create many RetentionIsrs.
     * @example
     * // Create many RetentionIsrs
     * const retentionIsr = await prisma.retentionIsr.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetentionIsrCreateManyArgs>(args?: SelectSubset<T, RetentionIsrCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RetentionIsrs and returns the data saved in the database.
     * @param {RetentionIsrCreateManyAndReturnArgs} args - Arguments to create many RetentionIsrs.
     * @example
     * // Create many RetentionIsrs
     * const retentionIsr = await prisma.retentionIsr.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RetentionIsrs and only return the `id`
     * const retentionIsrWithIdOnly = await prisma.retentionIsr.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetentionIsrCreateManyAndReturnArgs>(args?: SelectSubset<T, RetentionIsrCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RetentionIsr.
     * @param {RetentionIsrDeleteArgs} args - Arguments to delete one RetentionIsr.
     * @example
     * // Delete one RetentionIsr
     * const RetentionIsr = await prisma.retentionIsr.delete({
     *   where: {
     *     // ... filter to delete one RetentionIsr
     *   }
     * })
     * 
     */
    delete<T extends RetentionIsrDeleteArgs>(args: SelectSubset<T, RetentionIsrDeleteArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RetentionIsr.
     * @param {RetentionIsrUpdateArgs} args - Arguments to update one RetentionIsr.
     * @example
     * // Update one RetentionIsr
     * const retentionIsr = await prisma.retentionIsr.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetentionIsrUpdateArgs>(args: SelectSubset<T, RetentionIsrUpdateArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RetentionIsrs.
     * @param {RetentionIsrDeleteManyArgs} args - Arguments to filter RetentionIsrs to delete.
     * @example
     * // Delete a few RetentionIsrs
     * const { count } = await prisma.retentionIsr.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetentionIsrDeleteManyArgs>(args?: SelectSubset<T, RetentionIsrDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RetentionIsrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionIsrUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RetentionIsrs
     * const retentionIsr = await prisma.retentionIsr.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetentionIsrUpdateManyArgs>(args: SelectSubset<T, RetentionIsrUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RetentionIsr.
     * @param {RetentionIsrUpsertArgs} args - Arguments to update or create a RetentionIsr.
     * @example
     * // Update or create a RetentionIsr
     * const retentionIsr = await prisma.retentionIsr.upsert({
     *   create: {
     *     // ... data to create a RetentionIsr
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RetentionIsr we want to update
     *   }
     * })
     */
    upsert<T extends RetentionIsrUpsertArgs>(args: SelectSubset<T, RetentionIsrUpsertArgs<ExtArgs>>): Prisma__RetentionIsrClient<$Result.GetResult<Prisma.$RetentionIsrPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RetentionIsrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionIsrCountArgs} args - Arguments to filter RetentionIsrs to count.
     * @example
     * // Count the number of RetentionIsrs
     * const count = await prisma.retentionIsr.count({
     *   where: {
     *     // ... the filter for the RetentionIsrs we want to count
     *   }
     * })
    **/
    count<T extends RetentionIsrCountArgs>(
      args?: Subset<T, RetentionIsrCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetentionIsrCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RetentionIsr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionIsrAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetentionIsrAggregateArgs>(args: Subset<T, RetentionIsrAggregateArgs>): Prisma.PrismaPromise<GetRetentionIsrAggregateType<T>>

    /**
     * Group by RetentionIsr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetentionIsrGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetentionIsrGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetentionIsrGroupByArgs['orderBy'] }
        : { orderBy?: RetentionIsrGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetentionIsrGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetentionIsrGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RetentionIsr model
   */
  readonly fields: RetentionIsrFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RetentionIsr.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetentionIsrClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesOrExpenses<T extends RetentionIsr$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, RetentionIsr$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RetentionIsr model
   */ 
  interface RetentionIsrFieldRefs {
    readonly id: FieldRef<"RetentionIsr", 'String'>
    readonly name: FieldRef<"RetentionIsr", 'String'>
    readonly rate: FieldRef<"RetentionIsr", 'Decimal'>
    readonly createdAt: FieldRef<"RetentionIsr", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RetentionIsr findUnique
   */
  export type RetentionIsrFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * Filter, which RetentionIsr to fetch.
     */
    where: RetentionIsrWhereUniqueInput
  }

  /**
   * RetentionIsr findUniqueOrThrow
   */
  export type RetentionIsrFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * Filter, which RetentionIsr to fetch.
     */
    where: RetentionIsrWhereUniqueInput
  }

  /**
   * RetentionIsr findFirst
   */
  export type RetentionIsrFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * Filter, which RetentionIsr to fetch.
     */
    where?: RetentionIsrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionIsrs to fetch.
     */
    orderBy?: RetentionIsrOrderByWithRelationInput | RetentionIsrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetentionIsrs.
     */
    cursor?: RetentionIsrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionIsrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionIsrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetentionIsrs.
     */
    distinct?: RetentionIsrScalarFieldEnum | RetentionIsrScalarFieldEnum[]
  }

  /**
   * RetentionIsr findFirstOrThrow
   */
  export type RetentionIsrFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * Filter, which RetentionIsr to fetch.
     */
    where?: RetentionIsrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionIsrs to fetch.
     */
    orderBy?: RetentionIsrOrderByWithRelationInput | RetentionIsrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetentionIsrs.
     */
    cursor?: RetentionIsrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionIsrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionIsrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetentionIsrs.
     */
    distinct?: RetentionIsrScalarFieldEnum | RetentionIsrScalarFieldEnum[]
  }

  /**
   * RetentionIsr findMany
   */
  export type RetentionIsrFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * Filter, which RetentionIsrs to fetch.
     */
    where?: RetentionIsrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetentionIsrs to fetch.
     */
    orderBy?: RetentionIsrOrderByWithRelationInput | RetentionIsrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RetentionIsrs.
     */
    cursor?: RetentionIsrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetentionIsrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetentionIsrs.
     */
    skip?: number
    distinct?: RetentionIsrScalarFieldEnum | RetentionIsrScalarFieldEnum[]
  }

  /**
   * RetentionIsr create
   */
  export type RetentionIsrCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * The data needed to create a RetentionIsr.
     */
    data: XOR<RetentionIsrCreateInput, RetentionIsrUncheckedCreateInput>
  }

  /**
   * RetentionIsr createMany
   */
  export type RetentionIsrCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RetentionIsrs.
     */
    data: RetentionIsrCreateManyInput | RetentionIsrCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetentionIsr createManyAndReturn
   */
  export type RetentionIsrCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RetentionIsrs.
     */
    data: RetentionIsrCreateManyInput | RetentionIsrCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetentionIsr update
   */
  export type RetentionIsrUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * The data needed to update a RetentionIsr.
     */
    data: XOR<RetentionIsrUpdateInput, RetentionIsrUncheckedUpdateInput>
    /**
     * Choose, which RetentionIsr to update.
     */
    where: RetentionIsrWhereUniqueInput
  }

  /**
   * RetentionIsr updateMany
   */
  export type RetentionIsrUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RetentionIsrs.
     */
    data: XOR<RetentionIsrUpdateManyMutationInput, RetentionIsrUncheckedUpdateManyInput>
    /**
     * Filter which RetentionIsrs to update
     */
    where?: RetentionIsrWhereInput
  }

  /**
   * RetentionIsr upsert
   */
  export type RetentionIsrUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * The filter to search for the RetentionIsr to update in case it exists.
     */
    where: RetentionIsrWhereUniqueInput
    /**
     * In case the RetentionIsr found by the `where` argument doesn't exist, create a new RetentionIsr with this data.
     */
    create: XOR<RetentionIsrCreateInput, RetentionIsrUncheckedCreateInput>
    /**
     * In case the RetentionIsr was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetentionIsrUpdateInput, RetentionIsrUncheckedUpdateInput>
  }

  /**
   * RetentionIsr delete
   */
  export type RetentionIsrDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
    /**
     * Filter which RetentionIsr to delete.
     */
    where: RetentionIsrWhereUniqueInput
  }

  /**
   * RetentionIsr deleteMany
   */
  export type RetentionIsrDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetentionIsrs to delete
     */
    where?: RetentionIsrWhereInput
  }

  /**
   * RetentionIsr.PurchasesOrExpenses
   */
  export type RetentionIsr$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * RetentionIsr without action
   */
  export type RetentionIsrDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetentionIsr
     */
    select?: RetentionIsrSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetentionIsrInclude<ExtArgs> | null
  }


  /**
   * Model CostTaxStatus
   */

  export type AggregateCostTaxStatus = {
    _count: CostTaxStatusCountAggregateOutputType | null
    _avg: CostTaxStatusAvgAggregateOutputType | null
    _sum: CostTaxStatusSumAggregateOutputType | null
    _min: CostTaxStatusMinAggregateOutputType | null
    _max: CostTaxStatusMaxAggregateOutputType | null
  }

  export type CostTaxStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type CostTaxStatusSumAggregateOutputType = {
    id: number | null
  }

  export type CostTaxStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type CostTaxStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type CostTaxStatusCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type CostTaxStatusAvgAggregateInputType = {
    id?: true
  }

  export type CostTaxStatusSumAggregateInputType = {
    id?: true
  }

  export type CostTaxStatusMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CostTaxStatusMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CostTaxStatusCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type CostTaxStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostTaxStatus to aggregate.
     */
    where?: CostTaxStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTaxStatuses to fetch.
     */
    orderBy?: CostTaxStatusOrderByWithRelationInput | CostTaxStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostTaxStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTaxStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTaxStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostTaxStatuses
    **/
    _count?: true | CostTaxStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostTaxStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostTaxStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostTaxStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostTaxStatusMaxAggregateInputType
  }

  export type GetCostTaxStatusAggregateType<T extends CostTaxStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateCostTaxStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostTaxStatus[P]>
      : GetScalarType<T[P], AggregateCostTaxStatus[P]>
  }




  export type CostTaxStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostTaxStatusWhereInput
    orderBy?: CostTaxStatusOrderByWithAggregationInput | CostTaxStatusOrderByWithAggregationInput[]
    by: CostTaxStatusScalarFieldEnum[] | CostTaxStatusScalarFieldEnum
    having?: CostTaxStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostTaxStatusCountAggregateInputType | true
    _avg?: CostTaxStatusAvgAggregateInputType
    _sum?: CostTaxStatusSumAggregateInputType
    _min?: CostTaxStatusMinAggregateInputType
    _max?: CostTaxStatusMaxAggregateInputType
  }

  export type CostTaxStatusGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: CostTaxStatusCountAggregateOutputType | null
    _avg: CostTaxStatusAvgAggregateOutputType | null
    _sum: CostTaxStatusSumAggregateOutputType | null
    _min: CostTaxStatusMinAggregateOutputType | null
    _max: CostTaxStatusMaxAggregateOutputType | null
  }

  type GetCostTaxStatusGroupByPayload<T extends CostTaxStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostTaxStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostTaxStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostTaxStatusGroupByOutputType[P]>
            : GetScalarType<T[P], CostTaxStatusGroupByOutputType[P]>
        }
      >
    >


  export type CostTaxStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    PurchasesOrExpenses?: boolean | CostTaxStatus$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | CostTaxStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costTaxStatus"]>

  export type CostTaxStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["costTaxStatus"]>

  export type CostTaxStatusSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type CostTaxStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | CostTaxStatus$PurchasesOrExpensesArgs<ExtArgs>
    _count?: boolean | CostTaxStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostTaxStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CostTaxStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostTaxStatus"
    objects: {
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["costTaxStatus"]>
    composites: {}
  }

  type CostTaxStatusGetPayload<S extends boolean | null | undefined | CostTaxStatusDefaultArgs> = $Result.GetResult<Prisma.$CostTaxStatusPayload, S>

  type CostTaxStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostTaxStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostTaxStatusCountAggregateInputType | true
    }

  export interface CostTaxStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostTaxStatus'], meta: { name: 'CostTaxStatus' } }
    /**
     * Find zero or one CostTaxStatus that matches the filter.
     * @param {CostTaxStatusFindUniqueArgs} args - Arguments to find a CostTaxStatus
     * @example
     * // Get one CostTaxStatus
     * const costTaxStatus = await prisma.costTaxStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostTaxStatusFindUniqueArgs>(args: SelectSubset<T, CostTaxStatusFindUniqueArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostTaxStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostTaxStatusFindUniqueOrThrowArgs} args - Arguments to find a CostTaxStatus
     * @example
     * // Get one CostTaxStatus
     * const costTaxStatus = await prisma.costTaxStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostTaxStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, CostTaxStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostTaxStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTaxStatusFindFirstArgs} args - Arguments to find a CostTaxStatus
     * @example
     * // Get one CostTaxStatus
     * const costTaxStatus = await prisma.costTaxStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostTaxStatusFindFirstArgs>(args?: SelectSubset<T, CostTaxStatusFindFirstArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostTaxStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTaxStatusFindFirstOrThrowArgs} args - Arguments to find a CostTaxStatus
     * @example
     * // Get one CostTaxStatus
     * const costTaxStatus = await prisma.costTaxStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostTaxStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, CostTaxStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostTaxStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTaxStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostTaxStatuses
     * const costTaxStatuses = await prisma.costTaxStatus.findMany()
     * 
     * // Get first 10 CostTaxStatuses
     * const costTaxStatuses = await prisma.costTaxStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costTaxStatusWithIdOnly = await prisma.costTaxStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostTaxStatusFindManyArgs>(args?: SelectSubset<T, CostTaxStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostTaxStatus.
     * @param {CostTaxStatusCreateArgs} args - Arguments to create a CostTaxStatus.
     * @example
     * // Create one CostTaxStatus
     * const CostTaxStatus = await prisma.costTaxStatus.create({
     *   data: {
     *     // ... data to create a CostTaxStatus
     *   }
     * })
     * 
     */
    create<T extends CostTaxStatusCreateArgs>(args: SelectSubset<T, CostTaxStatusCreateArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostTaxStatuses.
     * @param {CostTaxStatusCreateManyArgs} args - Arguments to create many CostTaxStatuses.
     * @example
     * // Create many CostTaxStatuses
     * const costTaxStatus = await prisma.costTaxStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostTaxStatusCreateManyArgs>(args?: SelectSubset<T, CostTaxStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostTaxStatuses and returns the data saved in the database.
     * @param {CostTaxStatusCreateManyAndReturnArgs} args - Arguments to create many CostTaxStatuses.
     * @example
     * // Create many CostTaxStatuses
     * const costTaxStatus = await prisma.costTaxStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostTaxStatuses and only return the `id`
     * const costTaxStatusWithIdOnly = await prisma.costTaxStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostTaxStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, CostTaxStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostTaxStatus.
     * @param {CostTaxStatusDeleteArgs} args - Arguments to delete one CostTaxStatus.
     * @example
     * // Delete one CostTaxStatus
     * const CostTaxStatus = await prisma.costTaxStatus.delete({
     *   where: {
     *     // ... filter to delete one CostTaxStatus
     *   }
     * })
     * 
     */
    delete<T extends CostTaxStatusDeleteArgs>(args: SelectSubset<T, CostTaxStatusDeleteArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostTaxStatus.
     * @param {CostTaxStatusUpdateArgs} args - Arguments to update one CostTaxStatus.
     * @example
     * // Update one CostTaxStatus
     * const costTaxStatus = await prisma.costTaxStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostTaxStatusUpdateArgs>(args: SelectSubset<T, CostTaxStatusUpdateArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostTaxStatuses.
     * @param {CostTaxStatusDeleteManyArgs} args - Arguments to filter CostTaxStatuses to delete.
     * @example
     * // Delete a few CostTaxStatuses
     * const { count } = await prisma.costTaxStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostTaxStatusDeleteManyArgs>(args?: SelectSubset<T, CostTaxStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostTaxStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTaxStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostTaxStatuses
     * const costTaxStatus = await prisma.costTaxStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostTaxStatusUpdateManyArgs>(args: SelectSubset<T, CostTaxStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostTaxStatus.
     * @param {CostTaxStatusUpsertArgs} args - Arguments to update or create a CostTaxStatus.
     * @example
     * // Update or create a CostTaxStatus
     * const costTaxStatus = await prisma.costTaxStatus.upsert({
     *   create: {
     *     // ... data to create a CostTaxStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostTaxStatus we want to update
     *   }
     * })
     */
    upsert<T extends CostTaxStatusUpsertArgs>(args: SelectSubset<T, CostTaxStatusUpsertArgs<ExtArgs>>): Prisma__CostTaxStatusClient<$Result.GetResult<Prisma.$CostTaxStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostTaxStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTaxStatusCountArgs} args - Arguments to filter CostTaxStatuses to count.
     * @example
     * // Count the number of CostTaxStatuses
     * const count = await prisma.costTaxStatus.count({
     *   where: {
     *     // ... the filter for the CostTaxStatuses we want to count
     *   }
     * })
    **/
    count<T extends CostTaxStatusCountArgs>(
      args?: Subset<T, CostTaxStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostTaxStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostTaxStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTaxStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostTaxStatusAggregateArgs>(args: Subset<T, CostTaxStatusAggregateArgs>): Prisma.PrismaPromise<GetCostTaxStatusAggregateType<T>>

    /**
     * Group by CostTaxStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTaxStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostTaxStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostTaxStatusGroupByArgs['orderBy'] }
        : { orderBy?: CostTaxStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostTaxStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostTaxStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostTaxStatus model
   */
  readonly fields: CostTaxStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostTaxStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostTaxStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesOrExpenses<T extends CostTaxStatus$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, CostTaxStatus$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostTaxStatus model
   */ 
  interface CostTaxStatusFieldRefs {
    readonly id: FieldRef<"CostTaxStatus", 'Int'>
    readonly name: FieldRef<"CostTaxStatus", 'String'>
    readonly createdAt: FieldRef<"CostTaxStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostTaxStatus findUnique
   */
  export type CostTaxStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * Filter, which CostTaxStatus to fetch.
     */
    where: CostTaxStatusWhereUniqueInput
  }

  /**
   * CostTaxStatus findUniqueOrThrow
   */
  export type CostTaxStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * Filter, which CostTaxStatus to fetch.
     */
    where: CostTaxStatusWhereUniqueInput
  }

  /**
   * CostTaxStatus findFirst
   */
  export type CostTaxStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * Filter, which CostTaxStatus to fetch.
     */
    where?: CostTaxStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTaxStatuses to fetch.
     */
    orderBy?: CostTaxStatusOrderByWithRelationInput | CostTaxStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostTaxStatuses.
     */
    cursor?: CostTaxStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTaxStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTaxStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostTaxStatuses.
     */
    distinct?: CostTaxStatusScalarFieldEnum | CostTaxStatusScalarFieldEnum[]
  }

  /**
   * CostTaxStatus findFirstOrThrow
   */
  export type CostTaxStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * Filter, which CostTaxStatus to fetch.
     */
    where?: CostTaxStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTaxStatuses to fetch.
     */
    orderBy?: CostTaxStatusOrderByWithRelationInput | CostTaxStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostTaxStatuses.
     */
    cursor?: CostTaxStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTaxStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTaxStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostTaxStatuses.
     */
    distinct?: CostTaxStatusScalarFieldEnum | CostTaxStatusScalarFieldEnum[]
  }

  /**
   * CostTaxStatus findMany
   */
  export type CostTaxStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * Filter, which CostTaxStatuses to fetch.
     */
    where?: CostTaxStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTaxStatuses to fetch.
     */
    orderBy?: CostTaxStatusOrderByWithRelationInput | CostTaxStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostTaxStatuses.
     */
    cursor?: CostTaxStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTaxStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTaxStatuses.
     */
    skip?: number
    distinct?: CostTaxStatusScalarFieldEnum | CostTaxStatusScalarFieldEnum[]
  }

  /**
   * CostTaxStatus create
   */
  export type CostTaxStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a CostTaxStatus.
     */
    data: XOR<CostTaxStatusCreateInput, CostTaxStatusUncheckedCreateInput>
  }

  /**
   * CostTaxStatus createMany
   */
  export type CostTaxStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostTaxStatuses.
     */
    data: CostTaxStatusCreateManyInput | CostTaxStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostTaxStatus createManyAndReturn
   */
  export type CostTaxStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostTaxStatuses.
     */
    data: CostTaxStatusCreateManyInput | CostTaxStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostTaxStatus update
   */
  export type CostTaxStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a CostTaxStatus.
     */
    data: XOR<CostTaxStatusUpdateInput, CostTaxStatusUncheckedUpdateInput>
    /**
     * Choose, which CostTaxStatus to update.
     */
    where: CostTaxStatusWhereUniqueInput
  }

  /**
   * CostTaxStatus updateMany
   */
  export type CostTaxStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostTaxStatuses.
     */
    data: XOR<CostTaxStatusUpdateManyMutationInput, CostTaxStatusUncheckedUpdateManyInput>
    /**
     * Filter which CostTaxStatuses to update
     */
    where?: CostTaxStatusWhereInput
  }

  /**
   * CostTaxStatus upsert
   */
  export type CostTaxStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the CostTaxStatus to update in case it exists.
     */
    where: CostTaxStatusWhereUniqueInput
    /**
     * In case the CostTaxStatus found by the `where` argument doesn't exist, create a new CostTaxStatus with this data.
     */
    create: XOR<CostTaxStatusCreateInput, CostTaxStatusUncheckedCreateInput>
    /**
     * In case the CostTaxStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostTaxStatusUpdateInput, CostTaxStatusUncheckedUpdateInput>
  }

  /**
   * CostTaxStatus delete
   */
  export type CostTaxStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
    /**
     * Filter which CostTaxStatus to delete.
     */
    where: CostTaxStatusWhereUniqueInput
  }

  /**
   * CostTaxStatus deleteMany
   */
  export type CostTaxStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostTaxStatuses to delete
     */
    where?: CostTaxStatusWhereInput
  }

  /**
   * CostTaxStatus.PurchasesOrExpenses
   */
  export type CostTaxStatus$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * CostTaxStatus without action
   */
  export type CostTaxStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTaxStatus
     */
    select?: CostTaxStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTaxStatusInclude<ExtArgs> | null
  }


  /**
   * Model TaxPayer
   */

  export type AggregateTaxPayer = {
    _count: TaxPayerCountAggregateOutputType | null
    _min: TaxPayerMinAggregateOutputType | null
    _max: TaxPayerMaxAggregateOutputType | null
  }

  export type TaxPayerMinAggregateOutputType = {
    id: string | null
    name: string | null
    tradeName: string | null
    about: string | null
    col1: string | null
    col2: string | null
    col3: string | null
    col4: string | null
    createdAt: string | null
    state: string | null
    status: string | null
  }

  export type TaxPayerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tradeName: string | null
    about: string | null
    col1: string | null
    col2: string | null
    col3: string | null
    col4: string | null
    createdAt: string | null
    state: string | null
    status: string | null
  }

  export type TaxPayerCountAggregateOutputType = {
    id: number
    name: number
    tradeName: number
    about: number
    col1: number
    col2: number
    col3: number
    col4: number
    createdAt: number
    state: number
    status: number
    _all: number
  }


  export type TaxPayerMinAggregateInputType = {
    id?: true
    name?: true
    tradeName?: true
    about?: true
    col1?: true
    col2?: true
    col3?: true
    col4?: true
    createdAt?: true
    state?: true
    status?: true
  }

  export type TaxPayerMaxAggregateInputType = {
    id?: true
    name?: true
    tradeName?: true
    about?: true
    col1?: true
    col2?: true
    col3?: true
    col4?: true
    createdAt?: true
    state?: true
    status?: true
  }

  export type TaxPayerCountAggregateInputType = {
    id?: true
    name?: true
    tradeName?: true
    about?: true
    col1?: true
    col2?: true
    col3?: true
    col4?: true
    createdAt?: true
    state?: true
    status?: true
    _all?: true
  }

  export type TaxPayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPayer to aggregate.
     */
    where?: TaxPayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayers to fetch.
     */
    orderBy?: TaxPayerOrderByWithRelationInput | TaxPayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxPayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxPayers
    **/
    _count?: true | TaxPayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxPayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxPayerMaxAggregateInputType
  }

  export type GetTaxPayerAggregateType<T extends TaxPayerAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxPayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxPayer[P]>
      : GetScalarType<T[P], AggregateTaxPayer[P]>
  }




  export type TaxPayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxPayerWhereInput
    orderBy?: TaxPayerOrderByWithAggregationInput | TaxPayerOrderByWithAggregationInput[]
    by: TaxPayerScalarFieldEnum[] | TaxPayerScalarFieldEnum
    having?: TaxPayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxPayerCountAggregateInputType | true
    _min?: TaxPayerMinAggregateInputType
    _max?: TaxPayerMaxAggregateInputType
  }

  export type TaxPayerGroupByOutputType = {
    id: string
    name: string | null
    tradeName: string | null
    about: string | null
    col1: string | null
    col2: string | null
    col3: string | null
    col4: string | null
    createdAt: string | null
    state: string | null
    status: string | null
    _count: TaxPayerCountAggregateOutputType | null
    _min: TaxPayerMinAggregateOutputType | null
    _max: TaxPayerMaxAggregateOutputType | null
  }

  type GetTaxPayerGroupByPayload<T extends TaxPayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxPayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxPayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxPayerGroupByOutputType[P]>
            : GetScalarType<T[P], TaxPayerGroupByOutputType[P]>
        }
      >
    >


  export type TaxPayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tradeName?: boolean
    about?: boolean
    col1?: boolean
    col2?: boolean
    col3?: boolean
    col4?: boolean
    createdAt?: boolean
    state?: boolean
    status?: boolean
    PurchasesOrExpenses?: boolean | TaxPayer$PurchasesOrExpensesArgs<ExtArgs>
    Requests?: boolean | TaxPayer$RequestsArgs<ExtArgs>
    Users?: boolean | TaxPayer$UsersArgs<ExtArgs>
    _count?: boolean | TaxPayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxPayer"]>

  export type TaxPayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tradeName?: boolean
    about?: boolean
    col1?: boolean
    col2?: boolean
    col3?: boolean
    col4?: boolean
    createdAt?: boolean
    state?: boolean
    status?: boolean
  }, ExtArgs["result"]["taxPayer"]>

  export type TaxPayerSelectScalar = {
    id?: boolean
    name?: boolean
    tradeName?: boolean
    about?: boolean
    col1?: boolean
    col2?: boolean
    col3?: boolean
    col4?: boolean
    createdAt?: boolean
    state?: boolean
    status?: boolean
  }

  export type TaxPayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesOrExpenses?: boolean | TaxPayer$PurchasesOrExpensesArgs<ExtArgs>
    Requests?: boolean | TaxPayer$RequestsArgs<ExtArgs>
    Users?: boolean | TaxPayer$UsersArgs<ExtArgs>
    _count?: boolean | TaxPayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaxPayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaxPayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxPayer"
    objects: {
      PurchasesOrExpenses: Prisma.$PurchasesOrExpensesPayload<ExtArgs>[]
      Requests: Prisma.$RequestsPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      tradeName: string | null
      about: string | null
      col1: string | null
      col2: string | null
      col3: string | null
      col4: string | null
      createdAt: string | null
      state: string | null
      status: string | null
    }, ExtArgs["result"]["taxPayer"]>
    composites: {}
  }

  type TaxPayerGetPayload<S extends boolean | null | undefined | TaxPayerDefaultArgs> = $Result.GetResult<Prisma.$TaxPayerPayload, S>

  type TaxPayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaxPayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaxPayerCountAggregateInputType | true
    }

  export interface TaxPayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxPayer'], meta: { name: 'TaxPayer' } }
    /**
     * Find zero or one TaxPayer that matches the filter.
     * @param {TaxPayerFindUniqueArgs} args - Arguments to find a TaxPayer
     * @example
     * // Get one TaxPayer
     * const taxPayer = await prisma.taxPayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxPayerFindUniqueArgs>(args: SelectSubset<T, TaxPayerFindUniqueArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaxPayer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaxPayerFindUniqueOrThrowArgs} args - Arguments to find a TaxPayer
     * @example
     * // Get one TaxPayer
     * const taxPayer = await prisma.taxPayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxPayerFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxPayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaxPayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerFindFirstArgs} args - Arguments to find a TaxPayer
     * @example
     * // Get one TaxPayer
     * const taxPayer = await prisma.taxPayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxPayerFindFirstArgs>(args?: SelectSubset<T, TaxPayerFindFirstArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaxPayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerFindFirstOrThrowArgs} args - Arguments to find a TaxPayer
     * @example
     * // Get one TaxPayer
     * const taxPayer = await prisma.taxPayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxPayerFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxPayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaxPayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxPayers
     * const taxPayers = await prisma.taxPayer.findMany()
     * 
     * // Get first 10 TaxPayers
     * const taxPayers = await prisma.taxPayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxPayerWithIdOnly = await prisma.taxPayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxPayerFindManyArgs>(args?: SelectSubset<T, TaxPayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaxPayer.
     * @param {TaxPayerCreateArgs} args - Arguments to create a TaxPayer.
     * @example
     * // Create one TaxPayer
     * const TaxPayer = await prisma.taxPayer.create({
     *   data: {
     *     // ... data to create a TaxPayer
     *   }
     * })
     * 
     */
    create<T extends TaxPayerCreateArgs>(args: SelectSubset<T, TaxPayerCreateArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaxPayers.
     * @param {TaxPayerCreateManyArgs} args - Arguments to create many TaxPayers.
     * @example
     * // Create many TaxPayers
     * const taxPayer = await prisma.taxPayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxPayerCreateManyArgs>(args?: SelectSubset<T, TaxPayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxPayers and returns the data saved in the database.
     * @param {TaxPayerCreateManyAndReturnArgs} args - Arguments to create many TaxPayers.
     * @example
     * // Create many TaxPayers
     * const taxPayer = await prisma.taxPayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxPayers and only return the `id`
     * const taxPayerWithIdOnly = await prisma.taxPayer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxPayerCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxPayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaxPayer.
     * @param {TaxPayerDeleteArgs} args - Arguments to delete one TaxPayer.
     * @example
     * // Delete one TaxPayer
     * const TaxPayer = await prisma.taxPayer.delete({
     *   where: {
     *     // ... filter to delete one TaxPayer
     *   }
     * })
     * 
     */
    delete<T extends TaxPayerDeleteArgs>(args: SelectSubset<T, TaxPayerDeleteArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaxPayer.
     * @param {TaxPayerUpdateArgs} args - Arguments to update one TaxPayer.
     * @example
     * // Update one TaxPayer
     * const taxPayer = await prisma.taxPayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxPayerUpdateArgs>(args: SelectSubset<T, TaxPayerUpdateArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaxPayers.
     * @param {TaxPayerDeleteManyArgs} args - Arguments to filter TaxPayers to delete.
     * @example
     * // Delete a few TaxPayers
     * const { count } = await prisma.taxPayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxPayerDeleteManyArgs>(args?: SelectSubset<T, TaxPayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxPayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxPayers
     * const taxPayer = await prisma.taxPayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxPayerUpdateManyArgs>(args: SelectSubset<T, TaxPayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxPayer.
     * @param {TaxPayerUpsertArgs} args - Arguments to update or create a TaxPayer.
     * @example
     * // Update or create a TaxPayer
     * const taxPayer = await prisma.taxPayer.upsert({
     *   create: {
     *     // ... data to create a TaxPayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxPayer we want to update
     *   }
     * })
     */
    upsert<T extends TaxPayerUpsertArgs>(args: SelectSubset<T, TaxPayerUpsertArgs<ExtArgs>>): Prisma__TaxPayerClient<$Result.GetResult<Prisma.$TaxPayerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaxPayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerCountArgs} args - Arguments to filter TaxPayers to count.
     * @example
     * // Count the number of TaxPayers
     * const count = await prisma.taxPayer.count({
     *   where: {
     *     // ... the filter for the TaxPayers we want to count
     *   }
     * })
    **/
    count<T extends TaxPayerCountArgs>(
      args?: Subset<T, TaxPayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxPayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxPayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxPayerAggregateArgs>(args: Subset<T, TaxPayerAggregateArgs>): Prisma.PrismaPromise<GetTaxPayerAggregateType<T>>

    /**
     * Group by TaxPayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxPayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxPayerGroupByArgs['orderBy'] }
        : { orderBy?: TaxPayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxPayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxPayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxPayer model
   */
  readonly fields: TaxPayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxPayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxPayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesOrExpenses<T extends TaxPayer$PurchasesOrExpensesArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayer$PurchasesOrExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesOrExpensesPayload<ExtArgs>, T, "findMany"> | Null>
    Requests<T extends TaxPayer$RequestsArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayer$RequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestsPayload<ExtArgs>, T, "findMany"> | Null>
    Users<T extends TaxPayer$UsersArgs<ExtArgs> = {}>(args?: Subset<T, TaxPayer$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxPayer model
   */ 
  interface TaxPayerFieldRefs {
    readonly id: FieldRef<"TaxPayer", 'String'>
    readonly name: FieldRef<"TaxPayer", 'String'>
    readonly tradeName: FieldRef<"TaxPayer", 'String'>
    readonly about: FieldRef<"TaxPayer", 'String'>
    readonly col1: FieldRef<"TaxPayer", 'String'>
    readonly col2: FieldRef<"TaxPayer", 'String'>
    readonly col3: FieldRef<"TaxPayer", 'String'>
    readonly col4: FieldRef<"TaxPayer", 'String'>
    readonly createdAt: FieldRef<"TaxPayer", 'String'>
    readonly state: FieldRef<"TaxPayer", 'String'>
    readonly status: FieldRef<"TaxPayer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaxPayer findUnique
   */
  export type TaxPayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayer to fetch.
     */
    where: TaxPayerWhereUniqueInput
  }

  /**
   * TaxPayer findUniqueOrThrow
   */
  export type TaxPayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayer to fetch.
     */
    where: TaxPayerWhereUniqueInput
  }

  /**
   * TaxPayer findFirst
   */
  export type TaxPayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayer to fetch.
     */
    where?: TaxPayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayers to fetch.
     */
    orderBy?: TaxPayerOrderByWithRelationInput | TaxPayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPayers.
     */
    cursor?: TaxPayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPayers.
     */
    distinct?: TaxPayerScalarFieldEnum | TaxPayerScalarFieldEnum[]
  }

  /**
   * TaxPayer findFirstOrThrow
   */
  export type TaxPayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayer to fetch.
     */
    where?: TaxPayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayers to fetch.
     */
    orderBy?: TaxPayerOrderByWithRelationInput | TaxPayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPayers.
     */
    cursor?: TaxPayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPayers.
     */
    distinct?: TaxPayerScalarFieldEnum | TaxPayerScalarFieldEnum[]
  }

  /**
   * TaxPayer findMany
   */
  export type TaxPayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * Filter, which TaxPayers to fetch.
     */
    where?: TaxPayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPayers to fetch.
     */
    orderBy?: TaxPayerOrderByWithRelationInput | TaxPayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxPayers.
     */
    cursor?: TaxPayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPayers.
     */
    skip?: number
    distinct?: TaxPayerScalarFieldEnum | TaxPayerScalarFieldEnum[]
  }

  /**
   * TaxPayer create
   */
  export type TaxPayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxPayer.
     */
    data: XOR<TaxPayerCreateInput, TaxPayerUncheckedCreateInput>
  }

  /**
   * TaxPayer createMany
   */
  export type TaxPayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxPayers.
     */
    data: TaxPayerCreateManyInput | TaxPayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxPayer createManyAndReturn
   */
  export type TaxPayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaxPayers.
     */
    data: TaxPayerCreateManyInput | TaxPayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxPayer update
   */
  export type TaxPayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxPayer.
     */
    data: XOR<TaxPayerUpdateInput, TaxPayerUncheckedUpdateInput>
    /**
     * Choose, which TaxPayer to update.
     */
    where: TaxPayerWhereUniqueInput
  }

  /**
   * TaxPayer updateMany
   */
  export type TaxPayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxPayers.
     */
    data: XOR<TaxPayerUpdateManyMutationInput, TaxPayerUncheckedUpdateManyInput>
    /**
     * Filter which TaxPayers to update
     */
    where?: TaxPayerWhereInput
  }

  /**
   * TaxPayer upsert
   */
  export type TaxPayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxPayer to update in case it exists.
     */
    where: TaxPayerWhereUniqueInput
    /**
     * In case the TaxPayer found by the `where` argument doesn't exist, create a new TaxPayer with this data.
     */
    create: XOR<TaxPayerCreateInput, TaxPayerUncheckedCreateInput>
    /**
     * In case the TaxPayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxPayerUpdateInput, TaxPayerUncheckedUpdateInput>
  }

  /**
   * TaxPayer delete
   */
  export type TaxPayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
    /**
     * Filter which TaxPayer to delete.
     */
    where: TaxPayerWhereUniqueInput
  }

  /**
   * TaxPayer deleteMany
   */
  export type TaxPayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPayers to delete
     */
    where?: TaxPayerWhereInput
  }

  /**
   * TaxPayer.PurchasesOrExpenses
   */
  export type TaxPayer$PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesOrExpenses
     */
    select?: PurchasesOrExpensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesOrExpensesInclude<ExtArgs> | null
    where?: PurchasesOrExpensesWhereInput
    orderBy?: PurchasesOrExpensesOrderByWithRelationInput | PurchasesOrExpensesOrderByWithRelationInput[]
    cursor?: PurchasesOrExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesOrExpensesScalarFieldEnum | PurchasesOrExpensesScalarFieldEnum[]
  }

  /**
   * TaxPayer.Requests
   */
  export type TaxPayer$RequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requests
     */
    select?: RequestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestsInclude<ExtArgs> | null
    where?: RequestsWhereInput
    orderBy?: RequestsOrderByWithRelationInput | RequestsOrderByWithRelationInput[]
    cursor?: RequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * TaxPayer.Users
   */
  export type TaxPayer$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * TaxPayer without action
   */
  export type TaxPayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPayer
     */
    select?: TaxPayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPayerInclude<ExtArgs> | null
  }


  /**
   * Model DocumentType
   */

  export type AggregateDocumentType = {
    _count: DocumentTypeCountAggregateOutputType | null
    _avg: DocumentTypeAvgAggregateOutputType | null
    _sum: DocumentTypeSumAggregateOutputType | null
    _min: DocumentTypeMinAggregateOutputType | null
    _max: DocumentTypeMaxAggregateOutputType | null
  }

  export type DocumentTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type DocumentTypeSumAggregateOutputType = {
    id: number | null
  }

  export type DocumentTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DocumentTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DocumentTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DocumentTypeAvgAggregateInputType = {
    id?: true
  }

  export type DocumentTypeSumAggregateInputType = {
    id?: true
  }

  export type DocumentTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DocumentTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DocumentTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DocumentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentType to aggregate.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentTypes
    **/
    _count?: true | DocumentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentTypeMaxAggregateInputType
  }

  export type GetDocumentTypeAggregateType<T extends DocumentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentType[P]>
      : GetScalarType<T[P], AggregateDocumentType[P]>
  }




  export type DocumentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTypeWhereInput
    orderBy?: DocumentTypeOrderByWithAggregationInput | DocumentTypeOrderByWithAggregationInput[]
    by: DocumentTypeScalarFieldEnum[] | DocumentTypeScalarFieldEnum
    having?: DocumentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentTypeCountAggregateInputType | true
    _avg?: DocumentTypeAvgAggregateInputType
    _sum?: DocumentTypeSumAggregateInputType
    _min?: DocumentTypeMinAggregateInputType
    _max?: DocumentTypeMaxAggregateInputType
  }

  export type DocumentTypeGroupByOutputType = {
    id: number
    name: string
    _count: DocumentTypeCountAggregateOutputType | null
    _avg: DocumentTypeAvgAggregateOutputType | null
    _sum: DocumentTypeSumAggregateOutputType | null
    _min: DocumentTypeMinAggregateOutputType | null
    _max: DocumentTypeMaxAggregateOutputType | null
  }

  type GetDocumentTypeGroupByPayload<T extends DocumentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentTypeGroupByOutputType[P]>
        }
      >
    >


  export type DocumentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    Documents?: boolean | DocumentType$DocumentsArgs<ExtArgs>
    _count?: boolean | DocumentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentType"]>

  export type DocumentTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["documentType"]>

  export type DocumentTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DocumentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Documents?: boolean | DocumentType$DocumentsArgs<ExtArgs>
    _count?: boolean | DocumentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentType"
    objects: {
      Documents: Prisma.$DocumentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["documentType"]>
    composites: {}
  }

  type DocumentTypeGetPayload<S extends boolean | null | undefined | DocumentTypeDefaultArgs> = $Result.GetResult<Prisma.$DocumentTypePayload, S>

  type DocumentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentTypeCountAggregateInputType | true
    }

  export interface DocumentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentType'], meta: { name: 'DocumentType' } }
    /**
     * Find zero or one DocumentType that matches the filter.
     * @param {DocumentTypeFindUniqueArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentTypeFindUniqueArgs>(args: SelectSubset<T, DocumentTypeFindUniqueArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentTypeFindUniqueOrThrowArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindFirstArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentTypeFindFirstArgs>(args?: SelectSubset<T, DocumentTypeFindFirstArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindFirstOrThrowArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentTypes
     * const documentTypes = await prisma.documentType.findMany()
     * 
     * // Get first 10 DocumentTypes
     * const documentTypes = await prisma.documentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentTypeWithIdOnly = await prisma.documentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentTypeFindManyArgs>(args?: SelectSubset<T, DocumentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentType.
     * @param {DocumentTypeCreateArgs} args - Arguments to create a DocumentType.
     * @example
     * // Create one DocumentType
     * const DocumentType = await prisma.documentType.create({
     *   data: {
     *     // ... data to create a DocumentType
     *   }
     * })
     * 
     */
    create<T extends DocumentTypeCreateArgs>(args: SelectSubset<T, DocumentTypeCreateArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentTypes.
     * @param {DocumentTypeCreateManyArgs} args - Arguments to create many DocumentTypes.
     * @example
     * // Create many DocumentTypes
     * const documentType = await prisma.documentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentTypeCreateManyArgs>(args?: SelectSubset<T, DocumentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentTypes and returns the data saved in the database.
     * @param {DocumentTypeCreateManyAndReturnArgs} args - Arguments to create many DocumentTypes.
     * @example
     * // Create many DocumentTypes
     * const documentType = await prisma.documentType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentTypes and only return the `id`
     * const documentTypeWithIdOnly = await prisma.documentType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DocumentType.
     * @param {DocumentTypeDeleteArgs} args - Arguments to delete one DocumentType.
     * @example
     * // Delete one DocumentType
     * const DocumentType = await prisma.documentType.delete({
     *   where: {
     *     // ... filter to delete one DocumentType
     *   }
     * })
     * 
     */
    delete<T extends DocumentTypeDeleteArgs>(args: SelectSubset<T, DocumentTypeDeleteArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentType.
     * @param {DocumentTypeUpdateArgs} args - Arguments to update one DocumentType.
     * @example
     * // Update one DocumentType
     * const documentType = await prisma.documentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentTypeUpdateArgs>(args: SelectSubset<T, DocumentTypeUpdateArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentTypes.
     * @param {DocumentTypeDeleteManyArgs} args - Arguments to filter DocumentTypes to delete.
     * @example
     * // Delete a few DocumentTypes
     * const { count } = await prisma.documentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentTypeDeleteManyArgs>(args?: SelectSubset<T, DocumentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentTypes
     * const documentType = await prisma.documentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentTypeUpdateManyArgs>(args: SelectSubset<T, DocumentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentType.
     * @param {DocumentTypeUpsertArgs} args - Arguments to update or create a DocumentType.
     * @example
     * // Update or create a DocumentType
     * const documentType = await prisma.documentType.upsert({
     *   create: {
     *     // ... data to create a DocumentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentType we want to update
     *   }
     * })
     */
    upsert<T extends DocumentTypeUpsertArgs>(args: SelectSubset<T, DocumentTypeUpsertArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocumentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeCountArgs} args - Arguments to filter DocumentTypes to count.
     * @example
     * // Count the number of DocumentTypes
     * const count = await prisma.documentType.count({
     *   where: {
     *     // ... the filter for the DocumentTypes we want to count
     *   }
     * })
    **/
    count<T extends DocumentTypeCountArgs>(
      args?: Subset<T, DocumentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentTypeAggregateArgs>(args: Subset<T, DocumentTypeAggregateArgs>): Prisma.PrismaPromise<GetDocumentTypeAggregateType<T>>

    /**
     * Group by DocumentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentTypeGroupByArgs['orderBy'] }
        : { orderBy?: DocumentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentType model
   */
  readonly fields: DocumentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Documents<T extends DocumentType$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentType$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentType model
   */ 
  interface DocumentTypeFieldRefs {
    readonly id: FieldRef<"DocumentType", 'Int'>
    readonly name: FieldRef<"DocumentType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentType findUnique
   */
  export type DocumentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType findUniqueOrThrow
   */
  export type DocumentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType findFirst
   */
  export type DocumentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTypes.
     */
    distinct?: DocumentTypeScalarFieldEnum | DocumentTypeScalarFieldEnum[]
  }

  /**
   * DocumentType findFirstOrThrow
   */
  export type DocumentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTypes.
     */
    distinct?: DocumentTypeScalarFieldEnum | DocumentTypeScalarFieldEnum[]
  }

  /**
   * DocumentType findMany
   */
  export type DocumentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTypes to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    distinct?: DocumentTypeScalarFieldEnum | DocumentTypeScalarFieldEnum[]
  }

  /**
   * DocumentType create
   */
  export type DocumentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentType.
     */
    data: XOR<DocumentTypeCreateInput, DocumentTypeUncheckedCreateInput>
  }

  /**
   * DocumentType createMany
   */
  export type DocumentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentTypes.
     */
    data: DocumentTypeCreateManyInput | DocumentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentType createManyAndReturn
   */
  export type DocumentTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DocumentTypes.
     */
    data: DocumentTypeCreateManyInput | DocumentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentType update
   */
  export type DocumentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentType.
     */
    data: XOR<DocumentTypeUpdateInput, DocumentTypeUncheckedUpdateInput>
    /**
     * Choose, which DocumentType to update.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType updateMany
   */
  export type DocumentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentTypes.
     */
    data: XOR<DocumentTypeUpdateManyMutationInput, DocumentTypeUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTypes to update
     */
    where?: DocumentTypeWhereInput
  }

  /**
   * DocumentType upsert
   */
  export type DocumentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentType to update in case it exists.
     */
    where: DocumentTypeWhereUniqueInput
    /**
     * In case the DocumentType found by the `where` argument doesn't exist, create a new DocumentType with this data.
     */
    create: XOR<DocumentTypeCreateInput, DocumentTypeUncheckedCreateInput>
    /**
     * In case the DocumentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentTypeUpdateInput, DocumentTypeUncheckedUpdateInput>
  }

  /**
   * DocumentType delete
   */
  export type DocumentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter which DocumentType to delete.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType deleteMany
   */
  export type DocumentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTypes to delete
     */
    where?: DocumentTypeWhereInput
  }

  /**
   * DocumentType.Documents
   */
  export type DocumentType$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    cursor?: DocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * DocumentType without action
   */
  export type DocumentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
  }


  /**
   * Model EmailVerifications
   */

  export type AggregateEmailVerifications = {
    _count: EmailVerificationsCountAggregateOutputType | null
    _avg: EmailVerificationsAvgAggregateOutputType | null
    _sum: EmailVerificationsSumAggregateOutputType | null
    _min: EmailVerificationsMinAggregateOutputType | null
    _max: EmailVerificationsMaxAggregateOutputType | null
  }

  export type EmailVerificationsAvgAggregateOutputType = {
    id: number | null
  }

  export type EmailVerificationsSumAggregateOutputType = {
    id: number | null
  }

  export type EmailVerificationsMinAggregateOutputType = {
    id: number | null
    email: string | null
    isVerify: boolean | null
    createdAt: Date | null
    code: string | null
    expirationDate: Date | null
  }

  export type EmailVerificationsMaxAggregateOutputType = {
    id: number | null
    email: string | null
    isVerify: boolean | null
    createdAt: Date | null
    code: string | null
    expirationDate: Date | null
  }

  export type EmailVerificationsCountAggregateOutputType = {
    id: number
    email: number
    isVerify: number
    createdAt: number
    code: number
    expirationDate: number
    _all: number
  }


  export type EmailVerificationsAvgAggregateInputType = {
    id?: true
  }

  export type EmailVerificationsSumAggregateInputType = {
    id?: true
  }

  export type EmailVerificationsMinAggregateInputType = {
    id?: true
    email?: true
    isVerify?: true
    createdAt?: true
    code?: true
    expirationDate?: true
  }

  export type EmailVerificationsMaxAggregateInputType = {
    id?: true
    email?: true
    isVerify?: true
    createdAt?: true
    code?: true
    expirationDate?: true
  }

  export type EmailVerificationsCountAggregateInputType = {
    id?: true
    email?: true
    isVerify?: true
    createdAt?: true
    code?: true
    expirationDate?: true
    _all?: true
  }

  export type EmailVerificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerifications to aggregate.
     */
    where?: EmailVerificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationsOrderByWithRelationInput | EmailVerificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerifications
    **/
    _count?: true | EmailVerificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailVerificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailVerificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationsMaxAggregateInputType
  }

  export type GetEmailVerificationsAggregateType<T extends EmailVerificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerifications[P]>
      : GetScalarType<T[P], AggregateEmailVerifications[P]>
  }




  export type EmailVerificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationsWhereInput
    orderBy?: EmailVerificationsOrderByWithAggregationInput | EmailVerificationsOrderByWithAggregationInput[]
    by: EmailVerificationsScalarFieldEnum[] | EmailVerificationsScalarFieldEnum
    having?: EmailVerificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailVerificationsCountAggregateInputType | true
    _avg?: EmailVerificationsAvgAggregateInputType
    _sum?: EmailVerificationsSumAggregateInputType
    _min?: EmailVerificationsMinAggregateInputType
    _max?: EmailVerificationsMaxAggregateInputType
  }

  export type EmailVerificationsGroupByOutputType = {
    id: number
    email: string
    isVerify: boolean
    createdAt: Date
    code: string | null
    expirationDate: Date | null
    _count: EmailVerificationsCountAggregateOutputType | null
    _avg: EmailVerificationsAvgAggregateOutputType | null
    _sum: EmailVerificationsSumAggregateOutputType | null
    _min: EmailVerificationsMinAggregateOutputType | null
    _max: EmailVerificationsMaxAggregateOutputType | null
  }

  type GetEmailVerificationsGroupByPayload<T extends EmailVerificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationsGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationsGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    isVerify?: boolean
    createdAt?: boolean
    code?: boolean
    expirationDate?: boolean
  }, ExtArgs["result"]["emailVerifications"]>

  export type EmailVerificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    isVerify?: boolean
    createdAt?: boolean
    code?: boolean
    expirationDate?: boolean
  }, ExtArgs["result"]["emailVerifications"]>

  export type EmailVerificationsSelectScalar = {
    id?: boolean
    email?: boolean
    isVerify?: boolean
    createdAt?: boolean
    code?: boolean
    expirationDate?: boolean
  }


  export type $EmailVerificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      isVerify: boolean
      createdAt: Date
      code: string | null
      expirationDate: Date | null
    }, ExtArgs["result"]["emailVerifications"]>
    composites: {}
  }

  type EmailVerificationsGetPayload<S extends boolean | null | undefined | EmailVerificationsDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationsPayload, S>

  type EmailVerificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailVerificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailVerificationsCountAggregateInputType | true
    }

  export interface EmailVerificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerifications'], meta: { name: 'EmailVerifications' } }
    /**
     * Find zero or one EmailVerifications that matches the filter.
     * @param {EmailVerificationsFindUniqueArgs} args - Arguments to find a EmailVerifications
     * @example
     * // Get one EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationsFindUniqueArgs>(args: SelectSubset<T, EmailVerificationsFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailVerifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailVerificationsFindUniqueOrThrowArgs} args - Arguments to find a EmailVerifications
     * @example
     * // Get one EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationsFindFirstArgs} args - Arguments to find a EmailVerifications
     * @example
     * // Get one EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationsFindFirstArgs>(args?: SelectSubset<T, EmailVerificationsFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailVerifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationsFindFirstOrThrowArgs} args - Arguments to find a EmailVerifications
     * @example
     * // Get one EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.findMany()
     * 
     * // Get first 10 EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationsWithIdOnly = await prisma.emailVerifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationsFindManyArgs>(args?: SelectSubset<T, EmailVerificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailVerifications.
     * @param {EmailVerificationsCreateArgs} args - Arguments to create a EmailVerifications.
     * @example
     * // Create one EmailVerifications
     * const EmailVerifications = await prisma.emailVerifications.create({
     *   data: {
     *     // ... data to create a EmailVerifications
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationsCreateArgs>(args: SelectSubset<T, EmailVerificationsCreateArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailVerifications.
     * @param {EmailVerificationsCreateManyArgs} args - Arguments to create many EmailVerifications.
     * @example
     * // Create many EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationsCreateManyArgs>(args?: SelectSubset<T, EmailVerificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailVerifications and returns the data saved in the database.
     * @param {EmailVerificationsCreateManyAndReturnArgs} args - Arguments to create many EmailVerifications.
     * @example
     * // Create many EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailVerifications and only return the `id`
     * const emailVerificationsWithIdOnly = await prisma.emailVerifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailVerificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailVerificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailVerifications.
     * @param {EmailVerificationsDeleteArgs} args - Arguments to delete one EmailVerifications.
     * @example
     * // Delete one EmailVerifications
     * const EmailVerifications = await prisma.emailVerifications.delete({
     *   where: {
     *     // ... filter to delete one EmailVerifications
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationsDeleteArgs>(args: SelectSubset<T, EmailVerificationsDeleteArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailVerifications.
     * @param {EmailVerificationsUpdateArgs} args - Arguments to update one EmailVerifications.
     * @example
     * // Update one EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationsUpdateArgs>(args: SelectSubset<T, EmailVerificationsUpdateArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailVerifications.
     * @param {EmailVerificationsDeleteManyArgs} args - Arguments to filter EmailVerifications to delete.
     * @example
     * // Delete a few EmailVerifications
     * const { count } = await prisma.emailVerifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationsDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationsUpdateManyArgs>(args: SelectSubset<T, EmailVerificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailVerifications.
     * @param {EmailVerificationsUpsertArgs} args - Arguments to update or create a EmailVerifications.
     * @example
     * // Update or create a EmailVerifications
     * const emailVerifications = await prisma.emailVerifications.upsert({
     *   create: {
     *     // ... data to create a EmailVerifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerifications we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationsUpsertArgs>(args: SelectSubset<T, EmailVerificationsUpsertArgs<ExtArgs>>): Prisma__EmailVerificationsClient<$Result.GetResult<Prisma.$EmailVerificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationsCountArgs} args - Arguments to filter EmailVerifications to count.
     * @example
     * // Count the number of EmailVerifications
     * const count = await prisma.emailVerifications.count({
     *   where: {
     *     // ... the filter for the EmailVerifications we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationsCountArgs>(
      args?: Subset<T, EmailVerificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationsAggregateArgs>(args: Subset<T, EmailVerificationsAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationsAggregateType<T>>

    /**
     * Group by EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationsGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerifications model
   */
  readonly fields: EmailVerificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerifications model
   */ 
  interface EmailVerificationsFieldRefs {
    readonly id: FieldRef<"EmailVerifications", 'Int'>
    readonly email: FieldRef<"EmailVerifications", 'String'>
    readonly isVerify: FieldRef<"EmailVerifications", 'Boolean'>
    readonly createdAt: FieldRef<"EmailVerifications", 'DateTime'>
    readonly code: FieldRef<"EmailVerifications", 'String'>
    readonly expirationDate: FieldRef<"EmailVerifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerifications findUnique
   */
  export type EmailVerificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where: EmailVerificationsWhereUniqueInput
  }

  /**
   * EmailVerifications findUniqueOrThrow
   */
  export type EmailVerificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where: EmailVerificationsWhereUniqueInput
  }

  /**
   * EmailVerifications findFirst
   */
  export type EmailVerificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where?: EmailVerificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationsOrderByWithRelationInput | EmailVerificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationsScalarFieldEnum | EmailVerificationsScalarFieldEnum[]
  }

  /**
   * EmailVerifications findFirstOrThrow
   */
  export type EmailVerificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where?: EmailVerificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationsOrderByWithRelationInput | EmailVerificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationsScalarFieldEnum | EmailVerificationsScalarFieldEnum[]
  }

  /**
   * EmailVerifications findMany
   */
  export type EmailVerificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where?: EmailVerificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationsOrderByWithRelationInput | EmailVerificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerifications.
     */
    cursor?: EmailVerificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    distinct?: EmailVerificationsScalarFieldEnum | EmailVerificationsScalarFieldEnum[]
  }

  /**
   * EmailVerifications create
   */
  export type EmailVerificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailVerifications.
     */
    data: XOR<EmailVerificationsCreateInput, EmailVerificationsUncheckedCreateInput>
  }

  /**
   * EmailVerifications createMany
   */
  export type EmailVerificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerifications.
     */
    data: EmailVerificationsCreateManyInput | EmailVerificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerifications createManyAndReturn
   */
  export type EmailVerificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailVerifications.
     */
    data: EmailVerificationsCreateManyInput | EmailVerificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerifications update
   */
  export type EmailVerificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailVerifications.
     */
    data: XOR<EmailVerificationsUpdateInput, EmailVerificationsUncheckedUpdateInput>
    /**
     * Choose, which EmailVerifications to update.
     */
    where: EmailVerificationsWhereUniqueInput
  }

  /**
   * EmailVerifications updateMany
   */
  export type EmailVerificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerifications.
     */
    data: XOR<EmailVerificationsUpdateManyMutationInput, EmailVerificationsUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerifications to update
     */
    where?: EmailVerificationsWhereInput
  }

  /**
   * EmailVerifications upsert
   */
  export type EmailVerificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailVerifications to update in case it exists.
     */
    where: EmailVerificationsWhereUniqueInput
    /**
     * In case the EmailVerifications found by the `where` argument doesn't exist, create a new EmailVerifications with this data.
     */
    create: XOR<EmailVerificationsCreateInput, EmailVerificationsUncheckedCreateInput>
    /**
     * In case the EmailVerifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationsUpdateInput, EmailVerificationsUncheckedUpdateInput>
  }

  /**
   * EmailVerifications delete
   */
  export type EmailVerificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
    /**
     * Filter which EmailVerifications to delete.
     */
    where: EmailVerificationsWhereUniqueInput
  }

  /**
   * EmailVerifications deleteMany
   */
  export type EmailVerificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerifications to delete
     */
    where?: EmailVerificationsWhereInput
  }

  /**
   * EmailVerifications without action
   */
  export type EmailVerificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerifications
     */
    select?: EmailVerificationsSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    email: 'email',
    passwordChangeMode: 'passwordChangeMode',
    enabled: 'enabled',
    createdAt: 'createdAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SerialScalarFieldEnum: {
    id: 'id',
    code: 'code'
  };

  export type SerialScalarFieldEnum = (typeof SerialScalarFieldEnum)[keyof typeof SerialScalarFieldEnum]


  export const ClassificationTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ClassificationTypeScalarFieldEnum = (typeof ClassificationTypeScalarFieldEnum)[keyof typeof ClassificationTypeScalarFieldEnum]


  export const ConceptsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    authorId: 'authorId',
    invoiceTypeId: 'invoiceTypeId',
    classificationTypeId: 'classificationTypeId'
  };

  export type ConceptsScalarFieldEnum = (typeof ConceptsScalarFieldEnum)[keyof typeof ConceptsScalarFieldEnum]


  export const RequestStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type RequestStatusScalarFieldEnum = (typeof RequestStatusScalarFieldEnum)[keyof typeof RequestStatusScalarFieldEnum]


  export const RequestsScalarFieldEnum: {
    id: 'id',
    requestNum: 'requestNum',
    username: 'username',
    email: 'email',
    createdAt: 'createdAt',
    requestStatusId: 'requestStatusId'
  };

  export type RequestsScalarFieldEnum = (typeof RequestsScalarFieldEnum)[keyof typeof RequestsScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    downloadURL: 'downloadURL',
    fileFormatType: 'fileFormatType',
    documentTypeId: 'documentTypeId',
    createdAt: 'createdAt',
    requestId: 'requestId'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const PurchasesOrExpensesScalarFieldEnum: {
    id: 'id',
    rncOrId: 'rncOrId',
    ncf: 'ncf',
    ncfAffected: 'ncfAffected',
    issueDate: 'issueDate',
    retentionDate: 'retentionDate',
    total: 'total',
    tax: 'tax',
    costTax: 'costTax',
    taxPayerTypesId: 'taxPayerTypesId',
    paymentsMethodsId: 'paymentsMethodsId',
    ncfsTypesId: 'ncfsTypesId',
    ncfsAffectTypeId: 'ncfsAffectTypeId',
    retentionTaxId: 'retentionTaxId',
    retentionIsrId: 'retentionIsrId',
    costTaxStatusId: 'costTaxStatusId',
    conceptId: 'conceptId',
    authorId: 'authorId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    netAmount: 'netAmount',
    retentionTaxValue: 'retentionTaxValue',
    retentionIsrValue: 'retentionIsrValue',
    netToPaid: 'netToPaid',
    taxForOvertaking: 'taxForOvertaking',
    manual: 'manual'
  };

  export type PurchasesOrExpensesScalarFieldEnum = (typeof PurchasesOrExpensesScalarFieldEnum)[keyof typeof PurchasesOrExpensesScalarFieldEnum]


  export const TaxPayerTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type TaxPayerTypesScalarFieldEnum = (typeof TaxPayerTypesScalarFieldEnum)[keyof typeof TaxPayerTypesScalarFieldEnum]


  export const InvoiceTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type InvoiceTypeScalarFieldEnum = (typeof InvoiceTypeScalarFieldEnum)[keyof typeof InvoiceTypeScalarFieldEnum]


  export const PaymentsMethodsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type PaymentsMethodsScalarFieldEnum = (typeof PaymentsMethodsScalarFieldEnum)[keyof typeof PaymentsMethodsScalarFieldEnum]


  export const NcfsTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    serialId: 'serialId',
    createdAt: 'createdAt'
  };

  export type NcfsTypesScalarFieldEnum = (typeof NcfsTypesScalarFieldEnum)[keyof typeof NcfsTypesScalarFieldEnum]


  export const RetentionTaxScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rate: 'rate',
    createdAt: 'createdAt'
  };

  export type RetentionTaxScalarFieldEnum = (typeof RetentionTaxScalarFieldEnum)[keyof typeof RetentionTaxScalarFieldEnum]


  export const RetentionIsrScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rate: 'rate',
    createdAt: 'createdAt'
  };

  export type RetentionIsrScalarFieldEnum = (typeof RetentionIsrScalarFieldEnum)[keyof typeof RetentionIsrScalarFieldEnum]


  export const CostTaxStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type CostTaxStatusScalarFieldEnum = (typeof CostTaxStatusScalarFieldEnum)[keyof typeof CostTaxStatusScalarFieldEnum]


  export const TaxPayerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tradeName: 'tradeName',
    about: 'about',
    col1: 'col1',
    col2: 'col2',
    col3: 'col3',
    col4: 'col4',
    createdAt: 'createdAt',
    state: 'state',
    status: 'status'
  };

  export type TaxPayerScalarFieldEnum = (typeof TaxPayerScalarFieldEnum)[keyof typeof TaxPayerScalarFieldEnum]


  export const DocumentTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DocumentTypeScalarFieldEnum = (typeof DocumentTypeScalarFieldEnum)[keyof typeof DocumentTypeScalarFieldEnum]


  export const EmailVerificationsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    isVerify: 'isVerify',
    createdAt: 'createdAt',
    code: 'code',
    expirationDate: 'expirationDate'
  };

  export type EmailVerificationsScalarFieldEnum = (typeof EmailVerificationsScalarFieldEnum)[keyof typeof EmailVerificationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    passwordChangeMode?: BoolFilter<"Users"> | boolean
    enabled?: BoolFilter<"Users"> | boolean
    createdAt?: DateTimeFilter<"Users"> | Date | string
    taxPayer?: XOR<TaxPayerRelationFilter, TaxPayerWhereInput>
    Concepts?: ConceptsListRelationFilter
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    passwordChangeMode?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    taxPayer?: TaxPayerOrderByWithRelationInput
    Concepts?: ConceptsOrderByRelationAggregateInput
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    username?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    passwordChangeMode?: BoolFilter<"Users"> | boolean
    enabled?: BoolFilter<"Users"> | boolean
    createdAt?: DateTimeFilter<"Users"> | Date | string
    taxPayer?: XOR<TaxPayerRelationFilter, TaxPayerWhereInput>
    Concepts?: ConceptsListRelationFilter
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }, "id" | "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    passwordChangeMode?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    username?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    passwordChangeMode?: BoolWithAggregatesFilter<"Users"> | boolean
    enabled?: BoolWithAggregatesFilter<"Users"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type SerialWhereInput = {
    AND?: SerialWhereInput | SerialWhereInput[]
    OR?: SerialWhereInput[]
    NOT?: SerialWhereInput | SerialWhereInput[]
    id?: IntFilter<"Serial"> | number
    code?: StringFilter<"Serial"> | string
    NcfsTypes?: NcfsTypesListRelationFilter
  }

  export type SerialOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    NcfsTypes?: NcfsTypesOrderByRelationAggregateInput
  }

  export type SerialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SerialWhereInput | SerialWhereInput[]
    OR?: SerialWhereInput[]
    NOT?: SerialWhereInput | SerialWhereInput[]
    NcfsTypes?: NcfsTypesListRelationFilter
  }, "id" | "code">

  export type SerialOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    _count?: SerialCountOrderByAggregateInput
    _avg?: SerialAvgOrderByAggregateInput
    _max?: SerialMaxOrderByAggregateInput
    _min?: SerialMinOrderByAggregateInput
    _sum?: SerialSumOrderByAggregateInput
  }

  export type SerialScalarWhereWithAggregatesInput = {
    AND?: SerialScalarWhereWithAggregatesInput | SerialScalarWhereWithAggregatesInput[]
    OR?: SerialScalarWhereWithAggregatesInput[]
    NOT?: SerialScalarWhereWithAggregatesInput | SerialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Serial"> | number
    code?: StringWithAggregatesFilter<"Serial"> | string
  }

  export type ClassificationTypeWhereInput = {
    AND?: ClassificationTypeWhereInput | ClassificationTypeWhereInput[]
    OR?: ClassificationTypeWhereInput[]
    NOT?: ClassificationTypeWhereInput | ClassificationTypeWhereInput[]
    id?: IntFilter<"ClassificationType"> | number
    name?: StringFilter<"ClassificationType"> | string
    Concepts?: ConceptsListRelationFilter
  }

  export type ClassificationTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Concepts?: ConceptsOrderByRelationAggregateInput
  }

  export type ClassificationTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassificationTypeWhereInput | ClassificationTypeWhereInput[]
    OR?: ClassificationTypeWhereInput[]
    NOT?: ClassificationTypeWhereInput | ClassificationTypeWhereInput[]
    name?: StringFilter<"ClassificationType"> | string
    Concepts?: ConceptsListRelationFilter
  }, "id" | "id">

  export type ClassificationTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ClassificationTypeCountOrderByAggregateInput
    _avg?: ClassificationTypeAvgOrderByAggregateInput
    _max?: ClassificationTypeMaxOrderByAggregateInput
    _min?: ClassificationTypeMinOrderByAggregateInput
    _sum?: ClassificationTypeSumOrderByAggregateInput
  }

  export type ClassificationTypeScalarWhereWithAggregatesInput = {
    AND?: ClassificationTypeScalarWhereWithAggregatesInput | ClassificationTypeScalarWhereWithAggregatesInput[]
    OR?: ClassificationTypeScalarWhereWithAggregatesInput[]
    NOT?: ClassificationTypeScalarWhereWithAggregatesInput | ClassificationTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassificationType"> | number
    name?: StringWithAggregatesFilter<"ClassificationType"> | string
  }

  export type ConceptsWhereInput = {
    AND?: ConceptsWhereInput | ConceptsWhereInput[]
    OR?: ConceptsWhereInput[]
    NOT?: ConceptsWhereInput | ConceptsWhereInput[]
    id?: IntFilter<"Concepts"> | number
    name?: StringFilter<"Concepts"> | string
    authorId?: StringFilter<"Concepts"> | string
    invoiceTypeId?: StringFilter<"Concepts"> | string
    classificationTypeId?: IntFilter<"Concepts"> | number
    classificationType?: XOR<ClassificationTypeRelationFilter, ClassificationTypeWhereInput>
    invoiceType?: XOR<InvoiceTypeRelationFilter, InvoiceTypeWhereInput>
    author?: XOR<UsersRelationFilter, UsersWhereInput>
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }

  export type ConceptsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    invoiceTypeId?: SortOrder
    classificationTypeId?: SortOrder
    classificationType?: ClassificationTypeOrderByWithRelationInput
    invoiceType?: InvoiceTypeOrderByWithRelationInput
    author?: UsersOrderByWithRelationInput
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type ConceptsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConceptsWhereInput | ConceptsWhereInput[]
    OR?: ConceptsWhereInput[]
    NOT?: ConceptsWhereInput | ConceptsWhereInput[]
    name?: StringFilter<"Concepts"> | string
    authorId?: StringFilter<"Concepts"> | string
    invoiceTypeId?: StringFilter<"Concepts"> | string
    classificationTypeId?: IntFilter<"Concepts"> | number
    classificationType?: XOR<ClassificationTypeRelationFilter, ClassificationTypeWhereInput>
    invoiceType?: XOR<InvoiceTypeRelationFilter, InvoiceTypeWhereInput>
    author?: XOR<UsersRelationFilter, UsersWhereInput>
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }, "id" | "id">

  export type ConceptsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    invoiceTypeId?: SortOrder
    classificationTypeId?: SortOrder
    _count?: ConceptsCountOrderByAggregateInput
    _avg?: ConceptsAvgOrderByAggregateInput
    _max?: ConceptsMaxOrderByAggregateInput
    _min?: ConceptsMinOrderByAggregateInput
    _sum?: ConceptsSumOrderByAggregateInput
  }

  export type ConceptsScalarWhereWithAggregatesInput = {
    AND?: ConceptsScalarWhereWithAggregatesInput | ConceptsScalarWhereWithAggregatesInput[]
    OR?: ConceptsScalarWhereWithAggregatesInput[]
    NOT?: ConceptsScalarWhereWithAggregatesInput | ConceptsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Concepts"> | number
    name?: StringWithAggregatesFilter<"Concepts"> | string
    authorId?: StringWithAggregatesFilter<"Concepts"> | string
    invoiceTypeId?: StringWithAggregatesFilter<"Concepts"> | string
    classificationTypeId?: IntWithAggregatesFilter<"Concepts"> | number
  }

  export type RequestStatusWhereInput = {
    AND?: RequestStatusWhereInput | RequestStatusWhereInput[]
    OR?: RequestStatusWhereInput[]
    NOT?: RequestStatusWhereInput | RequestStatusWhereInput[]
    id?: IntFilter<"RequestStatus"> | number
    name?: StringFilter<"RequestStatus"> | string
    createdAt?: DateTimeFilter<"RequestStatus"> | Date | string
    Requests?: RequestsListRelationFilter
  }

  export type RequestStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    Requests?: RequestsOrderByRelationAggregateInput
  }

  export type RequestStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RequestStatusWhereInput | RequestStatusWhereInput[]
    OR?: RequestStatusWhereInput[]
    NOT?: RequestStatusWhereInput | RequestStatusWhereInput[]
    name?: StringFilter<"RequestStatus"> | string
    createdAt?: DateTimeFilter<"RequestStatus"> | Date | string
    Requests?: RequestsListRelationFilter
  }, "id" | "id">

  export type RequestStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: RequestStatusCountOrderByAggregateInput
    _avg?: RequestStatusAvgOrderByAggregateInput
    _max?: RequestStatusMaxOrderByAggregateInput
    _min?: RequestStatusMinOrderByAggregateInput
    _sum?: RequestStatusSumOrderByAggregateInput
  }

  export type RequestStatusScalarWhereWithAggregatesInput = {
    AND?: RequestStatusScalarWhereWithAggregatesInput | RequestStatusScalarWhereWithAggregatesInput[]
    OR?: RequestStatusScalarWhereWithAggregatesInput[]
    NOT?: RequestStatusScalarWhereWithAggregatesInput | RequestStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestStatus"> | number
    name?: StringWithAggregatesFilter<"RequestStatus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequestStatus"> | Date | string
  }

  export type RequestsWhereInput = {
    AND?: RequestsWhereInput | RequestsWhereInput[]
    OR?: RequestsWhereInput[]
    NOT?: RequestsWhereInput | RequestsWhereInput[]
    id?: StringFilter<"Requests"> | string
    requestNum?: IntFilter<"Requests"> | number
    username?: StringFilter<"Requests"> | string
    email?: StringFilter<"Requests"> | string
    createdAt?: DateTimeFilter<"Requests"> | Date | string
    requestStatusId?: IntFilter<"Requests"> | number
    taxPayer?: XOR<TaxPayerRelationFilter, TaxPayerWhereInput>
    status?: XOR<RequestStatusRelationFilter, RequestStatusWhereInput>
    Documents?: DocumentsListRelationFilter
  }

  export type RequestsOrderByWithRelationInput = {
    id?: SortOrder
    requestNum?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    requestStatusId?: SortOrder
    taxPayer?: TaxPayerOrderByWithRelationInput
    status?: RequestStatusOrderByWithRelationInput
    Documents?: DocumentsOrderByRelationAggregateInput
  }

  export type RequestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: RequestsWhereInput | RequestsWhereInput[]
    OR?: RequestsWhereInput[]
    NOT?: RequestsWhereInput | RequestsWhereInput[]
    requestNum?: IntFilter<"Requests"> | number
    username?: StringFilter<"Requests"> | string
    createdAt?: DateTimeFilter<"Requests"> | Date | string
    requestStatusId?: IntFilter<"Requests"> | number
    taxPayer?: XOR<TaxPayerRelationFilter, TaxPayerWhereInput>
    status?: XOR<RequestStatusRelationFilter, RequestStatusWhereInput>
    Documents?: DocumentsListRelationFilter
  }, "id" | "id" | "email">

  export type RequestsOrderByWithAggregationInput = {
    id?: SortOrder
    requestNum?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    requestStatusId?: SortOrder
    _count?: RequestsCountOrderByAggregateInput
    _avg?: RequestsAvgOrderByAggregateInput
    _max?: RequestsMaxOrderByAggregateInput
    _min?: RequestsMinOrderByAggregateInput
    _sum?: RequestsSumOrderByAggregateInput
  }

  export type RequestsScalarWhereWithAggregatesInput = {
    AND?: RequestsScalarWhereWithAggregatesInput | RequestsScalarWhereWithAggregatesInput[]
    OR?: RequestsScalarWhereWithAggregatesInput[]
    NOT?: RequestsScalarWhereWithAggregatesInput | RequestsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Requests"> | string
    requestNum?: IntWithAggregatesFilter<"Requests"> | number
    username?: StringWithAggregatesFilter<"Requests"> | string
    email?: StringWithAggregatesFilter<"Requests"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Requests"> | Date | string
    requestStatusId?: IntWithAggregatesFilter<"Requests"> | number
  }

  export type DocumentsWhereInput = {
    AND?: DocumentsWhereInput | DocumentsWhereInput[]
    OR?: DocumentsWhereInput[]
    NOT?: DocumentsWhereInput | DocumentsWhereInput[]
    id?: StringFilter<"Documents"> | string
    fileName?: StringFilter<"Documents"> | string
    downloadURL?: StringFilter<"Documents"> | string
    fileFormatType?: StringFilter<"Documents"> | string
    documentTypeId?: IntFilter<"Documents"> | number
    createdAt?: DateTimeFilter<"Documents"> | Date | string
    requestId?: StringFilter<"Documents"> | string
    request?: XOR<RequestsRelationFilter, RequestsWhereInput>
    documentType?: XOR<DocumentTypeRelationFilter, DocumentTypeWhereInput>
  }

  export type DocumentsOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    downloadURL?: SortOrder
    fileFormatType?: SortOrder
    documentTypeId?: SortOrder
    createdAt?: SortOrder
    requestId?: SortOrder
    request?: RequestsOrderByWithRelationInput
    documentType?: DocumentTypeOrderByWithRelationInput
  }

  export type DocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentsWhereInput | DocumentsWhereInput[]
    OR?: DocumentsWhereInput[]
    NOT?: DocumentsWhereInput | DocumentsWhereInput[]
    fileName?: StringFilter<"Documents"> | string
    downloadURL?: StringFilter<"Documents"> | string
    fileFormatType?: StringFilter<"Documents"> | string
    documentTypeId?: IntFilter<"Documents"> | number
    createdAt?: DateTimeFilter<"Documents"> | Date | string
    requestId?: StringFilter<"Documents"> | string
    request?: XOR<RequestsRelationFilter, RequestsWhereInput>
    documentType?: XOR<DocumentTypeRelationFilter, DocumentTypeWhereInput>
  }, "id" | "id">

  export type DocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    downloadURL?: SortOrder
    fileFormatType?: SortOrder
    documentTypeId?: SortOrder
    createdAt?: SortOrder
    requestId?: SortOrder
    _count?: DocumentsCountOrderByAggregateInput
    _avg?: DocumentsAvgOrderByAggregateInput
    _max?: DocumentsMaxOrderByAggregateInput
    _min?: DocumentsMinOrderByAggregateInput
    _sum?: DocumentsSumOrderByAggregateInput
  }

  export type DocumentsScalarWhereWithAggregatesInput = {
    AND?: DocumentsScalarWhereWithAggregatesInput | DocumentsScalarWhereWithAggregatesInput[]
    OR?: DocumentsScalarWhereWithAggregatesInput[]
    NOT?: DocumentsScalarWhereWithAggregatesInput | DocumentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Documents"> | string
    fileName?: StringWithAggregatesFilter<"Documents"> | string
    downloadURL?: StringWithAggregatesFilter<"Documents"> | string
    fileFormatType?: StringWithAggregatesFilter<"Documents"> | string
    documentTypeId?: IntWithAggregatesFilter<"Documents"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Documents"> | Date | string
    requestId?: StringWithAggregatesFilter<"Documents"> | string
  }

  export type PurchasesOrExpensesWhereInput = {
    AND?: PurchasesOrExpensesWhereInput | PurchasesOrExpensesWhereInput[]
    OR?: PurchasesOrExpensesWhereInput[]
    NOT?: PurchasesOrExpensesWhereInput | PurchasesOrExpensesWhereInput[]
    id?: StringFilter<"PurchasesOrExpenses"> | string
    rncOrId?: StringFilter<"PurchasesOrExpenses"> | string
    ncf?: StringFilter<"PurchasesOrExpenses"> | string
    ncfAffected?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    issueDate?: DateTimeFilter<"PurchasesOrExpenses"> | Date | string
    retentionDate?: DateTimeNullableFilter<"PurchasesOrExpenses"> | Date | string | null
    total?: DecimalFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    costTax?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFilter<"PurchasesOrExpenses"> | number
    paymentsMethodsId?: StringFilter<"PurchasesOrExpenses"> | string
    ncfsTypesId?: StringFilter<"PurchasesOrExpenses"> | string
    ncfsAffectTypeId?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    retentionTaxId?: IntNullableFilter<"PurchasesOrExpenses"> | number | null
    retentionIsrId?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    costTaxStatusId?: IntNullableFilter<"PurchasesOrExpenses"> | number | null
    conceptId?: IntFilter<"PurchasesOrExpenses"> | number
    authorId?: StringFilter<"PurchasesOrExpenses"> | string
    updatedAt?: DateTimeNullableFilter<"PurchasesOrExpenses"> | Date | string | null
    createdAt?: DateTimeFilter<"PurchasesOrExpenses"> | Date | string
    netAmount?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    netToPaid?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    manual?: BoolNullableFilter<"PurchasesOrExpenses"> | boolean | null
    taxPayer?: XOR<TaxPayerRelationFilter, TaxPayerWhereInput>
    author?: XOR<UsersRelationFilter, UsersWhereInput>
    concept?: XOR<ConceptsRelationFilter, ConceptsWhereInput>
    taxPayerType?: XOR<TaxPayerTypesRelationFilter, TaxPayerTypesWhereInput>
    paymentMethod?: XOR<PaymentsMethodsRelationFilter, PaymentsMethodsWhereInput>
    ncfType?: XOR<NcfsTypesRelationFilter, NcfsTypesWhereInput>
    ncfAffectType?: XOR<NcfsTypesNullableRelationFilter, NcfsTypesWhereInput> | null
    retentionTax?: XOR<RetentionTaxNullableRelationFilter, RetentionTaxWhereInput> | null
    retentionIsr?: XOR<RetentionIsrNullableRelationFilter, RetentionIsrWhereInput> | null
    costTaxStatus?: XOR<CostTaxStatusNullableRelationFilter, CostTaxStatusWhereInput> | null
  }

  export type PurchasesOrExpensesOrderByWithRelationInput = {
    id?: SortOrder
    rncOrId?: SortOrder
    ncf?: SortOrder
    ncfAffected?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    retentionDate?: SortOrderInput | SortOrder
    total?: SortOrder
    tax?: SortOrder
    costTax?: SortOrderInput | SortOrder
    taxPayerTypesId?: SortOrder
    paymentsMethodsId?: SortOrder
    ncfsTypesId?: SortOrder
    ncfsAffectTypeId?: SortOrderInput | SortOrder
    retentionTaxId?: SortOrderInput | SortOrder
    retentionIsrId?: SortOrderInput | SortOrder
    costTaxStatusId?: SortOrderInput | SortOrder
    conceptId?: SortOrder
    authorId?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    netAmount?: SortOrderInput | SortOrder
    retentionTaxValue?: SortOrderInput | SortOrder
    retentionIsrValue?: SortOrderInput | SortOrder
    netToPaid?: SortOrderInput | SortOrder
    taxForOvertaking?: SortOrderInput | SortOrder
    manual?: SortOrderInput | SortOrder
    taxPayer?: TaxPayerOrderByWithRelationInput
    author?: UsersOrderByWithRelationInput
    concept?: ConceptsOrderByWithRelationInput
    taxPayerType?: TaxPayerTypesOrderByWithRelationInput
    paymentMethod?: PaymentsMethodsOrderByWithRelationInput
    ncfType?: NcfsTypesOrderByWithRelationInput
    ncfAffectType?: NcfsTypesOrderByWithRelationInput
    retentionTax?: RetentionTaxOrderByWithRelationInput
    retentionIsr?: RetentionIsrOrderByWithRelationInput
    costTaxStatus?: CostTaxStatusOrderByWithRelationInput
  }

  export type PurchasesOrExpensesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchasesOrExpensesWhereInput | PurchasesOrExpensesWhereInput[]
    OR?: PurchasesOrExpensesWhereInput[]
    NOT?: PurchasesOrExpensesWhereInput | PurchasesOrExpensesWhereInput[]
    rncOrId?: StringFilter<"PurchasesOrExpenses"> | string
    ncf?: StringFilter<"PurchasesOrExpenses"> | string
    ncfAffected?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    issueDate?: DateTimeFilter<"PurchasesOrExpenses"> | Date | string
    retentionDate?: DateTimeNullableFilter<"PurchasesOrExpenses"> | Date | string | null
    total?: DecimalFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    costTax?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFilter<"PurchasesOrExpenses"> | number
    paymentsMethodsId?: StringFilter<"PurchasesOrExpenses"> | string
    ncfsTypesId?: StringFilter<"PurchasesOrExpenses"> | string
    ncfsAffectTypeId?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    retentionTaxId?: IntNullableFilter<"PurchasesOrExpenses"> | number | null
    retentionIsrId?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    costTaxStatusId?: IntNullableFilter<"PurchasesOrExpenses"> | number | null
    conceptId?: IntFilter<"PurchasesOrExpenses"> | number
    authorId?: StringFilter<"PurchasesOrExpenses"> | string
    updatedAt?: DateTimeNullableFilter<"PurchasesOrExpenses"> | Date | string | null
    createdAt?: DateTimeFilter<"PurchasesOrExpenses"> | Date | string
    netAmount?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    netToPaid?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    manual?: BoolNullableFilter<"PurchasesOrExpenses"> | boolean | null
    taxPayer?: XOR<TaxPayerRelationFilter, TaxPayerWhereInput>
    author?: XOR<UsersRelationFilter, UsersWhereInput>
    concept?: XOR<ConceptsRelationFilter, ConceptsWhereInput>
    taxPayerType?: XOR<TaxPayerTypesRelationFilter, TaxPayerTypesWhereInput>
    paymentMethod?: XOR<PaymentsMethodsRelationFilter, PaymentsMethodsWhereInput>
    ncfType?: XOR<NcfsTypesRelationFilter, NcfsTypesWhereInput>
    ncfAffectType?: XOR<NcfsTypesNullableRelationFilter, NcfsTypesWhereInput> | null
    retentionTax?: XOR<RetentionTaxNullableRelationFilter, RetentionTaxWhereInput> | null
    retentionIsr?: XOR<RetentionIsrNullableRelationFilter, RetentionIsrWhereInput> | null
    costTaxStatus?: XOR<CostTaxStatusNullableRelationFilter, CostTaxStatusWhereInput> | null
  }, "id" | "id">

  export type PurchasesOrExpensesOrderByWithAggregationInput = {
    id?: SortOrder
    rncOrId?: SortOrder
    ncf?: SortOrder
    ncfAffected?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    retentionDate?: SortOrderInput | SortOrder
    total?: SortOrder
    tax?: SortOrder
    costTax?: SortOrderInput | SortOrder
    taxPayerTypesId?: SortOrder
    paymentsMethodsId?: SortOrder
    ncfsTypesId?: SortOrder
    ncfsAffectTypeId?: SortOrderInput | SortOrder
    retentionTaxId?: SortOrderInput | SortOrder
    retentionIsrId?: SortOrderInput | SortOrder
    costTaxStatusId?: SortOrderInput | SortOrder
    conceptId?: SortOrder
    authorId?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    netAmount?: SortOrderInput | SortOrder
    retentionTaxValue?: SortOrderInput | SortOrder
    retentionIsrValue?: SortOrderInput | SortOrder
    netToPaid?: SortOrderInput | SortOrder
    taxForOvertaking?: SortOrderInput | SortOrder
    manual?: SortOrderInput | SortOrder
    _count?: PurchasesOrExpensesCountOrderByAggregateInput
    _avg?: PurchasesOrExpensesAvgOrderByAggregateInput
    _max?: PurchasesOrExpensesMaxOrderByAggregateInput
    _min?: PurchasesOrExpensesMinOrderByAggregateInput
    _sum?: PurchasesOrExpensesSumOrderByAggregateInput
  }

  export type PurchasesOrExpensesScalarWhereWithAggregatesInput = {
    AND?: PurchasesOrExpensesScalarWhereWithAggregatesInput | PurchasesOrExpensesScalarWhereWithAggregatesInput[]
    OR?: PurchasesOrExpensesScalarWhereWithAggregatesInput[]
    NOT?: PurchasesOrExpensesScalarWhereWithAggregatesInput | PurchasesOrExpensesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchasesOrExpenses"> | string
    rncOrId?: StringWithAggregatesFilter<"PurchasesOrExpenses"> | string
    ncf?: StringWithAggregatesFilter<"PurchasesOrExpenses"> | string
    ncfAffected?: StringNullableWithAggregatesFilter<"PurchasesOrExpenses"> | string | null
    issueDate?: DateTimeWithAggregatesFilter<"PurchasesOrExpenses"> | Date | string
    retentionDate?: DateTimeNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Date | string | null
    total?: DecimalWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    costTax?: DecimalNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntWithAggregatesFilter<"PurchasesOrExpenses"> | number
    paymentsMethodsId?: StringWithAggregatesFilter<"PurchasesOrExpenses"> | string
    ncfsTypesId?: StringWithAggregatesFilter<"PurchasesOrExpenses"> | string
    ncfsAffectTypeId?: StringNullableWithAggregatesFilter<"PurchasesOrExpenses"> | string | null
    retentionTaxId?: IntNullableWithAggregatesFilter<"PurchasesOrExpenses"> | number | null
    retentionIsrId?: StringNullableWithAggregatesFilter<"PurchasesOrExpenses"> | string | null
    costTaxStatusId?: IntNullableWithAggregatesFilter<"PurchasesOrExpenses"> | number | null
    conceptId?: IntWithAggregatesFilter<"PurchasesOrExpenses"> | number
    authorId?: StringWithAggregatesFilter<"PurchasesOrExpenses"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchasesOrExpenses"> | Date | string
    netAmount?: DecimalNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: DecimalNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: DecimalNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    netToPaid?: DecimalNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: DecimalNullableWithAggregatesFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    manual?: BoolNullableWithAggregatesFilter<"PurchasesOrExpenses"> | boolean | null
  }

  export type TaxPayerTypesWhereInput = {
    AND?: TaxPayerTypesWhereInput | TaxPayerTypesWhereInput[]
    OR?: TaxPayerTypesWhereInput[]
    NOT?: TaxPayerTypesWhereInput | TaxPayerTypesWhereInput[]
    id?: IntFilter<"TaxPayerTypes"> | number
    name?: StringFilter<"TaxPayerTypes"> | string
    createdAt?: DateTimeFilter<"TaxPayerTypes"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }

  export type TaxPayerTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type TaxPayerTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaxPayerTypesWhereInput | TaxPayerTypesWhereInput[]
    OR?: TaxPayerTypesWhereInput[]
    NOT?: TaxPayerTypesWhereInput | TaxPayerTypesWhereInput[]
    name?: StringFilter<"TaxPayerTypes"> | string
    createdAt?: DateTimeFilter<"TaxPayerTypes"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }, "id" | "id">

  export type TaxPayerTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: TaxPayerTypesCountOrderByAggregateInput
    _avg?: TaxPayerTypesAvgOrderByAggregateInput
    _max?: TaxPayerTypesMaxOrderByAggregateInput
    _min?: TaxPayerTypesMinOrderByAggregateInput
    _sum?: TaxPayerTypesSumOrderByAggregateInput
  }

  export type TaxPayerTypesScalarWhereWithAggregatesInput = {
    AND?: TaxPayerTypesScalarWhereWithAggregatesInput | TaxPayerTypesScalarWhereWithAggregatesInput[]
    OR?: TaxPayerTypesScalarWhereWithAggregatesInput[]
    NOT?: TaxPayerTypesScalarWhereWithAggregatesInput | TaxPayerTypesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaxPayerTypes"> | number
    name?: StringWithAggregatesFilter<"TaxPayerTypes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaxPayerTypes"> | Date | string
  }

  export type InvoiceTypeWhereInput = {
    AND?: InvoiceTypeWhereInput | InvoiceTypeWhereInput[]
    OR?: InvoiceTypeWhereInput[]
    NOT?: InvoiceTypeWhereInput | InvoiceTypeWhereInput[]
    id?: StringFilter<"InvoiceType"> | string
    name?: StringFilter<"InvoiceType"> | string
    createdAt?: DateTimeFilter<"InvoiceType"> | Date | string
    Concepts?: ConceptsListRelationFilter
  }

  export type InvoiceTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    Concepts?: ConceptsOrderByRelationAggregateInput
  }

  export type InvoiceTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceTypeWhereInput | InvoiceTypeWhereInput[]
    OR?: InvoiceTypeWhereInput[]
    NOT?: InvoiceTypeWhereInput | InvoiceTypeWhereInput[]
    name?: StringFilter<"InvoiceType"> | string
    createdAt?: DateTimeFilter<"InvoiceType"> | Date | string
    Concepts?: ConceptsListRelationFilter
  }, "id" | "id">

  export type InvoiceTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: InvoiceTypeCountOrderByAggregateInput
    _max?: InvoiceTypeMaxOrderByAggregateInput
    _min?: InvoiceTypeMinOrderByAggregateInput
  }

  export type InvoiceTypeScalarWhereWithAggregatesInput = {
    AND?: InvoiceTypeScalarWhereWithAggregatesInput | InvoiceTypeScalarWhereWithAggregatesInput[]
    OR?: InvoiceTypeScalarWhereWithAggregatesInput[]
    NOT?: InvoiceTypeScalarWhereWithAggregatesInput | InvoiceTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceType"> | string
    name?: StringWithAggregatesFilter<"InvoiceType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceType"> | Date | string
  }

  export type PaymentsMethodsWhereInput = {
    AND?: PaymentsMethodsWhereInput | PaymentsMethodsWhereInput[]
    OR?: PaymentsMethodsWhereInput[]
    NOT?: PaymentsMethodsWhereInput | PaymentsMethodsWhereInput[]
    id?: StringFilter<"PaymentsMethods"> | string
    name?: StringFilter<"PaymentsMethods"> | string
    createdAt?: DateTimeFilter<"PaymentsMethods"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }

  export type PaymentsMethodsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type PaymentsMethodsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentsMethodsWhereInput | PaymentsMethodsWhereInput[]
    OR?: PaymentsMethodsWhereInput[]
    NOT?: PaymentsMethodsWhereInput | PaymentsMethodsWhereInput[]
    name?: StringFilter<"PaymentsMethods"> | string
    createdAt?: DateTimeFilter<"PaymentsMethods"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }, "id" | "id">

  export type PaymentsMethodsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentsMethodsCountOrderByAggregateInput
    _max?: PaymentsMethodsMaxOrderByAggregateInput
    _min?: PaymentsMethodsMinOrderByAggregateInput
  }

  export type PaymentsMethodsScalarWhereWithAggregatesInput = {
    AND?: PaymentsMethodsScalarWhereWithAggregatesInput | PaymentsMethodsScalarWhereWithAggregatesInput[]
    OR?: PaymentsMethodsScalarWhereWithAggregatesInput[]
    NOT?: PaymentsMethodsScalarWhereWithAggregatesInput | PaymentsMethodsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentsMethods"> | string
    name?: StringWithAggregatesFilter<"PaymentsMethods"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentsMethods"> | Date | string
  }

  export type NcfsTypesWhereInput = {
    AND?: NcfsTypesWhereInput | NcfsTypesWhereInput[]
    OR?: NcfsTypesWhereInput[]
    NOT?: NcfsTypesWhereInput | NcfsTypesWhereInput[]
    id?: StringFilter<"NcfsTypes"> | string
    name?: StringFilter<"NcfsTypes"> | string
    serialId?: IntFilter<"NcfsTypes"> | number
    createdAt?: DateTimeFilter<"NcfsTypes"> | Date | string
    serial?: XOR<SerialRelationFilter, SerialWhereInput>
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesListRelationFilter
  }

  export type NcfsTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    serialId?: SortOrder
    createdAt?: SortOrder
    serial?: SerialOrderByWithRelationInput
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type NcfsTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NcfsTypesWhereInput | NcfsTypesWhereInput[]
    OR?: NcfsTypesWhereInput[]
    NOT?: NcfsTypesWhereInput | NcfsTypesWhereInput[]
    name?: StringFilter<"NcfsTypes"> | string
    serialId?: IntFilter<"NcfsTypes"> | number
    createdAt?: DateTimeFilter<"NcfsTypes"> | Date | string
    serial?: XOR<SerialRelationFilter, SerialWhereInput>
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesListRelationFilter
  }, "id" | "id">

  export type NcfsTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    serialId?: SortOrder
    createdAt?: SortOrder
    _count?: NcfsTypesCountOrderByAggregateInput
    _avg?: NcfsTypesAvgOrderByAggregateInput
    _max?: NcfsTypesMaxOrderByAggregateInput
    _min?: NcfsTypesMinOrderByAggregateInput
    _sum?: NcfsTypesSumOrderByAggregateInput
  }

  export type NcfsTypesScalarWhereWithAggregatesInput = {
    AND?: NcfsTypesScalarWhereWithAggregatesInput | NcfsTypesScalarWhereWithAggregatesInput[]
    OR?: NcfsTypesScalarWhereWithAggregatesInput[]
    NOT?: NcfsTypesScalarWhereWithAggregatesInput | NcfsTypesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NcfsTypes"> | string
    name?: StringWithAggregatesFilter<"NcfsTypes"> | string
    serialId?: IntWithAggregatesFilter<"NcfsTypes"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NcfsTypes"> | Date | string
  }

  export type RetentionTaxWhereInput = {
    AND?: RetentionTaxWhereInput | RetentionTaxWhereInput[]
    OR?: RetentionTaxWhereInput[]
    NOT?: RetentionTaxWhereInput | RetentionTaxWhereInput[]
    id?: IntFilter<"RetentionTax"> | number
    name?: StringFilter<"RetentionTax"> | string
    rate?: DecimalFilter<"RetentionTax"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"RetentionTax"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }

  export type RetentionTaxOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type RetentionTaxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RetentionTaxWhereInput | RetentionTaxWhereInput[]
    OR?: RetentionTaxWhereInput[]
    NOT?: RetentionTaxWhereInput | RetentionTaxWhereInput[]
    rate?: DecimalFilter<"RetentionTax"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"RetentionTax"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }, "name" | "id" | "name">

  export type RetentionTaxOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    _count?: RetentionTaxCountOrderByAggregateInput
    _avg?: RetentionTaxAvgOrderByAggregateInput
    _max?: RetentionTaxMaxOrderByAggregateInput
    _min?: RetentionTaxMinOrderByAggregateInput
    _sum?: RetentionTaxSumOrderByAggregateInput
  }

  export type RetentionTaxScalarWhereWithAggregatesInput = {
    AND?: RetentionTaxScalarWhereWithAggregatesInput | RetentionTaxScalarWhereWithAggregatesInput[]
    OR?: RetentionTaxScalarWhereWithAggregatesInput[]
    NOT?: RetentionTaxScalarWhereWithAggregatesInput | RetentionTaxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RetentionTax"> | number
    name?: StringWithAggregatesFilter<"RetentionTax"> | string
    rate?: DecimalWithAggregatesFilter<"RetentionTax"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"RetentionTax"> | Date | string
  }

  export type RetentionIsrWhereInput = {
    AND?: RetentionIsrWhereInput | RetentionIsrWhereInput[]
    OR?: RetentionIsrWhereInput[]
    NOT?: RetentionIsrWhereInput | RetentionIsrWhereInput[]
    id?: StringFilter<"RetentionIsr"> | string
    name?: StringFilter<"RetentionIsr"> | string
    rate?: DecimalFilter<"RetentionIsr"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"RetentionIsr"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }

  export type RetentionIsrOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type RetentionIsrWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RetentionIsrWhereInput | RetentionIsrWhereInput[]
    OR?: RetentionIsrWhereInput[]
    NOT?: RetentionIsrWhereInput | RetentionIsrWhereInput[]
    rate?: DecimalFilter<"RetentionIsr"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"RetentionIsr"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }, "id" | "id" | "name">

  export type RetentionIsrOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    _count?: RetentionIsrCountOrderByAggregateInput
    _avg?: RetentionIsrAvgOrderByAggregateInput
    _max?: RetentionIsrMaxOrderByAggregateInput
    _min?: RetentionIsrMinOrderByAggregateInput
    _sum?: RetentionIsrSumOrderByAggregateInput
  }

  export type RetentionIsrScalarWhereWithAggregatesInput = {
    AND?: RetentionIsrScalarWhereWithAggregatesInput | RetentionIsrScalarWhereWithAggregatesInput[]
    OR?: RetentionIsrScalarWhereWithAggregatesInput[]
    NOT?: RetentionIsrScalarWhereWithAggregatesInput | RetentionIsrScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RetentionIsr"> | string
    name?: StringWithAggregatesFilter<"RetentionIsr"> | string
    rate?: DecimalWithAggregatesFilter<"RetentionIsr"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"RetentionIsr"> | Date | string
  }

  export type CostTaxStatusWhereInput = {
    AND?: CostTaxStatusWhereInput | CostTaxStatusWhereInput[]
    OR?: CostTaxStatusWhereInput[]
    NOT?: CostTaxStatusWhereInput | CostTaxStatusWhereInput[]
    id?: IntFilter<"CostTaxStatus"> | number
    name?: StringFilter<"CostTaxStatus"> | string
    createdAt?: DateTimeFilter<"CostTaxStatus"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }

  export type CostTaxStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
  }

  export type CostTaxStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CostTaxStatusWhereInput | CostTaxStatusWhereInput[]
    OR?: CostTaxStatusWhereInput[]
    NOT?: CostTaxStatusWhereInput | CostTaxStatusWhereInput[]
    name?: StringFilter<"CostTaxStatus"> | string
    createdAt?: DateTimeFilter<"CostTaxStatus"> | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
  }, "id" | "id">

  export type CostTaxStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: CostTaxStatusCountOrderByAggregateInput
    _avg?: CostTaxStatusAvgOrderByAggregateInput
    _max?: CostTaxStatusMaxOrderByAggregateInput
    _min?: CostTaxStatusMinOrderByAggregateInput
    _sum?: CostTaxStatusSumOrderByAggregateInput
  }

  export type CostTaxStatusScalarWhereWithAggregatesInput = {
    AND?: CostTaxStatusScalarWhereWithAggregatesInput | CostTaxStatusScalarWhereWithAggregatesInput[]
    OR?: CostTaxStatusScalarWhereWithAggregatesInput[]
    NOT?: CostTaxStatusScalarWhereWithAggregatesInput | CostTaxStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CostTaxStatus"> | number
    name?: StringWithAggregatesFilter<"CostTaxStatus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CostTaxStatus"> | Date | string
  }

  export type TaxPayerWhereInput = {
    AND?: TaxPayerWhereInput | TaxPayerWhereInput[]
    OR?: TaxPayerWhereInput[]
    NOT?: TaxPayerWhereInput | TaxPayerWhereInput[]
    id?: StringFilter<"TaxPayer"> | string
    name?: StringNullableFilter<"TaxPayer"> | string | null
    tradeName?: StringNullableFilter<"TaxPayer"> | string | null
    about?: StringNullableFilter<"TaxPayer"> | string | null
    col1?: StringNullableFilter<"TaxPayer"> | string | null
    col2?: StringNullableFilter<"TaxPayer"> | string | null
    col3?: StringNullableFilter<"TaxPayer"> | string | null
    col4?: StringNullableFilter<"TaxPayer"> | string | null
    createdAt?: StringNullableFilter<"TaxPayer"> | string | null
    state?: StringNullableFilter<"TaxPayer"> | string | null
    status?: StringNullableFilter<"TaxPayer"> | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
    Requests?: RequestsListRelationFilter
    Users?: UsersListRelationFilter
  }

  export type TaxPayerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    tradeName?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    col1?: SortOrderInput | SortOrder
    col2?: SortOrderInput | SortOrder
    col3?: SortOrderInput | SortOrder
    col4?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    PurchasesOrExpenses?: PurchasesOrExpensesOrderByRelationAggregateInput
    Requests?: RequestsOrderByRelationAggregateInput
    Users?: UsersOrderByRelationAggregateInput
  }

  export type TaxPayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxPayerWhereInput | TaxPayerWhereInput[]
    OR?: TaxPayerWhereInput[]
    NOT?: TaxPayerWhereInput | TaxPayerWhereInput[]
    name?: StringNullableFilter<"TaxPayer"> | string | null
    tradeName?: StringNullableFilter<"TaxPayer"> | string | null
    about?: StringNullableFilter<"TaxPayer"> | string | null
    col1?: StringNullableFilter<"TaxPayer"> | string | null
    col2?: StringNullableFilter<"TaxPayer"> | string | null
    col3?: StringNullableFilter<"TaxPayer"> | string | null
    col4?: StringNullableFilter<"TaxPayer"> | string | null
    createdAt?: StringNullableFilter<"TaxPayer"> | string | null
    state?: StringNullableFilter<"TaxPayer"> | string | null
    status?: StringNullableFilter<"TaxPayer"> | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesListRelationFilter
    Requests?: RequestsListRelationFilter
    Users?: UsersListRelationFilter
  }, "id" | "id">

  export type TaxPayerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    tradeName?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    col1?: SortOrderInput | SortOrder
    col2?: SortOrderInput | SortOrder
    col3?: SortOrderInput | SortOrder
    col4?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: TaxPayerCountOrderByAggregateInput
    _max?: TaxPayerMaxOrderByAggregateInput
    _min?: TaxPayerMinOrderByAggregateInput
  }

  export type TaxPayerScalarWhereWithAggregatesInput = {
    AND?: TaxPayerScalarWhereWithAggregatesInput | TaxPayerScalarWhereWithAggregatesInput[]
    OR?: TaxPayerScalarWhereWithAggregatesInput[]
    NOT?: TaxPayerScalarWhereWithAggregatesInput | TaxPayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxPayer"> | string
    name?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    tradeName?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    about?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    col1?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    col2?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    col3?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    col4?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    createdAt?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    state?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
    status?: StringNullableWithAggregatesFilter<"TaxPayer"> | string | null
  }

  export type DocumentTypeWhereInput = {
    AND?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    OR?: DocumentTypeWhereInput[]
    NOT?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    id?: IntFilter<"DocumentType"> | number
    name?: StringFilter<"DocumentType"> | string
    Documents?: DocumentsListRelationFilter
  }

  export type DocumentTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Documents?: DocumentsOrderByRelationAggregateInput
  }

  export type DocumentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    OR?: DocumentTypeWhereInput[]
    NOT?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    name?: StringFilter<"DocumentType"> | string
    Documents?: DocumentsListRelationFilter
  }, "id" | "id">

  export type DocumentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DocumentTypeCountOrderByAggregateInput
    _avg?: DocumentTypeAvgOrderByAggregateInput
    _max?: DocumentTypeMaxOrderByAggregateInput
    _min?: DocumentTypeMinOrderByAggregateInput
    _sum?: DocumentTypeSumOrderByAggregateInput
  }

  export type DocumentTypeScalarWhereWithAggregatesInput = {
    AND?: DocumentTypeScalarWhereWithAggregatesInput | DocumentTypeScalarWhereWithAggregatesInput[]
    OR?: DocumentTypeScalarWhereWithAggregatesInput[]
    NOT?: DocumentTypeScalarWhereWithAggregatesInput | DocumentTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DocumentType"> | number
    name?: StringWithAggregatesFilter<"DocumentType"> | string
  }

  export type EmailVerificationsWhereInput = {
    AND?: EmailVerificationsWhereInput | EmailVerificationsWhereInput[]
    OR?: EmailVerificationsWhereInput[]
    NOT?: EmailVerificationsWhereInput | EmailVerificationsWhereInput[]
    id?: IntFilter<"EmailVerifications"> | number
    email?: StringFilter<"EmailVerifications"> | string
    isVerify?: BoolFilter<"EmailVerifications"> | boolean
    createdAt?: DateTimeFilter<"EmailVerifications"> | Date | string
    code?: StringNullableFilter<"EmailVerifications"> | string | null
    expirationDate?: DateTimeNullableFilter<"EmailVerifications"> | Date | string | null
  }

  export type EmailVerificationsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    isVerify?: SortOrder
    createdAt?: SortOrder
    code?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
  }

  export type EmailVerificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: EmailVerificationsWhereInput | EmailVerificationsWhereInput[]
    OR?: EmailVerificationsWhereInput[]
    NOT?: EmailVerificationsWhereInput | EmailVerificationsWhereInput[]
    isVerify?: BoolFilter<"EmailVerifications"> | boolean
    createdAt?: DateTimeFilter<"EmailVerifications"> | Date | string
    code?: StringNullableFilter<"EmailVerifications"> | string | null
    expirationDate?: DateTimeNullableFilter<"EmailVerifications"> | Date | string | null
  }, "id" | "email">

  export type EmailVerificationsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    isVerify?: SortOrder
    createdAt?: SortOrder
    code?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    _count?: EmailVerificationsCountOrderByAggregateInput
    _avg?: EmailVerificationsAvgOrderByAggregateInput
    _max?: EmailVerificationsMaxOrderByAggregateInput
    _min?: EmailVerificationsMinOrderByAggregateInput
    _sum?: EmailVerificationsSumOrderByAggregateInput
  }

  export type EmailVerificationsScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationsScalarWhereWithAggregatesInput | EmailVerificationsScalarWhereWithAggregatesInput[]
    OR?: EmailVerificationsScalarWhereWithAggregatesInput[]
    NOT?: EmailVerificationsScalarWhereWithAggregatesInput | EmailVerificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailVerifications"> | number
    email?: StringWithAggregatesFilter<"EmailVerifications"> | string
    isVerify?: BoolWithAggregatesFilter<"EmailVerifications"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerifications"> | Date | string
    code?: StringNullableWithAggregatesFilter<"EmailVerifications"> | string | null
    expirationDate?: DateTimeNullableWithAggregatesFilter<"EmailVerifications"> | Date | string | null
  }

  export type UsersCreateInput = {
    id?: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    taxPayer: TaxPayerCreateNestedOneWithoutUsersInput
    Concepts?: ConceptsCreateNestedManyWithoutAuthorInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutAuthorInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    Concepts?: ConceptsUncheckedCreateNestedManyWithoutAuthorInput
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxPayer?: TaxPayerUpdateOneRequiredWithoutUsersNestedInput
    Concepts?: ConceptsUpdateManyWithoutAuthorNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutAuthorNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concepts?: ConceptsUncheckedUpdateManyWithoutAuthorNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    username: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerialCreateInput = {
    id: number
    code: string
    NcfsTypes?: NcfsTypesCreateNestedManyWithoutSerialInput
  }

  export type SerialUncheckedCreateInput = {
    id: number
    code: string
    NcfsTypes?: NcfsTypesUncheckedCreateNestedManyWithoutSerialInput
  }

  export type SerialUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    NcfsTypes?: NcfsTypesUpdateManyWithoutSerialNestedInput
  }

  export type SerialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    NcfsTypes?: NcfsTypesUncheckedUpdateManyWithoutSerialNestedInput
  }

  export type SerialCreateManyInput = {
    id: number
    code: string
  }

  export type SerialUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type SerialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type ClassificationTypeCreateInput = {
    name: string
    Concepts?: ConceptsCreateNestedManyWithoutClassificationTypeInput
  }

  export type ClassificationTypeUncheckedCreateInput = {
    id?: number
    name: string
    Concepts?: ConceptsUncheckedCreateNestedManyWithoutClassificationTypeInput
  }

  export type ClassificationTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Concepts?: ConceptsUpdateManyWithoutClassificationTypeNestedInput
  }

  export type ClassificationTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Concepts?: ConceptsUncheckedUpdateManyWithoutClassificationTypeNestedInput
  }

  export type ClassificationTypeCreateManyInput = {
    id?: number
    name: string
  }

  export type ClassificationTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ClassificationTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConceptsCreateInput = {
    name: string
    classificationType: ClassificationTypeCreateNestedOneWithoutConceptsInput
    invoiceType: InvoiceTypeCreateNestedOneWithoutConceptsInput
    author: UsersCreateNestedOneWithoutConceptsInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutConceptInput
  }

  export type ConceptsUncheckedCreateInput = {
    id?: number
    name: string
    authorId: string
    invoiceTypeId: string
    classificationTypeId: number
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    classificationType?: ClassificationTypeUpdateOneRequiredWithoutConceptsNestedInput
    invoiceType?: InvoiceTypeUpdateOneRequiredWithoutConceptsNestedInput
    author?: UsersUpdateOneRequiredWithoutConceptsNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    invoiceTypeId?: StringFieldUpdateOperationsInput | string
    classificationTypeId?: IntFieldUpdateOperationsInput | number
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsCreateManyInput = {
    id?: number
    name: string
    authorId: string
    invoiceTypeId: string
    classificationTypeId: number
  }

  export type ConceptsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConceptsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    invoiceTypeId?: StringFieldUpdateOperationsInput | string
    classificationTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type RequestStatusCreateInput = {
    name: string
    createdAt?: Date | string
    Requests?: RequestsCreateNestedManyWithoutStatusInput
  }

  export type RequestStatusUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    Requests?: RequestsUncheckedCreateNestedManyWithoutStatusInput
  }

  export type RequestStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requests?: RequestsUpdateManyWithoutStatusNestedInput
  }

  export type RequestStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Requests?: RequestsUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type RequestStatusCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type RequestStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestsCreateInput = {
    id?: string
    requestNum?: number
    email: string
    createdAt?: Date | string
    taxPayer: TaxPayerCreateNestedOneWithoutRequestsInput
    status: RequestStatusCreateNestedOneWithoutRequestsInput
    Documents?: DocumentsCreateNestedManyWithoutRequestInput
  }

  export type RequestsUncheckedCreateInput = {
    id?: string
    requestNum?: number
    username: string
    email: string
    createdAt?: Date | string
    requestStatusId: number
    Documents?: DocumentsUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxPayer?: TaxPayerUpdateOneRequiredWithoutRequestsNestedInput
    status?: RequestStatusUpdateOneRequiredWithoutRequestsNestedInput
    Documents?: DocumentsUpdateManyWithoutRequestNestedInput
  }

  export type RequestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestStatusId?: IntFieldUpdateOperationsInput | number
    Documents?: DocumentsUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestsCreateManyInput = {
    id?: string
    requestNum?: number
    username: string
    email: string
    createdAt?: Date | string
    requestStatusId: number
  }

  export type RequestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentsCreateInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    createdAt?: Date | string
    request: RequestsCreateNestedOneWithoutDocumentsInput
    documentType: DocumentTypeCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    documentTypeId: number
    createdAt?: Date | string
    requestId: string
  }

  export type DocumentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: RequestsUpdateOneRequiredWithoutDocumentsNestedInput
    documentType?: DocumentTypeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentsCreateManyInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    documentTypeId: number
    createdAt?: Date | string
    requestId: string
  }

  export type DocumentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchasesOrExpensesCreateInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesCreateManyInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TaxPayerTypesCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutTaxPayerTypeInput
  }

  export type TaxPayerTypesUncheckedCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutTaxPayerTypeInput
  }

  export type TaxPayerTypesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutTaxPayerTypeNestedInput
  }

  export type TaxPayerTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerTypeNestedInput
  }

  export type TaxPayerTypesCreateManyInput = {
    id: number
    name: string
    createdAt?: Date | string
  }

  export type TaxPayerTypesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPayerTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceTypeCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    Concepts?: ConceptsCreateNestedManyWithoutInvoiceTypeInput
  }

  export type InvoiceTypeUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    Concepts?: ConceptsUncheckedCreateNestedManyWithoutInvoiceTypeInput
  }

  export type InvoiceTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concepts?: ConceptsUpdateManyWithoutInvoiceTypeNestedInput
  }

  export type InvoiceTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concepts?: ConceptsUncheckedUpdateManyWithoutInvoiceTypeNestedInput
  }

  export type InvoiceTypeCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string
  }

  export type InvoiceTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsMethodsCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentsMethodsUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentsMethodsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentsMethodsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentsMethodsCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string
  }

  export type PaymentsMethodsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsMethodsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NcfsTypesCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    serial: SerialCreateNestedOneWithoutNcfsTypesInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutNcfTypeInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesCreateNestedManyWithoutNcfAffectTypeInput
  }

  export type NcfsTypesUncheckedCreateInput = {
    id: string
    name: string
    serialId: number
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfTypeInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfAffectTypeInput
  }

  export type NcfsTypesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serial?: SerialUpdateOneRequiredWithoutNcfsTypesNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutNcfTypeNestedInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUpdateManyWithoutNcfAffectTypeNestedInput
  }

  export type NcfsTypesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    serialId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutNcfTypeNestedInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUncheckedUpdateManyWithoutNcfAffectTypeNestedInput
  }

  export type NcfsTypesCreateManyInput = {
    id: string
    name: string
    serialId: number
    createdAt?: Date | string
  }

  export type NcfsTypesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NcfsTypesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    serialId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetentionTaxCreateInput = {
    id?: number
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutRetentionTaxInput
  }

  export type RetentionTaxUncheckedCreateInput = {
    id?: number
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutRetentionTaxInput
  }

  export type RetentionTaxUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutRetentionTaxNestedInput
  }

  export type RetentionTaxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionTaxNestedInput
  }

  export type RetentionTaxCreateManyInput = {
    id?: number
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type RetentionTaxUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetentionTaxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetentionIsrCreateInput = {
    id: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutRetentionIsrInput
  }

  export type RetentionIsrUncheckedCreateInput = {
    id: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutRetentionIsrInput
  }

  export type RetentionIsrUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutRetentionIsrNestedInput
  }

  export type RetentionIsrUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionIsrNestedInput
  }

  export type RetentionIsrCreateManyInput = {
    id: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type RetentionIsrUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetentionIsrUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostTaxStatusCreateInput = {
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutCostTaxStatusInput
  }

  export type CostTaxStatusUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutCostTaxStatusInput
  }

  export type CostTaxStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutCostTaxStatusNestedInput
  }

  export type CostTaxStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutCostTaxStatusNestedInput
  }

  export type CostTaxStatusCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type CostTaxStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostTaxStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPayerCreateInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutTaxPayerInput
    Requests?: RequestsCreateNestedManyWithoutTaxPayerInput
    Users?: UsersCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerUncheckedCreateInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutTaxPayerInput
    Requests?: RequestsUncheckedCreateNestedManyWithoutTaxPayerInput
    Users?: UsersUncheckedCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutTaxPayerNestedInput
    Requests?: RequestsUpdateManyWithoutTaxPayerNestedInput
    Users?: UsersUpdateManyWithoutTaxPayerNestedInput
  }

  export type TaxPayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerNestedInput
    Requests?: RequestsUncheckedUpdateManyWithoutTaxPayerNestedInput
    Users?: UsersUncheckedUpdateManyWithoutTaxPayerNestedInput
  }

  export type TaxPayerCreateManyInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
  }

  export type TaxPayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaxPayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentTypeCreateInput = {
    name: string
    Documents?: DocumentsCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUncheckedCreateInput = {
    id?: number
    name: string
    Documents?: DocumentsUncheckedCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Documents?: DocumentsUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Documents?: DocumentsUncheckedUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeCreateManyInput = {
    id?: number
    name: string
  }

  export type DocumentTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EmailVerificationsCreateInput = {
    email: string
    isVerify?: boolean
    createdAt?: Date | string
    code?: string | null
    expirationDate?: Date | string | null
  }

  export type EmailVerificationsUncheckedCreateInput = {
    id?: number
    email: string
    isVerify?: boolean
    createdAt?: Date | string
    code?: string | null
    expirationDate?: Date | string | null
  }

  export type EmailVerificationsUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailVerificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailVerificationsCreateManyInput = {
    id?: number
    email: string
    isVerify?: boolean
    createdAt?: Date | string
    code?: string | null
    expirationDate?: Date | string | null
  }

  export type EmailVerificationsUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailVerificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    isVerify?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TaxPayerRelationFilter = {
    is?: TaxPayerWhereInput
    isNot?: TaxPayerWhereInput
  }

  export type ConceptsListRelationFilter = {
    every?: ConceptsWhereInput
    some?: ConceptsWhereInput
    none?: ConceptsWhereInput
  }

  export type PurchasesOrExpensesListRelationFilter = {
    every?: PurchasesOrExpensesWhereInput
    some?: PurchasesOrExpensesWhereInput
    none?: PurchasesOrExpensesWhereInput
  }

  export type ConceptsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasesOrExpensesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    passwordChangeMode?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    passwordChangeMode?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    passwordChangeMode?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NcfsTypesListRelationFilter = {
    every?: NcfsTypesWhereInput
    some?: NcfsTypesWhereInput
    none?: NcfsTypesWhereInput
  }

  export type NcfsTypesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SerialCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
  }

  export type SerialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SerialMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
  }

  export type SerialMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
  }

  export type SerialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ClassificationTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ClassificationTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClassificationTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ClassificationTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ClassificationTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClassificationTypeRelationFilter = {
    is?: ClassificationTypeWhereInput
    isNot?: ClassificationTypeWhereInput
  }

  export type InvoiceTypeRelationFilter = {
    is?: InvoiceTypeWhereInput
    isNot?: InvoiceTypeWhereInput
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type ConceptsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    invoiceTypeId?: SortOrder
    classificationTypeId?: SortOrder
  }

  export type ConceptsAvgOrderByAggregateInput = {
    id?: SortOrder
    classificationTypeId?: SortOrder
  }

  export type ConceptsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    invoiceTypeId?: SortOrder
    classificationTypeId?: SortOrder
  }

  export type ConceptsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    authorId?: SortOrder
    invoiceTypeId?: SortOrder
    classificationTypeId?: SortOrder
  }

  export type ConceptsSumOrderByAggregateInput = {
    id?: SortOrder
    classificationTypeId?: SortOrder
  }

  export type RequestsListRelationFilter = {
    every?: RequestsWhereInput
    some?: RequestsWhereInput
    none?: RequestsWhereInput
  }

  export type RequestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RequestStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RequestStatusRelationFilter = {
    is?: RequestStatusWhereInput
    isNot?: RequestStatusWhereInput
  }

  export type DocumentsListRelationFilter = {
    every?: DocumentsWhereInput
    some?: DocumentsWhereInput
    none?: DocumentsWhereInput
  }

  export type DocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestsCountOrderByAggregateInput = {
    id?: SortOrder
    requestNum?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    requestStatusId?: SortOrder
  }

  export type RequestsAvgOrderByAggregateInput = {
    requestNum?: SortOrder
    requestStatusId?: SortOrder
  }

  export type RequestsMaxOrderByAggregateInput = {
    id?: SortOrder
    requestNum?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    requestStatusId?: SortOrder
  }

  export type RequestsMinOrderByAggregateInput = {
    id?: SortOrder
    requestNum?: SortOrder
    username?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    requestStatusId?: SortOrder
  }

  export type RequestsSumOrderByAggregateInput = {
    requestNum?: SortOrder
    requestStatusId?: SortOrder
  }

  export type RequestsRelationFilter = {
    is?: RequestsWhereInput
    isNot?: RequestsWhereInput
  }

  export type DocumentTypeRelationFilter = {
    is?: DocumentTypeWhereInput
    isNot?: DocumentTypeWhereInput
  }

  export type DocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    downloadURL?: SortOrder
    fileFormatType?: SortOrder
    documentTypeId?: SortOrder
    createdAt?: SortOrder
    requestId?: SortOrder
  }

  export type DocumentsAvgOrderByAggregateInput = {
    documentTypeId?: SortOrder
  }

  export type DocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    downloadURL?: SortOrder
    fileFormatType?: SortOrder
    documentTypeId?: SortOrder
    createdAt?: SortOrder
    requestId?: SortOrder
  }

  export type DocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    downloadURL?: SortOrder
    fileFormatType?: SortOrder
    documentTypeId?: SortOrder
    createdAt?: SortOrder
    requestId?: SortOrder
  }

  export type DocumentsSumOrderByAggregateInput = {
    documentTypeId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ConceptsRelationFilter = {
    is?: ConceptsWhereInput
    isNot?: ConceptsWhereInput
  }

  export type TaxPayerTypesRelationFilter = {
    is?: TaxPayerTypesWhereInput
    isNot?: TaxPayerTypesWhereInput
  }

  export type PaymentsMethodsRelationFilter = {
    is?: PaymentsMethodsWhereInput
    isNot?: PaymentsMethodsWhereInput
  }

  export type NcfsTypesRelationFilter = {
    is?: NcfsTypesWhereInput
    isNot?: NcfsTypesWhereInput
  }

  export type NcfsTypesNullableRelationFilter = {
    is?: NcfsTypesWhereInput | null
    isNot?: NcfsTypesWhereInput | null
  }

  export type RetentionTaxNullableRelationFilter = {
    is?: RetentionTaxWhereInput | null
    isNot?: RetentionTaxWhereInput | null
  }

  export type RetentionIsrNullableRelationFilter = {
    is?: RetentionIsrWhereInput | null
    isNot?: RetentionIsrWhereInput | null
  }

  export type CostTaxStatusNullableRelationFilter = {
    is?: CostTaxStatusWhereInput | null
    isNot?: CostTaxStatusWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PurchasesOrExpensesCountOrderByAggregateInput = {
    id?: SortOrder
    rncOrId?: SortOrder
    ncf?: SortOrder
    ncfAffected?: SortOrder
    issueDate?: SortOrder
    retentionDate?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    costTax?: SortOrder
    taxPayerTypesId?: SortOrder
    paymentsMethodsId?: SortOrder
    ncfsTypesId?: SortOrder
    ncfsAffectTypeId?: SortOrder
    retentionTaxId?: SortOrder
    retentionIsrId?: SortOrder
    costTaxStatusId?: SortOrder
    conceptId?: SortOrder
    authorId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    netAmount?: SortOrder
    retentionTaxValue?: SortOrder
    retentionIsrValue?: SortOrder
    netToPaid?: SortOrder
    taxForOvertaking?: SortOrder
    manual?: SortOrder
  }

  export type PurchasesOrExpensesAvgOrderByAggregateInput = {
    total?: SortOrder
    tax?: SortOrder
    costTax?: SortOrder
    taxPayerTypesId?: SortOrder
    retentionTaxId?: SortOrder
    costTaxStatusId?: SortOrder
    conceptId?: SortOrder
    netAmount?: SortOrder
    retentionTaxValue?: SortOrder
    retentionIsrValue?: SortOrder
    netToPaid?: SortOrder
    taxForOvertaking?: SortOrder
  }

  export type PurchasesOrExpensesMaxOrderByAggregateInput = {
    id?: SortOrder
    rncOrId?: SortOrder
    ncf?: SortOrder
    ncfAffected?: SortOrder
    issueDate?: SortOrder
    retentionDate?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    costTax?: SortOrder
    taxPayerTypesId?: SortOrder
    paymentsMethodsId?: SortOrder
    ncfsTypesId?: SortOrder
    ncfsAffectTypeId?: SortOrder
    retentionTaxId?: SortOrder
    retentionIsrId?: SortOrder
    costTaxStatusId?: SortOrder
    conceptId?: SortOrder
    authorId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    netAmount?: SortOrder
    retentionTaxValue?: SortOrder
    retentionIsrValue?: SortOrder
    netToPaid?: SortOrder
    taxForOvertaking?: SortOrder
    manual?: SortOrder
  }

  export type PurchasesOrExpensesMinOrderByAggregateInput = {
    id?: SortOrder
    rncOrId?: SortOrder
    ncf?: SortOrder
    ncfAffected?: SortOrder
    issueDate?: SortOrder
    retentionDate?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    costTax?: SortOrder
    taxPayerTypesId?: SortOrder
    paymentsMethodsId?: SortOrder
    ncfsTypesId?: SortOrder
    ncfsAffectTypeId?: SortOrder
    retentionTaxId?: SortOrder
    retentionIsrId?: SortOrder
    costTaxStatusId?: SortOrder
    conceptId?: SortOrder
    authorId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    netAmount?: SortOrder
    retentionTaxValue?: SortOrder
    retentionIsrValue?: SortOrder
    netToPaid?: SortOrder
    taxForOvertaking?: SortOrder
    manual?: SortOrder
  }

  export type PurchasesOrExpensesSumOrderByAggregateInput = {
    total?: SortOrder
    tax?: SortOrder
    costTax?: SortOrder
    taxPayerTypesId?: SortOrder
    retentionTaxId?: SortOrder
    costTaxStatusId?: SortOrder
    conceptId?: SortOrder
    netAmount?: SortOrder
    retentionTaxValue?: SortOrder
    retentionIsrValue?: SortOrder
    netToPaid?: SortOrder
    taxForOvertaking?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TaxPayerTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TaxPayerTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TaxPayerTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TaxPayerTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TaxPayerTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InvoiceTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentsMethodsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentsMethodsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentsMethodsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type SerialRelationFilter = {
    is?: SerialWhereInput
    isNot?: SerialWhereInput
  }

  export type NcfsTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serialId?: SortOrder
    createdAt?: SortOrder
  }

  export type NcfsTypesAvgOrderByAggregateInput = {
    serialId?: SortOrder
  }

  export type NcfsTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serialId?: SortOrder
    createdAt?: SortOrder
  }

  export type NcfsTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serialId?: SortOrder
    createdAt?: SortOrder
  }

  export type NcfsTypesSumOrderByAggregateInput = {
    serialId?: SortOrder
  }

  export type RetentionTaxCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
  }

  export type RetentionTaxAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
  }

  export type RetentionTaxMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
  }

  export type RetentionTaxMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
  }

  export type RetentionTaxSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
  }

  export type RetentionIsrCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
  }

  export type RetentionIsrAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type RetentionIsrMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
  }

  export type RetentionIsrMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
  }

  export type RetentionIsrSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type CostTaxStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CostTaxStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CostTaxStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CostTaxStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CostTaxStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxPayerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tradeName?: SortOrder
    about?: SortOrder
    col1?: SortOrder
    col2?: SortOrder
    col3?: SortOrder
    col4?: SortOrder
    createdAt?: SortOrder
    state?: SortOrder
    status?: SortOrder
  }

  export type TaxPayerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tradeName?: SortOrder
    about?: SortOrder
    col1?: SortOrder
    col2?: SortOrder
    col3?: SortOrder
    col4?: SortOrder
    createdAt?: SortOrder
    state?: SortOrder
    status?: SortOrder
  }

  export type TaxPayerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tradeName?: SortOrder
    about?: SortOrder
    col1?: SortOrder
    col2?: SortOrder
    col3?: SortOrder
    col4?: SortOrder
    createdAt?: SortOrder
    state?: SortOrder
    status?: SortOrder
  }

  export type DocumentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DocumentTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DocumentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DocumentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DocumentTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailVerificationsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    isVerify?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
  }

  export type EmailVerificationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailVerificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    isVerify?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
  }

  export type EmailVerificationsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    isVerify?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    expirationDate?: SortOrder
  }

  export type EmailVerificationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TaxPayerCreateNestedOneWithoutUsersInput = {
    create?: XOR<TaxPayerCreateWithoutUsersInput, TaxPayerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TaxPayerCreateOrConnectWithoutUsersInput
    connect?: TaxPayerWhereUniqueInput
  }

  export type ConceptsCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ConceptsCreateWithoutAuthorInput, ConceptsUncheckedCreateWithoutAuthorInput> | ConceptsCreateWithoutAuthorInput[] | ConceptsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutAuthorInput | ConceptsCreateOrConnectWithoutAuthorInput[]
    createMany?: ConceptsCreateManyAuthorInputEnvelope
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutAuthorInput, PurchasesOrExpensesUncheckedCreateWithoutAuthorInput> | PurchasesOrExpensesCreateWithoutAuthorInput[] | PurchasesOrExpensesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutAuthorInput | PurchasesOrExpensesCreateOrConnectWithoutAuthorInput[]
    createMany?: PurchasesOrExpensesCreateManyAuthorInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type ConceptsUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ConceptsCreateWithoutAuthorInput, ConceptsUncheckedCreateWithoutAuthorInput> | ConceptsCreateWithoutAuthorInput[] | ConceptsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutAuthorInput | ConceptsCreateOrConnectWithoutAuthorInput[]
    createMany?: ConceptsCreateManyAuthorInputEnvelope
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutAuthorInput, PurchasesOrExpensesUncheckedCreateWithoutAuthorInput> | PurchasesOrExpensesCreateWithoutAuthorInput[] | PurchasesOrExpensesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutAuthorInput | PurchasesOrExpensesCreateOrConnectWithoutAuthorInput[]
    createMany?: PurchasesOrExpensesCreateManyAuthorInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TaxPayerUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TaxPayerCreateWithoutUsersInput, TaxPayerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TaxPayerCreateOrConnectWithoutUsersInput
    upsert?: TaxPayerUpsertWithoutUsersInput
    connect?: TaxPayerWhereUniqueInput
    update?: XOR<XOR<TaxPayerUpdateToOneWithWhereWithoutUsersInput, TaxPayerUpdateWithoutUsersInput>, TaxPayerUncheckedUpdateWithoutUsersInput>
  }

  export type ConceptsUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ConceptsCreateWithoutAuthorInput, ConceptsUncheckedCreateWithoutAuthorInput> | ConceptsCreateWithoutAuthorInput[] | ConceptsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutAuthorInput | ConceptsCreateOrConnectWithoutAuthorInput[]
    upsert?: ConceptsUpsertWithWhereUniqueWithoutAuthorInput | ConceptsUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ConceptsCreateManyAuthorInputEnvelope
    set?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    disconnect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    delete?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    update?: ConceptsUpdateWithWhereUniqueWithoutAuthorInput | ConceptsUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ConceptsUpdateManyWithWhereWithoutAuthorInput | ConceptsUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutAuthorInput, PurchasesOrExpensesUncheckedCreateWithoutAuthorInput> | PurchasesOrExpensesCreateWithoutAuthorInput[] | PurchasesOrExpensesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutAuthorInput | PurchasesOrExpensesCreateOrConnectWithoutAuthorInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutAuthorInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PurchasesOrExpensesCreateManyAuthorInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutAuthorInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutAuthorInput | PurchasesOrExpensesUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type ConceptsUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ConceptsCreateWithoutAuthorInput, ConceptsUncheckedCreateWithoutAuthorInput> | ConceptsCreateWithoutAuthorInput[] | ConceptsUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutAuthorInput | ConceptsCreateOrConnectWithoutAuthorInput[]
    upsert?: ConceptsUpsertWithWhereUniqueWithoutAuthorInput | ConceptsUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ConceptsCreateManyAuthorInputEnvelope
    set?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    disconnect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    delete?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    update?: ConceptsUpdateWithWhereUniqueWithoutAuthorInput | ConceptsUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ConceptsUpdateManyWithWhereWithoutAuthorInput | ConceptsUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutAuthorInput, PurchasesOrExpensesUncheckedCreateWithoutAuthorInput> | PurchasesOrExpensesCreateWithoutAuthorInput[] | PurchasesOrExpensesUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutAuthorInput | PurchasesOrExpensesCreateOrConnectWithoutAuthorInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutAuthorInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PurchasesOrExpensesCreateManyAuthorInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutAuthorInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutAuthorInput | PurchasesOrExpensesUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type NcfsTypesCreateNestedManyWithoutSerialInput = {
    create?: XOR<NcfsTypesCreateWithoutSerialInput, NcfsTypesUncheckedCreateWithoutSerialInput> | NcfsTypesCreateWithoutSerialInput[] | NcfsTypesUncheckedCreateWithoutSerialInput[]
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutSerialInput | NcfsTypesCreateOrConnectWithoutSerialInput[]
    createMany?: NcfsTypesCreateManySerialInputEnvelope
    connect?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
  }

  export type NcfsTypesUncheckedCreateNestedManyWithoutSerialInput = {
    create?: XOR<NcfsTypesCreateWithoutSerialInput, NcfsTypesUncheckedCreateWithoutSerialInput> | NcfsTypesCreateWithoutSerialInput[] | NcfsTypesUncheckedCreateWithoutSerialInput[]
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutSerialInput | NcfsTypesCreateOrConnectWithoutSerialInput[]
    createMany?: NcfsTypesCreateManySerialInputEnvelope
    connect?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NcfsTypesUpdateManyWithoutSerialNestedInput = {
    create?: XOR<NcfsTypesCreateWithoutSerialInput, NcfsTypesUncheckedCreateWithoutSerialInput> | NcfsTypesCreateWithoutSerialInput[] | NcfsTypesUncheckedCreateWithoutSerialInput[]
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutSerialInput | NcfsTypesCreateOrConnectWithoutSerialInput[]
    upsert?: NcfsTypesUpsertWithWhereUniqueWithoutSerialInput | NcfsTypesUpsertWithWhereUniqueWithoutSerialInput[]
    createMany?: NcfsTypesCreateManySerialInputEnvelope
    set?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    disconnect?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    delete?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    connect?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    update?: NcfsTypesUpdateWithWhereUniqueWithoutSerialInput | NcfsTypesUpdateWithWhereUniqueWithoutSerialInput[]
    updateMany?: NcfsTypesUpdateManyWithWhereWithoutSerialInput | NcfsTypesUpdateManyWithWhereWithoutSerialInput[]
    deleteMany?: NcfsTypesScalarWhereInput | NcfsTypesScalarWhereInput[]
  }

  export type NcfsTypesUncheckedUpdateManyWithoutSerialNestedInput = {
    create?: XOR<NcfsTypesCreateWithoutSerialInput, NcfsTypesUncheckedCreateWithoutSerialInput> | NcfsTypesCreateWithoutSerialInput[] | NcfsTypesUncheckedCreateWithoutSerialInput[]
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutSerialInput | NcfsTypesCreateOrConnectWithoutSerialInput[]
    upsert?: NcfsTypesUpsertWithWhereUniqueWithoutSerialInput | NcfsTypesUpsertWithWhereUniqueWithoutSerialInput[]
    createMany?: NcfsTypesCreateManySerialInputEnvelope
    set?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    disconnect?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    delete?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    connect?: NcfsTypesWhereUniqueInput | NcfsTypesWhereUniqueInput[]
    update?: NcfsTypesUpdateWithWhereUniqueWithoutSerialInput | NcfsTypesUpdateWithWhereUniqueWithoutSerialInput[]
    updateMany?: NcfsTypesUpdateManyWithWhereWithoutSerialInput | NcfsTypesUpdateManyWithWhereWithoutSerialInput[]
    deleteMany?: NcfsTypesScalarWhereInput | NcfsTypesScalarWhereInput[]
  }

  export type ConceptsCreateNestedManyWithoutClassificationTypeInput = {
    create?: XOR<ConceptsCreateWithoutClassificationTypeInput, ConceptsUncheckedCreateWithoutClassificationTypeInput> | ConceptsCreateWithoutClassificationTypeInput[] | ConceptsUncheckedCreateWithoutClassificationTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutClassificationTypeInput | ConceptsCreateOrConnectWithoutClassificationTypeInput[]
    createMany?: ConceptsCreateManyClassificationTypeInputEnvelope
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
  }

  export type ConceptsUncheckedCreateNestedManyWithoutClassificationTypeInput = {
    create?: XOR<ConceptsCreateWithoutClassificationTypeInput, ConceptsUncheckedCreateWithoutClassificationTypeInput> | ConceptsCreateWithoutClassificationTypeInput[] | ConceptsUncheckedCreateWithoutClassificationTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutClassificationTypeInput | ConceptsCreateOrConnectWithoutClassificationTypeInput[]
    createMany?: ConceptsCreateManyClassificationTypeInputEnvelope
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
  }

  export type ConceptsUpdateManyWithoutClassificationTypeNestedInput = {
    create?: XOR<ConceptsCreateWithoutClassificationTypeInput, ConceptsUncheckedCreateWithoutClassificationTypeInput> | ConceptsCreateWithoutClassificationTypeInput[] | ConceptsUncheckedCreateWithoutClassificationTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutClassificationTypeInput | ConceptsCreateOrConnectWithoutClassificationTypeInput[]
    upsert?: ConceptsUpsertWithWhereUniqueWithoutClassificationTypeInput | ConceptsUpsertWithWhereUniqueWithoutClassificationTypeInput[]
    createMany?: ConceptsCreateManyClassificationTypeInputEnvelope
    set?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    disconnect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    delete?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    update?: ConceptsUpdateWithWhereUniqueWithoutClassificationTypeInput | ConceptsUpdateWithWhereUniqueWithoutClassificationTypeInput[]
    updateMany?: ConceptsUpdateManyWithWhereWithoutClassificationTypeInput | ConceptsUpdateManyWithWhereWithoutClassificationTypeInput[]
    deleteMany?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
  }

  export type ConceptsUncheckedUpdateManyWithoutClassificationTypeNestedInput = {
    create?: XOR<ConceptsCreateWithoutClassificationTypeInput, ConceptsUncheckedCreateWithoutClassificationTypeInput> | ConceptsCreateWithoutClassificationTypeInput[] | ConceptsUncheckedCreateWithoutClassificationTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutClassificationTypeInput | ConceptsCreateOrConnectWithoutClassificationTypeInput[]
    upsert?: ConceptsUpsertWithWhereUniqueWithoutClassificationTypeInput | ConceptsUpsertWithWhereUniqueWithoutClassificationTypeInput[]
    createMany?: ConceptsCreateManyClassificationTypeInputEnvelope
    set?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    disconnect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    delete?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    update?: ConceptsUpdateWithWhereUniqueWithoutClassificationTypeInput | ConceptsUpdateWithWhereUniqueWithoutClassificationTypeInput[]
    updateMany?: ConceptsUpdateManyWithWhereWithoutClassificationTypeInput | ConceptsUpdateManyWithWhereWithoutClassificationTypeInput[]
    deleteMany?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
  }

  export type ClassificationTypeCreateNestedOneWithoutConceptsInput = {
    create?: XOR<ClassificationTypeCreateWithoutConceptsInput, ClassificationTypeUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: ClassificationTypeCreateOrConnectWithoutConceptsInput
    connect?: ClassificationTypeWhereUniqueInput
  }

  export type InvoiceTypeCreateNestedOneWithoutConceptsInput = {
    create?: XOR<InvoiceTypeCreateWithoutConceptsInput, InvoiceTypeUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: InvoiceTypeCreateOrConnectWithoutConceptsInput
    connect?: InvoiceTypeWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutConceptsInput = {
    create?: XOR<UsersCreateWithoutConceptsInput, UsersUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConceptsInput
    connect?: UsersWhereUniqueInput
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutConceptInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutConceptInput, PurchasesOrExpensesUncheckedCreateWithoutConceptInput> | PurchasesOrExpensesCreateWithoutConceptInput[] | PurchasesOrExpensesUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutConceptInput | PurchasesOrExpensesCreateOrConnectWithoutConceptInput[]
    createMany?: PurchasesOrExpensesCreateManyConceptInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutConceptInput, PurchasesOrExpensesUncheckedCreateWithoutConceptInput> | PurchasesOrExpensesCreateWithoutConceptInput[] | PurchasesOrExpensesUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutConceptInput | PurchasesOrExpensesCreateOrConnectWithoutConceptInput[]
    createMany?: PurchasesOrExpensesCreateManyConceptInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type ClassificationTypeUpdateOneRequiredWithoutConceptsNestedInput = {
    create?: XOR<ClassificationTypeCreateWithoutConceptsInput, ClassificationTypeUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: ClassificationTypeCreateOrConnectWithoutConceptsInput
    upsert?: ClassificationTypeUpsertWithoutConceptsInput
    connect?: ClassificationTypeWhereUniqueInput
    update?: XOR<XOR<ClassificationTypeUpdateToOneWithWhereWithoutConceptsInput, ClassificationTypeUpdateWithoutConceptsInput>, ClassificationTypeUncheckedUpdateWithoutConceptsInput>
  }

  export type InvoiceTypeUpdateOneRequiredWithoutConceptsNestedInput = {
    create?: XOR<InvoiceTypeCreateWithoutConceptsInput, InvoiceTypeUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: InvoiceTypeCreateOrConnectWithoutConceptsInput
    upsert?: InvoiceTypeUpsertWithoutConceptsInput
    connect?: InvoiceTypeWhereUniqueInput
    update?: XOR<XOR<InvoiceTypeUpdateToOneWithWhereWithoutConceptsInput, InvoiceTypeUpdateWithoutConceptsInput>, InvoiceTypeUncheckedUpdateWithoutConceptsInput>
  }

  export type UsersUpdateOneRequiredWithoutConceptsNestedInput = {
    create?: XOR<UsersCreateWithoutConceptsInput, UsersUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutConceptsInput
    upsert?: UsersUpsertWithoutConceptsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutConceptsInput, UsersUpdateWithoutConceptsInput>, UsersUncheckedUpdateWithoutConceptsInput>
  }

  export type PurchasesOrExpensesUpdateManyWithoutConceptNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutConceptInput, PurchasesOrExpensesUncheckedCreateWithoutConceptInput> | PurchasesOrExpensesCreateWithoutConceptInput[] | PurchasesOrExpensesUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutConceptInput | PurchasesOrExpensesCreateOrConnectWithoutConceptInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutConceptInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: PurchasesOrExpensesCreateManyConceptInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutConceptInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutConceptInput | PurchasesOrExpensesUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutConceptInput, PurchasesOrExpensesUncheckedCreateWithoutConceptInput> | PurchasesOrExpensesCreateWithoutConceptInput[] | PurchasesOrExpensesUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutConceptInput | PurchasesOrExpensesCreateOrConnectWithoutConceptInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutConceptInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: PurchasesOrExpensesCreateManyConceptInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutConceptInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutConceptInput | PurchasesOrExpensesUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type RequestsCreateNestedManyWithoutStatusInput = {
    create?: XOR<RequestsCreateWithoutStatusInput, RequestsUncheckedCreateWithoutStatusInput> | RequestsCreateWithoutStatusInput[] | RequestsUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutStatusInput | RequestsCreateOrConnectWithoutStatusInput[]
    createMany?: RequestsCreateManyStatusInputEnvelope
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
  }

  export type RequestsUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<RequestsCreateWithoutStatusInput, RequestsUncheckedCreateWithoutStatusInput> | RequestsCreateWithoutStatusInput[] | RequestsUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutStatusInput | RequestsCreateOrConnectWithoutStatusInput[]
    createMany?: RequestsCreateManyStatusInputEnvelope
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
  }

  export type RequestsUpdateManyWithoutStatusNestedInput = {
    create?: XOR<RequestsCreateWithoutStatusInput, RequestsUncheckedCreateWithoutStatusInput> | RequestsCreateWithoutStatusInput[] | RequestsUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutStatusInput | RequestsCreateOrConnectWithoutStatusInput[]
    upsert?: RequestsUpsertWithWhereUniqueWithoutStatusInput | RequestsUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: RequestsCreateManyStatusInputEnvelope
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    update?: RequestsUpdateWithWhereUniqueWithoutStatusInput | RequestsUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: RequestsUpdateManyWithWhereWithoutStatusInput | RequestsUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[]
  }

  export type RequestsUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<RequestsCreateWithoutStatusInput, RequestsUncheckedCreateWithoutStatusInput> | RequestsCreateWithoutStatusInput[] | RequestsUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutStatusInput | RequestsCreateOrConnectWithoutStatusInput[]
    upsert?: RequestsUpsertWithWhereUniqueWithoutStatusInput | RequestsUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: RequestsCreateManyStatusInputEnvelope
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    update?: RequestsUpdateWithWhereUniqueWithoutStatusInput | RequestsUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: RequestsUpdateManyWithWhereWithoutStatusInput | RequestsUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[]
  }

  export type TaxPayerCreateNestedOneWithoutRequestsInput = {
    create?: XOR<TaxPayerCreateWithoutRequestsInput, TaxPayerUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: TaxPayerCreateOrConnectWithoutRequestsInput
    connect?: TaxPayerWhereUniqueInput
  }

  export type RequestStatusCreateNestedOneWithoutRequestsInput = {
    create?: XOR<RequestStatusCreateWithoutRequestsInput, RequestStatusUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: RequestStatusCreateOrConnectWithoutRequestsInput
    connect?: RequestStatusWhereUniqueInput
  }

  export type DocumentsCreateNestedManyWithoutRequestInput = {
    create?: XOR<DocumentsCreateWithoutRequestInput, DocumentsUncheckedCreateWithoutRequestInput> | DocumentsCreateWithoutRequestInput[] | DocumentsUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutRequestInput | DocumentsCreateOrConnectWithoutRequestInput[]
    createMany?: DocumentsCreateManyRequestInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type DocumentsUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<DocumentsCreateWithoutRequestInput, DocumentsUncheckedCreateWithoutRequestInput> | DocumentsCreateWithoutRequestInput[] | DocumentsUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutRequestInput | DocumentsCreateOrConnectWithoutRequestInput[]
    createMany?: DocumentsCreateManyRequestInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type TaxPayerUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<TaxPayerCreateWithoutRequestsInput, TaxPayerUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: TaxPayerCreateOrConnectWithoutRequestsInput
    upsert?: TaxPayerUpsertWithoutRequestsInput
    connect?: TaxPayerWhereUniqueInput
    update?: XOR<XOR<TaxPayerUpdateToOneWithWhereWithoutRequestsInput, TaxPayerUpdateWithoutRequestsInput>, TaxPayerUncheckedUpdateWithoutRequestsInput>
  }

  export type RequestStatusUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<RequestStatusCreateWithoutRequestsInput, RequestStatusUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: RequestStatusCreateOrConnectWithoutRequestsInput
    upsert?: RequestStatusUpsertWithoutRequestsInput
    connect?: RequestStatusWhereUniqueInput
    update?: XOR<XOR<RequestStatusUpdateToOneWithWhereWithoutRequestsInput, RequestStatusUpdateWithoutRequestsInput>, RequestStatusUncheckedUpdateWithoutRequestsInput>
  }

  export type DocumentsUpdateManyWithoutRequestNestedInput = {
    create?: XOR<DocumentsCreateWithoutRequestInput, DocumentsUncheckedCreateWithoutRequestInput> | DocumentsCreateWithoutRequestInput[] | DocumentsUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutRequestInput | DocumentsCreateOrConnectWithoutRequestInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutRequestInput | DocumentsUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: DocumentsCreateManyRequestInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutRequestInput | DocumentsUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutRequestInput | DocumentsUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type DocumentsUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<DocumentsCreateWithoutRequestInput, DocumentsUncheckedCreateWithoutRequestInput> | DocumentsCreateWithoutRequestInput[] | DocumentsUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutRequestInput | DocumentsCreateOrConnectWithoutRequestInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutRequestInput | DocumentsUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: DocumentsCreateManyRequestInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutRequestInput | DocumentsUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutRequestInput | DocumentsUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type RequestsCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<RequestsCreateWithoutDocumentsInput, RequestsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RequestsCreateOrConnectWithoutDocumentsInput
    connect?: RequestsWhereUniqueInput
  }

  export type DocumentTypeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DocumentTypeCreateWithoutDocumentsInput, DocumentTypeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutDocumentsInput
    connect?: DocumentTypeWhereUniqueInput
  }

  export type RequestsUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<RequestsCreateWithoutDocumentsInput, RequestsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: RequestsCreateOrConnectWithoutDocumentsInput
    upsert?: RequestsUpsertWithoutDocumentsInput
    connect?: RequestsWhereUniqueInput
    update?: XOR<XOR<RequestsUpdateToOneWithWhereWithoutDocumentsInput, RequestsUpdateWithoutDocumentsInput>, RequestsUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentTypeUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<DocumentTypeCreateWithoutDocumentsInput, DocumentTypeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutDocumentsInput
    upsert?: DocumentTypeUpsertWithoutDocumentsInput
    connect?: DocumentTypeWhereUniqueInput
    update?: XOR<XOR<DocumentTypeUpdateToOneWithWhereWithoutDocumentsInput, DocumentTypeUpdateWithoutDocumentsInput>, DocumentTypeUncheckedUpdateWithoutDocumentsInput>
  }

  export type TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<TaxPayerCreateWithoutPurchasesOrExpensesInput, TaxPayerUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: TaxPayerCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: TaxPayerWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<UsersCreateWithoutPurchasesOrExpensesInput, UsersUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: UsersWhereUniqueInput
  }

  export type ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<ConceptsCreateWithoutPurchasesOrExpensesInput, ConceptsUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: ConceptsCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: ConceptsWhereUniqueInput
  }

  export type TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<TaxPayerTypesCreateWithoutPurchasesOrExpensesInput, TaxPayerTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: TaxPayerTypesCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: TaxPayerTypesWhereUniqueInput
  }

  export type PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<PaymentsMethodsCreateWithoutPurchasesOrExpensesInput, PaymentsMethodsUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: PaymentsMethodsCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: PaymentsMethodsWhereUniqueInput
  }

  export type NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: NcfsTypesWhereUniqueInput
  }

  export type NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    create?: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesOfNcfAffectedInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesOfNcfAffectedInput>
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutPurchasesOrExpensesOfNcfAffectedInput
    connect?: NcfsTypesWhereUniqueInput
  }

  export type RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<RetentionTaxCreateWithoutPurchasesOrExpensesInput, RetentionTaxUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: RetentionTaxCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: RetentionTaxWhereUniqueInput
  }

  export type RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<RetentionIsrCreateWithoutPurchasesOrExpensesInput, RetentionIsrUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: RetentionIsrCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: RetentionIsrWhereUniqueInput
  }

  export type CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput = {
    create?: XOR<CostTaxStatusCreateWithoutPurchasesOrExpensesInput, CostTaxStatusUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: CostTaxStatusCreateOrConnectWithoutPurchasesOrExpensesInput
    connect?: CostTaxStatusWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<TaxPayerCreateWithoutPurchasesOrExpensesInput, TaxPayerUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: TaxPayerCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: TaxPayerUpsertWithoutPurchasesOrExpensesInput
    connect?: TaxPayerWhereUniqueInput
    update?: XOR<XOR<TaxPayerUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, TaxPayerUpdateWithoutPurchasesOrExpensesInput>, TaxPayerUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<UsersCreateWithoutPurchasesOrExpensesInput, UsersUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: UsersUpsertWithoutPurchasesOrExpensesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, UsersUpdateWithoutPurchasesOrExpensesInput>, UsersUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<ConceptsCreateWithoutPurchasesOrExpensesInput, ConceptsUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: ConceptsCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: ConceptsUpsertWithoutPurchasesOrExpensesInput
    connect?: ConceptsWhereUniqueInput
    update?: XOR<XOR<ConceptsUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, ConceptsUpdateWithoutPurchasesOrExpensesInput>, ConceptsUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<TaxPayerTypesCreateWithoutPurchasesOrExpensesInput, TaxPayerTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: TaxPayerTypesCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: TaxPayerTypesUpsertWithoutPurchasesOrExpensesInput
    connect?: TaxPayerTypesWhereUniqueInput
    update?: XOR<XOR<TaxPayerTypesUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, TaxPayerTypesUpdateWithoutPurchasesOrExpensesInput>, TaxPayerTypesUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<PaymentsMethodsCreateWithoutPurchasesOrExpensesInput, PaymentsMethodsUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: PaymentsMethodsCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: PaymentsMethodsUpsertWithoutPurchasesOrExpensesInput
    connect?: PaymentsMethodsWhereUniqueInput
    update?: XOR<XOR<PaymentsMethodsUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, PaymentsMethodsUpdateWithoutPurchasesOrExpensesInput>, PaymentsMethodsUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: NcfsTypesUpsertWithoutPurchasesOrExpensesInput
    connect?: NcfsTypesWhereUniqueInput
    update?: XOR<XOR<NcfsTypesUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, NcfsTypesUpdateWithoutPurchasesOrExpensesInput>, NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput = {
    create?: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesOfNcfAffectedInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesOfNcfAffectedInput>
    connectOrCreate?: NcfsTypesCreateOrConnectWithoutPurchasesOrExpensesOfNcfAffectedInput
    upsert?: NcfsTypesUpsertWithoutPurchasesOrExpensesOfNcfAffectedInput
    disconnect?: NcfsTypesWhereInput | boolean
    delete?: NcfsTypesWhereInput | boolean
    connect?: NcfsTypesWhereUniqueInput
    update?: XOR<XOR<NcfsTypesUpdateToOneWithWhereWithoutPurchasesOrExpensesOfNcfAffectedInput, NcfsTypesUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput>, NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput>
  }

  export type RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<RetentionTaxCreateWithoutPurchasesOrExpensesInput, RetentionTaxUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: RetentionTaxCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: RetentionTaxUpsertWithoutPurchasesOrExpensesInput
    disconnect?: RetentionTaxWhereInput | boolean
    delete?: RetentionTaxWhereInput | boolean
    connect?: RetentionTaxWhereUniqueInput
    update?: XOR<XOR<RetentionTaxUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, RetentionTaxUpdateWithoutPurchasesOrExpensesInput>, RetentionTaxUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<RetentionIsrCreateWithoutPurchasesOrExpensesInput, RetentionIsrUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: RetentionIsrCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: RetentionIsrUpsertWithoutPurchasesOrExpensesInput
    disconnect?: RetentionIsrWhereInput | boolean
    delete?: RetentionIsrWhereInput | boolean
    connect?: RetentionIsrWhereUniqueInput
    update?: XOR<XOR<RetentionIsrUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, RetentionIsrUpdateWithoutPurchasesOrExpensesInput>, RetentionIsrUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput = {
    create?: XOR<CostTaxStatusCreateWithoutPurchasesOrExpensesInput, CostTaxStatusUncheckedCreateWithoutPurchasesOrExpensesInput>
    connectOrCreate?: CostTaxStatusCreateOrConnectWithoutPurchasesOrExpensesInput
    upsert?: CostTaxStatusUpsertWithoutPurchasesOrExpensesInput
    disconnect?: CostTaxStatusWhereInput | boolean
    delete?: CostTaxStatusWhereInput | boolean
    connect?: CostTaxStatusWhereUniqueInput
    update?: XOR<XOR<CostTaxStatusUpdateToOneWithWhereWithoutPurchasesOrExpensesInput, CostTaxStatusUpdateWithoutPurchasesOrExpensesInput>, CostTaxStatusUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutTaxPayerTypeInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput> | PurchasesOrExpensesCreateWithoutTaxPayerTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerTypeInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutTaxPayerTypeInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput> | PurchasesOrExpensesCreateWithoutTaxPayerTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerTypeInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutTaxPayerTypeNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput> | PurchasesOrExpensesCreateWithoutTaxPayerTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerTypeInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerTypeInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerTypeInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerTypeInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerTypeInput | PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerTypeInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerTypeNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput> | PurchasesOrExpensesCreateWithoutTaxPayerTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerTypeInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerTypeInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerTypeInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerTypeInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerTypeInput | PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerTypeInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type ConceptsCreateNestedManyWithoutInvoiceTypeInput = {
    create?: XOR<ConceptsCreateWithoutInvoiceTypeInput, ConceptsUncheckedCreateWithoutInvoiceTypeInput> | ConceptsCreateWithoutInvoiceTypeInput[] | ConceptsUncheckedCreateWithoutInvoiceTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutInvoiceTypeInput | ConceptsCreateOrConnectWithoutInvoiceTypeInput[]
    createMany?: ConceptsCreateManyInvoiceTypeInputEnvelope
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
  }

  export type ConceptsUncheckedCreateNestedManyWithoutInvoiceTypeInput = {
    create?: XOR<ConceptsCreateWithoutInvoiceTypeInput, ConceptsUncheckedCreateWithoutInvoiceTypeInput> | ConceptsCreateWithoutInvoiceTypeInput[] | ConceptsUncheckedCreateWithoutInvoiceTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutInvoiceTypeInput | ConceptsCreateOrConnectWithoutInvoiceTypeInput[]
    createMany?: ConceptsCreateManyInvoiceTypeInputEnvelope
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
  }

  export type ConceptsUpdateManyWithoutInvoiceTypeNestedInput = {
    create?: XOR<ConceptsCreateWithoutInvoiceTypeInput, ConceptsUncheckedCreateWithoutInvoiceTypeInput> | ConceptsCreateWithoutInvoiceTypeInput[] | ConceptsUncheckedCreateWithoutInvoiceTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutInvoiceTypeInput | ConceptsCreateOrConnectWithoutInvoiceTypeInput[]
    upsert?: ConceptsUpsertWithWhereUniqueWithoutInvoiceTypeInput | ConceptsUpsertWithWhereUniqueWithoutInvoiceTypeInput[]
    createMany?: ConceptsCreateManyInvoiceTypeInputEnvelope
    set?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    disconnect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    delete?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    update?: ConceptsUpdateWithWhereUniqueWithoutInvoiceTypeInput | ConceptsUpdateWithWhereUniqueWithoutInvoiceTypeInput[]
    updateMany?: ConceptsUpdateManyWithWhereWithoutInvoiceTypeInput | ConceptsUpdateManyWithWhereWithoutInvoiceTypeInput[]
    deleteMany?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
  }

  export type ConceptsUncheckedUpdateManyWithoutInvoiceTypeNestedInput = {
    create?: XOR<ConceptsCreateWithoutInvoiceTypeInput, ConceptsUncheckedCreateWithoutInvoiceTypeInput> | ConceptsCreateWithoutInvoiceTypeInput[] | ConceptsUncheckedCreateWithoutInvoiceTypeInput[]
    connectOrCreate?: ConceptsCreateOrConnectWithoutInvoiceTypeInput | ConceptsCreateOrConnectWithoutInvoiceTypeInput[]
    upsert?: ConceptsUpsertWithWhereUniqueWithoutInvoiceTypeInput | ConceptsUpsertWithWhereUniqueWithoutInvoiceTypeInput[]
    createMany?: ConceptsCreateManyInvoiceTypeInputEnvelope
    set?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    disconnect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    delete?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    connect?: ConceptsWhereUniqueInput | ConceptsWhereUniqueInput[]
    update?: ConceptsUpdateWithWhereUniqueWithoutInvoiceTypeInput | ConceptsUpdateWithWhereUniqueWithoutInvoiceTypeInput[]
    updateMany?: ConceptsUpdateManyWithWhereWithoutInvoiceTypeInput | ConceptsUpdateManyWithWhereWithoutInvoiceTypeInput[]
    deleteMany?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput> | PurchasesOrExpensesCreateWithoutPaymentMethodInput[] | PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput | PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PurchasesOrExpensesCreateManyPaymentMethodInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput> | PurchasesOrExpensesCreateWithoutPaymentMethodInput[] | PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput | PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PurchasesOrExpensesCreateManyPaymentMethodInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput> | PurchasesOrExpensesCreateWithoutPaymentMethodInput[] | PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput | PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutPaymentMethodInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PurchasesOrExpensesCreateManyPaymentMethodInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutPaymentMethodInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutPaymentMethodInput | PurchasesOrExpensesUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput> | PurchasesOrExpensesCreateWithoutPaymentMethodInput[] | PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput | PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutPaymentMethodInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PurchasesOrExpensesCreateManyPaymentMethodInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutPaymentMethodInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutPaymentMethodInput | PurchasesOrExpensesUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type SerialCreateNestedOneWithoutNcfsTypesInput = {
    create?: XOR<SerialCreateWithoutNcfsTypesInput, SerialUncheckedCreateWithoutNcfsTypesInput>
    connectOrCreate?: SerialCreateOrConnectWithoutNcfsTypesInput
    connect?: SerialWhereUniqueInput
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutNcfTypeInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput> | PurchasesOrExpensesCreateWithoutNcfTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfTypeInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutNcfAffectTypeInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput> | PurchasesOrExpensesCreateWithoutNcfAffectTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfAffectTypeInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfTypeInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput> | PurchasesOrExpensesCreateWithoutNcfTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfTypeInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfAffectTypeInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput> | PurchasesOrExpensesCreateWithoutNcfAffectTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfAffectTypeInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type SerialUpdateOneRequiredWithoutNcfsTypesNestedInput = {
    create?: XOR<SerialCreateWithoutNcfsTypesInput, SerialUncheckedCreateWithoutNcfsTypesInput>
    connectOrCreate?: SerialCreateOrConnectWithoutNcfsTypesInput
    upsert?: SerialUpsertWithoutNcfsTypesInput
    connect?: SerialWhereUniqueInput
    update?: XOR<XOR<SerialUpdateToOneWithWhereWithoutNcfsTypesInput, SerialUpdateWithoutNcfsTypesInput>, SerialUncheckedUpdateWithoutNcfsTypesInput>
  }

  export type PurchasesOrExpensesUpdateManyWithoutNcfTypeNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput> | PurchasesOrExpensesCreateWithoutNcfTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfTypeInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfTypeInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfTypeInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfTypeInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutNcfTypeInput | PurchasesOrExpensesUpdateManyWithWhereWithoutNcfTypeInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutNcfAffectTypeNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput> | PurchasesOrExpensesCreateWithoutNcfAffectTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfAffectTypeInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfAffectTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfAffectTypeInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfAffectTypeInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfAffectTypeInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutNcfAffectTypeInput | PurchasesOrExpensesUpdateManyWithWhereWithoutNcfAffectTypeInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutNcfTypeNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput> | PurchasesOrExpensesCreateWithoutNcfTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfTypeInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfTypeInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfTypeInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfTypeInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutNcfTypeInput | PurchasesOrExpensesUpdateManyWithWhereWithoutNcfTypeInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutNcfAffectTypeNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput> | PurchasesOrExpensesCreateWithoutNcfAffectTypeInput[] | PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput | PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfAffectTypeInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfAffectTypeInput[]
    createMany?: PurchasesOrExpensesCreateManyNcfAffectTypeInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfAffectTypeInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfAffectTypeInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutNcfAffectTypeInput | PurchasesOrExpensesUpdateManyWithWhereWithoutNcfAffectTypeInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutRetentionTaxInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput> | PurchasesOrExpensesCreateWithoutRetentionTaxInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionTaxInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutRetentionTaxInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput> | PurchasesOrExpensesCreateWithoutRetentionTaxInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionTaxInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutRetentionTaxNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput> | PurchasesOrExpensesCreateWithoutRetentionTaxInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionTaxInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionTaxInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionTaxInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionTaxInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionTaxInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionTaxInput | PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionTaxInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionTaxNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput> | PurchasesOrExpensesCreateWithoutRetentionTaxInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionTaxInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionTaxInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionTaxInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionTaxInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionTaxInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionTaxInput | PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionTaxInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutRetentionIsrInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput> | PurchasesOrExpensesCreateWithoutRetentionIsrInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionIsrInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutRetentionIsrInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput> | PurchasesOrExpensesCreateWithoutRetentionIsrInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionIsrInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutRetentionIsrNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput> | PurchasesOrExpensesCreateWithoutRetentionIsrInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionIsrInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionIsrInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionIsrInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionIsrInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionIsrInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionIsrInput | PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionIsrInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionIsrNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput> | PurchasesOrExpensesCreateWithoutRetentionIsrInput[] | PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput | PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionIsrInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionIsrInput[]
    createMany?: PurchasesOrExpensesCreateManyRetentionIsrInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionIsrInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionIsrInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionIsrInput | PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionIsrInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutCostTaxStatusInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput> | PurchasesOrExpensesCreateWithoutCostTaxStatusInput[] | PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput | PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput[]
    createMany?: PurchasesOrExpensesCreateManyCostTaxStatusInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutCostTaxStatusInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput> | PurchasesOrExpensesCreateWithoutCostTaxStatusInput[] | PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput | PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput[]
    createMany?: PurchasesOrExpensesCreateManyCostTaxStatusInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutCostTaxStatusNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput> | PurchasesOrExpensesCreateWithoutCostTaxStatusInput[] | PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput | PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutCostTaxStatusInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutCostTaxStatusInput[]
    createMany?: PurchasesOrExpensesCreateManyCostTaxStatusInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutCostTaxStatusInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutCostTaxStatusInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutCostTaxStatusInput | PurchasesOrExpensesUpdateManyWithWhereWithoutCostTaxStatusInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutCostTaxStatusNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput> | PurchasesOrExpensesCreateWithoutCostTaxStatusInput[] | PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput | PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutCostTaxStatusInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutCostTaxStatusInput[]
    createMany?: PurchasesOrExpensesCreateManyCostTaxStatusInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutCostTaxStatusInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutCostTaxStatusInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutCostTaxStatusInput | PurchasesOrExpensesUpdateManyWithWhereWithoutCostTaxStatusInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type PurchasesOrExpensesCreateNestedManyWithoutTaxPayerInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput> | PurchasesOrExpensesCreateWithoutTaxPayerInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type RequestsCreateNestedManyWithoutTaxPayerInput = {
    create?: XOR<RequestsCreateWithoutTaxPayerInput, RequestsUncheckedCreateWithoutTaxPayerInput> | RequestsCreateWithoutTaxPayerInput[] | RequestsUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutTaxPayerInput | RequestsCreateOrConnectWithoutTaxPayerInput[]
    createMany?: RequestsCreateManyTaxPayerInputEnvelope
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
  }

  export type UsersCreateNestedManyWithoutTaxPayerInput = {
    create?: XOR<UsersCreateWithoutTaxPayerInput, UsersUncheckedCreateWithoutTaxPayerInput> | UsersCreateWithoutTaxPayerInput[] | UsersUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutTaxPayerInput | UsersCreateOrConnectWithoutTaxPayerInput[]
    createMany?: UsersCreateManyTaxPayerInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUncheckedCreateNestedManyWithoutTaxPayerInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput> | PurchasesOrExpensesCreateWithoutTaxPayerInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerInputEnvelope
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
  }

  export type RequestsUncheckedCreateNestedManyWithoutTaxPayerInput = {
    create?: XOR<RequestsCreateWithoutTaxPayerInput, RequestsUncheckedCreateWithoutTaxPayerInput> | RequestsCreateWithoutTaxPayerInput[] | RequestsUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutTaxPayerInput | RequestsCreateOrConnectWithoutTaxPayerInput[]
    createMany?: RequestsCreateManyTaxPayerInputEnvelope
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutTaxPayerInput = {
    create?: XOR<UsersCreateWithoutTaxPayerInput, UsersUncheckedCreateWithoutTaxPayerInput> | UsersCreateWithoutTaxPayerInput[] | UsersUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutTaxPayerInput | UsersCreateOrConnectWithoutTaxPayerInput[]
    createMany?: UsersCreateManyTaxPayerInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type PurchasesOrExpensesUpdateManyWithoutTaxPayerNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput> | PurchasesOrExpensesCreateWithoutTaxPayerInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerInput | PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type RequestsUpdateManyWithoutTaxPayerNestedInput = {
    create?: XOR<RequestsCreateWithoutTaxPayerInput, RequestsUncheckedCreateWithoutTaxPayerInput> | RequestsCreateWithoutTaxPayerInput[] | RequestsUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutTaxPayerInput | RequestsCreateOrConnectWithoutTaxPayerInput[]
    upsert?: RequestsUpsertWithWhereUniqueWithoutTaxPayerInput | RequestsUpsertWithWhereUniqueWithoutTaxPayerInput[]
    createMany?: RequestsCreateManyTaxPayerInputEnvelope
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    update?: RequestsUpdateWithWhereUniqueWithoutTaxPayerInput | RequestsUpdateWithWhereUniqueWithoutTaxPayerInput[]
    updateMany?: RequestsUpdateManyWithWhereWithoutTaxPayerInput | RequestsUpdateManyWithWhereWithoutTaxPayerInput[]
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[]
  }

  export type UsersUpdateManyWithoutTaxPayerNestedInput = {
    create?: XOR<UsersCreateWithoutTaxPayerInput, UsersUncheckedCreateWithoutTaxPayerInput> | UsersCreateWithoutTaxPayerInput[] | UsersUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutTaxPayerInput | UsersCreateOrConnectWithoutTaxPayerInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutTaxPayerInput | UsersUpsertWithWhereUniqueWithoutTaxPayerInput[]
    createMany?: UsersCreateManyTaxPayerInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutTaxPayerInput | UsersUpdateWithWhereUniqueWithoutTaxPayerInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutTaxPayerInput | UsersUpdateManyWithWhereWithoutTaxPayerInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerNestedInput = {
    create?: XOR<PurchasesOrExpensesCreateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput> | PurchasesOrExpensesCreateWithoutTaxPayerInput[] | PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput | PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput[]
    upsert?: PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerInput | PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerInput[]
    createMany?: PurchasesOrExpensesCreateManyTaxPayerInputEnvelope
    set?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    disconnect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    delete?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    connect?: PurchasesOrExpensesWhereUniqueInput | PurchasesOrExpensesWhereUniqueInput[]
    update?: PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerInput | PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerInput[]
    updateMany?: PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerInput | PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerInput[]
    deleteMany?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
  }

  export type RequestsUncheckedUpdateManyWithoutTaxPayerNestedInput = {
    create?: XOR<RequestsCreateWithoutTaxPayerInput, RequestsUncheckedCreateWithoutTaxPayerInput> | RequestsCreateWithoutTaxPayerInput[] | RequestsUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: RequestsCreateOrConnectWithoutTaxPayerInput | RequestsCreateOrConnectWithoutTaxPayerInput[]
    upsert?: RequestsUpsertWithWhereUniqueWithoutTaxPayerInput | RequestsUpsertWithWhereUniqueWithoutTaxPayerInput[]
    createMany?: RequestsCreateManyTaxPayerInputEnvelope
    set?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    disconnect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    delete?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    connect?: RequestsWhereUniqueInput | RequestsWhereUniqueInput[]
    update?: RequestsUpdateWithWhereUniqueWithoutTaxPayerInput | RequestsUpdateWithWhereUniqueWithoutTaxPayerInput[]
    updateMany?: RequestsUpdateManyWithWhereWithoutTaxPayerInput | RequestsUpdateManyWithWhereWithoutTaxPayerInput[]
    deleteMany?: RequestsScalarWhereInput | RequestsScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutTaxPayerNestedInput = {
    create?: XOR<UsersCreateWithoutTaxPayerInput, UsersUncheckedCreateWithoutTaxPayerInput> | UsersCreateWithoutTaxPayerInput[] | UsersUncheckedCreateWithoutTaxPayerInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutTaxPayerInput | UsersCreateOrConnectWithoutTaxPayerInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutTaxPayerInput | UsersUpsertWithWhereUniqueWithoutTaxPayerInput[]
    createMany?: UsersCreateManyTaxPayerInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutTaxPayerInput | UsersUpdateWithWhereUniqueWithoutTaxPayerInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutTaxPayerInput | UsersUpdateManyWithWhereWithoutTaxPayerInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type DocumentsCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<DocumentsCreateWithoutDocumentTypeInput, DocumentsUncheckedCreateWithoutDocumentTypeInput> | DocumentsCreateWithoutDocumentTypeInput[] | DocumentsUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentTypeInput | DocumentsCreateOrConnectWithoutDocumentTypeInput[]
    createMany?: DocumentsCreateManyDocumentTypeInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type DocumentsUncheckedCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<DocumentsCreateWithoutDocumentTypeInput, DocumentsUncheckedCreateWithoutDocumentTypeInput> | DocumentsCreateWithoutDocumentTypeInput[] | DocumentsUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentTypeInput | DocumentsCreateOrConnectWithoutDocumentTypeInput[]
    createMany?: DocumentsCreateManyDocumentTypeInputEnvelope
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
  }

  export type DocumentsUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<DocumentsCreateWithoutDocumentTypeInput, DocumentsUncheckedCreateWithoutDocumentTypeInput> | DocumentsCreateWithoutDocumentTypeInput[] | DocumentsUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentTypeInput | DocumentsCreateOrConnectWithoutDocumentTypeInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutDocumentTypeInput | DocumentsUpsertWithWhereUniqueWithoutDocumentTypeInput[]
    createMany?: DocumentsCreateManyDocumentTypeInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutDocumentTypeInput | DocumentsUpdateWithWhereUniqueWithoutDocumentTypeInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutDocumentTypeInput | DocumentsUpdateManyWithWhereWithoutDocumentTypeInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type DocumentsUncheckedUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<DocumentsCreateWithoutDocumentTypeInput, DocumentsUncheckedCreateWithoutDocumentTypeInput> | DocumentsCreateWithoutDocumentTypeInput[] | DocumentsUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: DocumentsCreateOrConnectWithoutDocumentTypeInput | DocumentsCreateOrConnectWithoutDocumentTypeInput[]
    upsert?: DocumentsUpsertWithWhereUniqueWithoutDocumentTypeInput | DocumentsUpsertWithWhereUniqueWithoutDocumentTypeInput[]
    createMany?: DocumentsCreateManyDocumentTypeInputEnvelope
    set?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    disconnect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    delete?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    connect?: DocumentsWhereUniqueInput | DocumentsWhereUniqueInput[]
    update?: DocumentsUpdateWithWhereUniqueWithoutDocumentTypeInput | DocumentsUpdateWithWhereUniqueWithoutDocumentTypeInput[]
    updateMany?: DocumentsUpdateManyWithWhereWithoutDocumentTypeInput | DocumentsUpdateManyWithWhereWithoutDocumentTypeInput[]
    deleteMany?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TaxPayerCreateWithoutUsersInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutTaxPayerInput
    Requests?: RequestsCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerUncheckedCreateWithoutUsersInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutTaxPayerInput
    Requests?: RequestsUncheckedCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerCreateOrConnectWithoutUsersInput = {
    where: TaxPayerWhereUniqueInput
    create: XOR<TaxPayerCreateWithoutUsersInput, TaxPayerUncheckedCreateWithoutUsersInput>
  }

  export type ConceptsCreateWithoutAuthorInput = {
    name: string
    classificationType: ClassificationTypeCreateNestedOneWithoutConceptsInput
    invoiceType: InvoiceTypeCreateNestedOneWithoutConceptsInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutConceptInput
  }

  export type ConceptsUncheckedCreateWithoutAuthorInput = {
    id?: number
    name: string
    invoiceTypeId: string
    classificationTypeId: number
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptsCreateOrConnectWithoutAuthorInput = {
    where: ConceptsWhereUniqueInput
    create: XOR<ConceptsCreateWithoutAuthorInput, ConceptsUncheckedCreateWithoutAuthorInput>
  }

  export type ConceptsCreateManyAuthorInputEnvelope = {
    data: ConceptsCreateManyAuthorInput | ConceptsCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesCreateWithoutAuthorInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutAuthorInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutAuthorInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutAuthorInput, PurchasesOrExpensesUncheckedCreateWithoutAuthorInput>
  }

  export type PurchasesOrExpensesCreateManyAuthorInputEnvelope = {
    data: PurchasesOrExpensesCreateManyAuthorInput | PurchasesOrExpensesCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type TaxPayerUpsertWithoutUsersInput = {
    update: XOR<TaxPayerUpdateWithoutUsersInput, TaxPayerUncheckedUpdateWithoutUsersInput>
    create: XOR<TaxPayerCreateWithoutUsersInput, TaxPayerUncheckedCreateWithoutUsersInput>
    where?: TaxPayerWhereInput
  }

  export type TaxPayerUpdateToOneWithWhereWithoutUsersInput = {
    where?: TaxPayerWhereInput
    data: XOR<TaxPayerUpdateWithoutUsersInput, TaxPayerUncheckedUpdateWithoutUsersInput>
  }

  export type TaxPayerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutTaxPayerNestedInput
    Requests?: RequestsUpdateManyWithoutTaxPayerNestedInput
  }

  export type TaxPayerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerNestedInput
    Requests?: RequestsUncheckedUpdateManyWithoutTaxPayerNestedInput
  }

  export type ConceptsUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ConceptsWhereUniqueInput
    update: XOR<ConceptsUpdateWithoutAuthorInput, ConceptsUncheckedUpdateWithoutAuthorInput>
    create: XOR<ConceptsCreateWithoutAuthorInput, ConceptsUncheckedCreateWithoutAuthorInput>
  }

  export type ConceptsUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ConceptsWhereUniqueInput
    data: XOR<ConceptsUpdateWithoutAuthorInput, ConceptsUncheckedUpdateWithoutAuthorInput>
  }

  export type ConceptsUpdateManyWithWhereWithoutAuthorInput = {
    where: ConceptsScalarWhereInput
    data: XOR<ConceptsUpdateManyMutationInput, ConceptsUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ConceptsScalarWhereInput = {
    AND?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
    OR?: ConceptsScalarWhereInput[]
    NOT?: ConceptsScalarWhereInput | ConceptsScalarWhereInput[]
    id?: IntFilter<"Concepts"> | number
    name?: StringFilter<"Concepts"> | string
    authorId?: StringFilter<"Concepts"> | string
    invoiceTypeId?: StringFilter<"Concepts"> | string
    classificationTypeId?: IntFilter<"Concepts"> | number
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutAuthorInput, PurchasesOrExpensesUncheckedUpdateWithoutAuthorInput>
    create: XOR<PurchasesOrExpensesCreateWithoutAuthorInput, PurchasesOrExpensesUncheckedCreateWithoutAuthorInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutAuthorInput, PurchasesOrExpensesUncheckedUpdateWithoutAuthorInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutAuthorInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PurchasesOrExpensesScalarWhereInput = {
    AND?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
    OR?: PurchasesOrExpensesScalarWhereInput[]
    NOT?: PurchasesOrExpensesScalarWhereInput | PurchasesOrExpensesScalarWhereInput[]
    id?: StringFilter<"PurchasesOrExpenses"> | string
    rncOrId?: StringFilter<"PurchasesOrExpenses"> | string
    ncf?: StringFilter<"PurchasesOrExpenses"> | string
    ncfAffected?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    issueDate?: DateTimeFilter<"PurchasesOrExpenses"> | Date | string
    retentionDate?: DateTimeNullableFilter<"PurchasesOrExpenses"> | Date | string | null
    total?: DecimalFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string
    costTax?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFilter<"PurchasesOrExpenses"> | number
    paymentsMethodsId?: StringFilter<"PurchasesOrExpenses"> | string
    ncfsTypesId?: StringFilter<"PurchasesOrExpenses"> | string
    ncfsAffectTypeId?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    retentionTaxId?: IntNullableFilter<"PurchasesOrExpenses"> | number | null
    retentionIsrId?: StringNullableFilter<"PurchasesOrExpenses"> | string | null
    costTaxStatusId?: IntNullableFilter<"PurchasesOrExpenses"> | number | null
    conceptId?: IntFilter<"PurchasesOrExpenses"> | number
    authorId?: StringFilter<"PurchasesOrExpenses"> | string
    updatedAt?: DateTimeNullableFilter<"PurchasesOrExpenses"> | Date | string | null
    createdAt?: DateTimeFilter<"PurchasesOrExpenses"> | Date | string
    netAmount?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    netToPaid?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: DecimalNullableFilter<"PurchasesOrExpenses"> | Decimal | DecimalJsLike | number | string | null
    manual?: BoolNullableFilter<"PurchasesOrExpenses"> | boolean | null
  }

  export type NcfsTypesCreateWithoutSerialInput = {
    id: string
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutNcfTypeInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesCreateNestedManyWithoutNcfAffectTypeInput
  }

  export type NcfsTypesUncheckedCreateWithoutSerialInput = {
    id: string
    name: string
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfTypeInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfAffectTypeInput
  }

  export type NcfsTypesCreateOrConnectWithoutSerialInput = {
    where: NcfsTypesWhereUniqueInput
    create: XOR<NcfsTypesCreateWithoutSerialInput, NcfsTypesUncheckedCreateWithoutSerialInput>
  }

  export type NcfsTypesCreateManySerialInputEnvelope = {
    data: NcfsTypesCreateManySerialInput | NcfsTypesCreateManySerialInput[]
    skipDuplicates?: boolean
  }

  export type NcfsTypesUpsertWithWhereUniqueWithoutSerialInput = {
    where: NcfsTypesWhereUniqueInput
    update: XOR<NcfsTypesUpdateWithoutSerialInput, NcfsTypesUncheckedUpdateWithoutSerialInput>
    create: XOR<NcfsTypesCreateWithoutSerialInput, NcfsTypesUncheckedCreateWithoutSerialInput>
  }

  export type NcfsTypesUpdateWithWhereUniqueWithoutSerialInput = {
    where: NcfsTypesWhereUniqueInput
    data: XOR<NcfsTypesUpdateWithoutSerialInput, NcfsTypesUncheckedUpdateWithoutSerialInput>
  }

  export type NcfsTypesUpdateManyWithWhereWithoutSerialInput = {
    where: NcfsTypesScalarWhereInput
    data: XOR<NcfsTypesUpdateManyMutationInput, NcfsTypesUncheckedUpdateManyWithoutSerialInput>
  }

  export type NcfsTypesScalarWhereInput = {
    AND?: NcfsTypesScalarWhereInput | NcfsTypesScalarWhereInput[]
    OR?: NcfsTypesScalarWhereInput[]
    NOT?: NcfsTypesScalarWhereInput | NcfsTypesScalarWhereInput[]
    id?: StringFilter<"NcfsTypes"> | string
    name?: StringFilter<"NcfsTypes"> | string
    serialId?: IntFilter<"NcfsTypes"> | number
    createdAt?: DateTimeFilter<"NcfsTypes"> | Date | string
  }

  export type ConceptsCreateWithoutClassificationTypeInput = {
    name: string
    invoiceType: InvoiceTypeCreateNestedOneWithoutConceptsInput
    author: UsersCreateNestedOneWithoutConceptsInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutConceptInput
  }

  export type ConceptsUncheckedCreateWithoutClassificationTypeInput = {
    id?: number
    name: string
    authorId: string
    invoiceTypeId: string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptsCreateOrConnectWithoutClassificationTypeInput = {
    where: ConceptsWhereUniqueInput
    create: XOR<ConceptsCreateWithoutClassificationTypeInput, ConceptsUncheckedCreateWithoutClassificationTypeInput>
  }

  export type ConceptsCreateManyClassificationTypeInputEnvelope = {
    data: ConceptsCreateManyClassificationTypeInput | ConceptsCreateManyClassificationTypeInput[]
    skipDuplicates?: boolean
  }

  export type ConceptsUpsertWithWhereUniqueWithoutClassificationTypeInput = {
    where: ConceptsWhereUniqueInput
    update: XOR<ConceptsUpdateWithoutClassificationTypeInput, ConceptsUncheckedUpdateWithoutClassificationTypeInput>
    create: XOR<ConceptsCreateWithoutClassificationTypeInput, ConceptsUncheckedCreateWithoutClassificationTypeInput>
  }

  export type ConceptsUpdateWithWhereUniqueWithoutClassificationTypeInput = {
    where: ConceptsWhereUniqueInput
    data: XOR<ConceptsUpdateWithoutClassificationTypeInput, ConceptsUncheckedUpdateWithoutClassificationTypeInput>
  }

  export type ConceptsUpdateManyWithWhereWithoutClassificationTypeInput = {
    where: ConceptsScalarWhereInput
    data: XOR<ConceptsUpdateManyMutationInput, ConceptsUncheckedUpdateManyWithoutClassificationTypeInput>
  }

  export type ClassificationTypeCreateWithoutConceptsInput = {
    name: string
  }

  export type ClassificationTypeUncheckedCreateWithoutConceptsInput = {
    id?: number
    name: string
  }

  export type ClassificationTypeCreateOrConnectWithoutConceptsInput = {
    where: ClassificationTypeWhereUniqueInput
    create: XOR<ClassificationTypeCreateWithoutConceptsInput, ClassificationTypeUncheckedCreateWithoutConceptsInput>
  }

  export type InvoiceTypeCreateWithoutConceptsInput = {
    id: string
    name: string
    createdAt?: Date | string
  }

  export type InvoiceTypeUncheckedCreateWithoutConceptsInput = {
    id: string
    name: string
    createdAt?: Date | string
  }

  export type InvoiceTypeCreateOrConnectWithoutConceptsInput = {
    where: InvoiceTypeWhereUniqueInput
    create: XOR<InvoiceTypeCreateWithoutConceptsInput, InvoiceTypeUncheckedCreateWithoutConceptsInput>
  }

  export type UsersCreateWithoutConceptsInput = {
    id?: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    taxPayer: TaxPayerCreateNestedOneWithoutUsersInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutAuthorInput
  }

  export type UsersUncheckedCreateWithoutConceptsInput = {
    id?: string
    username: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UsersCreateOrConnectWithoutConceptsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutConceptsInput, UsersUncheckedCreateWithoutConceptsInput>
  }

  export type PurchasesOrExpensesCreateWithoutConceptInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutConceptInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutConceptInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutConceptInput, PurchasesOrExpensesUncheckedCreateWithoutConceptInput>
  }

  export type PurchasesOrExpensesCreateManyConceptInputEnvelope = {
    data: PurchasesOrExpensesCreateManyConceptInput | PurchasesOrExpensesCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ClassificationTypeUpsertWithoutConceptsInput = {
    update: XOR<ClassificationTypeUpdateWithoutConceptsInput, ClassificationTypeUncheckedUpdateWithoutConceptsInput>
    create: XOR<ClassificationTypeCreateWithoutConceptsInput, ClassificationTypeUncheckedCreateWithoutConceptsInput>
    where?: ClassificationTypeWhereInput
  }

  export type ClassificationTypeUpdateToOneWithWhereWithoutConceptsInput = {
    where?: ClassificationTypeWhereInput
    data: XOR<ClassificationTypeUpdateWithoutConceptsInput, ClassificationTypeUncheckedUpdateWithoutConceptsInput>
  }

  export type ClassificationTypeUpdateWithoutConceptsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ClassificationTypeUncheckedUpdateWithoutConceptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceTypeUpsertWithoutConceptsInput = {
    update: XOR<InvoiceTypeUpdateWithoutConceptsInput, InvoiceTypeUncheckedUpdateWithoutConceptsInput>
    create: XOR<InvoiceTypeCreateWithoutConceptsInput, InvoiceTypeUncheckedCreateWithoutConceptsInput>
    where?: InvoiceTypeWhereInput
  }

  export type InvoiceTypeUpdateToOneWithWhereWithoutConceptsInput = {
    where?: InvoiceTypeWhereInput
    data: XOR<InvoiceTypeUpdateWithoutConceptsInput, InvoiceTypeUncheckedUpdateWithoutConceptsInput>
  }

  export type InvoiceTypeUpdateWithoutConceptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceTypeUncheckedUpdateWithoutConceptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUpsertWithoutConceptsInput = {
    update: XOR<UsersUpdateWithoutConceptsInput, UsersUncheckedUpdateWithoutConceptsInput>
    create: XOR<UsersCreateWithoutConceptsInput, UsersUncheckedCreateWithoutConceptsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutConceptsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutConceptsInput, UsersUncheckedUpdateWithoutConceptsInput>
  }

  export type UsersUpdateWithoutConceptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxPayer?: TaxPayerUpdateOneRequiredWithoutUsersNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutAuthorNestedInput
  }

  export type UsersUncheckedUpdateWithoutConceptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutConceptInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutConceptInput, PurchasesOrExpensesUncheckedUpdateWithoutConceptInput>
    create: XOR<PurchasesOrExpensesCreateWithoutConceptInput, PurchasesOrExpensesUncheckedCreateWithoutConceptInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutConceptInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutConceptInput, PurchasesOrExpensesUncheckedUpdateWithoutConceptInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutConceptInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutConceptInput>
  }

  export type RequestsCreateWithoutStatusInput = {
    id?: string
    requestNum?: number
    email: string
    createdAt?: Date | string
    taxPayer: TaxPayerCreateNestedOneWithoutRequestsInput
    Documents?: DocumentsCreateNestedManyWithoutRequestInput
  }

  export type RequestsUncheckedCreateWithoutStatusInput = {
    id?: string
    requestNum?: number
    username: string
    email: string
    createdAt?: Date | string
    Documents?: DocumentsUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestsCreateOrConnectWithoutStatusInput = {
    where: RequestsWhereUniqueInput
    create: XOR<RequestsCreateWithoutStatusInput, RequestsUncheckedCreateWithoutStatusInput>
  }

  export type RequestsCreateManyStatusInputEnvelope = {
    data: RequestsCreateManyStatusInput | RequestsCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type RequestsUpsertWithWhereUniqueWithoutStatusInput = {
    where: RequestsWhereUniqueInput
    update: XOR<RequestsUpdateWithoutStatusInput, RequestsUncheckedUpdateWithoutStatusInput>
    create: XOR<RequestsCreateWithoutStatusInput, RequestsUncheckedCreateWithoutStatusInput>
  }

  export type RequestsUpdateWithWhereUniqueWithoutStatusInput = {
    where: RequestsWhereUniqueInput
    data: XOR<RequestsUpdateWithoutStatusInput, RequestsUncheckedUpdateWithoutStatusInput>
  }

  export type RequestsUpdateManyWithWhereWithoutStatusInput = {
    where: RequestsScalarWhereInput
    data: XOR<RequestsUpdateManyMutationInput, RequestsUncheckedUpdateManyWithoutStatusInput>
  }

  export type RequestsScalarWhereInput = {
    AND?: RequestsScalarWhereInput | RequestsScalarWhereInput[]
    OR?: RequestsScalarWhereInput[]
    NOT?: RequestsScalarWhereInput | RequestsScalarWhereInput[]
    id?: StringFilter<"Requests"> | string
    requestNum?: IntFilter<"Requests"> | number
    username?: StringFilter<"Requests"> | string
    email?: StringFilter<"Requests"> | string
    createdAt?: DateTimeFilter<"Requests"> | Date | string
    requestStatusId?: IntFilter<"Requests"> | number
  }

  export type TaxPayerCreateWithoutRequestsInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutTaxPayerInput
    Users?: UsersCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerUncheckedCreateWithoutRequestsInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutTaxPayerInput
    Users?: UsersUncheckedCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerCreateOrConnectWithoutRequestsInput = {
    where: TaxPayerWhereUniqueInput
    create: XOR<TaxPayerCreateWithoutRequestsInput, TaxPayerUncheckedCreateWithoutRequestsInput>
  }

  export type RequestStatusCreateWithoutRequestsInput = {
    name: string
    createdAt?: Date | string
  }

  export type RequestStatusUncheckedCreateWithoutRequestsInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type RequestStatusCreateOrConnectWithoutRequestsInput = {
    where: RequestStatusWhereUniqueInput
    create: XOR<RequestStatusCreateWithoutRequestsInput, RequestStatusUncheckedCreateWithoutRequestsInput>
  }

  export type DocumentsCreateWithoutRequestInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    createdAt?: Date | string
    documentType: DocumentTypeCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutRequestInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    documentTypeId: number
    createdAt?: Date | string
  }

  export type DocumentsCreateOrConnectWithoutRequestInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutRequestInput, DocumentsUncheckedCreateWithoutRequestInput>
  }

  export type DocumentsCreateManyRequestInputEnvelope = {
    data: DocumentsCreateManyRequestInput | DocumentsCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type TaxPayerUpsertWithoutRequestsInput = {
    update: XOR<TaxPayerUpdateWithoutRequestsInput, TaxPayerUncheckedUpdateWithoutRequestsInput>
    create: XOR<TaxPayerCreateWithoutRequestsInput, TaxPayerUncheckedCreateWithoutRequestsInput>
    where?: TaxPayerWhereInput
  }

  export type TaxPayerUpdateToOneWithWhereWithoutRequestsInput = {
    where?: TaxPayerWhereInput
    data: XOR<TaxPayerUpdateWithoutRequestsInput, TaxPayerUncheckedUpdateWithoutRequestsInput>
  }

  export type TaxPayerUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutTaxPayerNestedInput
    Users?: UsersUpdateManyWithoutTaxPayerNestedInput
  }

  export type TaxPayerUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerNestedInput
    Users?: UsersUncheckedUpdateManyWithoutTaxPayerNestedInput
  }

  export type RequestStatusUpsertWithoutRequestsInput = {
    update: XOR<RequestStatusUpdateWithoutRequestsInput, RequestStatusUncheckedUpdateWithoutRequestsInput>
    create: XOR<RequestStatusCreateWithoutRequestsInput, RequestStatusUncheckedCreateWithoutRequestsInput>
    where?: RequestStatusWhereInput
  }

  export type RequestStatusUpdateToOneWithWhereWithoutRequestsInput = {
    where?: RequestStatusWhereInput
    data: XOR<RequestStatusUpdateWithoutRequestsInput, RequestStatusUncheckedUpdateWithoutRequestsInput>
  }

  export type RequestStatusUpdateWithoutRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentsUpsertWithWhereUniqueWithoutRequestInput = {
    where: DocumentsWhereUniqueInput
    update: XOR<DocumentsUpdateWithoutRequestInput, DocumentsUncheckedUpdateWithoutRequestInput>
    create: XOR<DocumentsCreateWithoutRequestInput, DocumentsUncheckedCreateWithoutRequestInput>
  }

  export type DocumentsUpdateWithWhereUniqueWithoutRequestInput = {
    where: DocumentsWhereUniqueInput
    data: XOR<DocumentsUpdateWithoutRequestInput, DocumentsUncheckedUpdateWithoutRequestInput>
  }

  export type DocumentsUpdateManyWithWhereWithoutRequestInput = {
    where: DocumentsScalarWhereInput
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyWithoutRequestInput>
  }

  export type DocumentsScalarWhereInput = {
    AND?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
    OR?: DocumentsScalarWhereInput[]
    NOT?: DocumentsScalarWhereInput | DocumentsScalarWhereInput[]
    id?: StringFilter<"Documents"> | string
    fileName?: StringFilter<"Documents"> | string
    downloadURL?: StringFilter<"Documents"> | string
    fileFormatType?: StringFilter<"Documents"> | string
    documentTypeId?: IntFilter<"Documents"> | number
    createdAt?: DateTimeFilter<"Documents"> | Date | string
    requestId?: StringFilter<"Documents"> | string
  }

  export type RequestsCreateWithoutDocumentsInput = {
    id?: string
    requestNum?: number
    email: string
    createdAt?: Date | string
    taxPayer: TaxPayerCreateNestedOneWithoutRequestsInput
    status: RequestStatusCreateNestedOneWithoutRequestsInput
  }

  export type RequestsUncheckedCreateWithoutDocumentsInput = {
    id?: string
    requestNum?: number
    username: string
    email: string
    createdAt?: Date | string
    requestStatusId: number
  }

  export type RequestsCreateOrConnectWithoutDocumentsInput = {
    where: RequestsWhereUniqueInput
    create: XOR<RequestsCreateWithoutDocumentsInput, RequestsUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentTypeCreateWithoutDocumentsInput = {
    name: string
  }

  export type DocumentTypeUncheckedCreateWithoutDocumentsInput = {
    id?: number
    name: string
  }

  export type DocumentTypeCreateOrConnectWithoutDocumentsInput = {
    where: DocumentTypeWhereUniqueInput
    create: XOR<DocumentTypeCreateWithoutDocumentsInput, DocumentTypeUncheckedCreateWithoutDocumentsInput>
  }

  export type RequestsUpsertWithoutDocumentsInput = {
    update: XOR<RequestsUpdateWithoutDocumentsInput, RequestsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<RequestsCreateWithoutDocumentsInput, RequestsUncheckedCreateWithoutDocumentsInput>
    where?: RequestsWhereInput
  }

  export type RequestsUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: RequestsWhereInput
    data: XOR<RequestsUpdateWithoutDocumentsInput, RequestsUncheckedUpdateWithoutDocumentsInput>
  }

  export type RequestsUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxPayer?: TaxPayerUpdateOneRequiredWithoutRequestsNestedInput
    status?: RequestStatusUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type RequestsUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentTypeUpsertWithoutDocumentsInput = {
    update: XOR<DocumentTypeUpdateWithoutDocumentsInput, DocumentTypeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DocumentTypeCreateWithoutDocumentsInput, DocumentTypeUncheckedCreateWithoutDocumentsInput>
    where?: DocumentTypeWhereInput
  }

  export type DocumentTypeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DocumentTypeWhereInput
    data: XOR<DocumentTypeUpdateWithoutDocumentsInput, DocumentTypeUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentTypeUpdateWithoutDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentTypeUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TaxPayerCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    Requests?: RequestsCreateNestedManyWithoutTaxPayerInput
    Users?: UsersCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name?: string | null
    tradeName?: string | null
    about?: string | null
    col1?: string | null
    col2?: string | null
    col3?: string | null
    col4?: string | null
    createdAt?: string | null
    state?: string | null
    status?: string | null
    Requests?: RequestsUncheckedCreateNestedManyWithoutTaxPayerInput
    Users?: UsersUncheckedCreateNestedManyWithoutTaxPayerInput
  }

  export type TaxPayerCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: TaxPayerWhereUniqueInput
    create: XOR<TaxPayerCreateWithoutPurchasesOrExpensesInput, TaxPayerUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type UsersCreateWithoutPurchasesOrExpensesInput = {
    id?: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    taxPayer: TaxPayerCreateNestedOneWithoutUsersInput
    Concepts?: ConceptsCreateNestedManyWithoutAuthorInput
  }

  export type UsersUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id?: string
    username: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    Concepts?: ConceptsUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UsersCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPurchasesOrExpensesInput, UsersUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type ConceptsCreateWithoutPurchasesOrExpensesInput = {
    name: string
    classificationType: ClassificationTypeCreateNestedOneWithoutConceptsInput
    invoiceType: InvoiceTypeCreateNestedOneWithoutConceptsInput
    author: UsersCreateNestedOneWithoutConceptsInput
  }

  export type ConceptsUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id?: number
    name: string
    authorId: string
    invoiceTypeId: string
    classificationTypeId: number
  }

  export type ConceptsCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: ConceptsWhereUniqueInput
    create: XOR<ConceptsCreateWithoutPurchasesOrExpensesInput, ConceptsUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type TaxPayerTypesCreateWithoutPurchasesOrExpensesInput = {
    id: number
    name: string
    createdAt?: Date | string
  }

  export type TaxPayerTypesUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id: number
    name: string
    createdAt?: Date | string
  }

  export type TaxPayerTypesCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: TaxPayerTypesWhereUniqueInput
    create: XOR<TaxPayerTypesCreateWithoutPurchasesOrExpensesInput, TaxPayerTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type PaymentsMethodsCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name: string
    createdAt?: Date | string
  }

  export type PaymentsMethodsUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name: string
    createdAt?: Date | string
  }

  export type PaymentsMethodsCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: PaymentsMethodsWhereUniqueInput
    create: XOR<PaymentsMethodsCreateWithoutPurchasesOrExpensesInput, PaymentsMethodsUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type NcfsTypesCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name: string
    createdAt?: Date | string
    serial: SerialCreateNestedOneWithoutNcfsTypesInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesCreateNestedManyWithoutNcfAffectTypeInput
  }

  export type NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name: string
    serialId: number
    createdAt?: Date | string
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfAffectTypeInput
  }

  export type NcfsTypesCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: NcfsTypesWhereUniqueInput
    create: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type NcfsTypesCreateWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    id: string
    name: string
    createdAt?: Date | string
    serial: SerialCreateNestedOneWithoutNcfsTypesInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutNcfTypeInput
  }

  export type NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    id: string
    name: string
    serialId: number
    createdAt?: Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutNcfTypeInput
  }

  export type NcfsTypesCreateOrConnectWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    where: NcfsTypesWhereUniqueInput
    create: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesOfNcfAffectedInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesOfNcfAffectedInput>
  }

  export type RetentionTaxCreateWithoutPurchasesOrExpensesInput = {
    id?: number
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type RetentionTaxUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id?: number
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type RetentionTaxCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: RetentionTaxWhereUniqueInput
    create: XOR<RetentionTaxCreateWithoutPurchasesOrExpensesInput, RetentionTaxUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type RetentionIsrCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type RetentionIsrUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type RetentionIsrCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: RetentionIsrWhereUniqueInput
    create: XOR<RetentionIsrCreateWithoutPurchasesOrExpensesInput, RetentionIsrUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type CostTaxStatusCreateWithoutPurchasesOrExpensesInput = {
    name: string
    createdAt?: Date | string
  }

  export type CostTaxStatusUncheckedCreateWithoutPurchasesOrExpensesInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type CostTaxStatusCreateOrConnectWithoutPurchasesOrExpensesInput = {
    where: CostTaxStatusWhereUniqueInput
    create: XOR<CostTaxStatusCreateWithoutPurchasesOrExpensesInput, CostTaxStatusUncheckedCreateWithoutPurchasesOrExpensesInput>
  }

  export type TaxPayerUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<TaxPayerUpdateWithoutPurchasesOrExpensesInput, TaxPayerUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<TaxPayerCreateWithoutPurchasesOrExpensesInput, TaxPayerUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: TaxPayerWhereInput
  }

  export type TaxPayerUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: TaxPayerWhereInput
    data: XOR<TaxPayerUpdateWithoutPurchasesOrExpensesInput, TaxPayerUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type TaxPayerUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    Requests?: RequestsUpdateManyWithoutTaxPayerNestedInput
    Users?: UsersUpdateManyWithoutTaxPayerNestedInput
  }

  export type TaxPayerUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    col1?: NullableStringFieldUpdateOperationsInput | string | null
    col2?: NullableStringFieldUpdateOperationsInput | string | null
    col3?: NullableStringFieldUpdateOperationsInput | string | null
    col4?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    Requests?: RequestsUncheckedUpdateManyWithoutTaxPayerNestedInput
    Users?: UsersUncheckedUpdateManyWithoutTaxPayerNestedInput
  }

  export type UsersUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<UsersUpdateWithoutPurchasesOrExpensesInput, UsersUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<UsersCreateWithoutPurchasesOrExpensesInput, UsersUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPurchasesOrExpensesInput, UsersUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type UsersUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxPayer?: TaxPayerUpdateOneRequiredWithoutUsersNestedInput
    Concepts?: ConceptsUpdateManyWithoutAuthorNestedInput
  }

  export type UsersUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concepts?: ConceptsUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ConceptsUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<ConceptsUpdateWithoutPurchasesOrExpensesInput, ConceptsUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<ConceptsCreateWithoutPurchasesOrExpensesInput, ConceptsUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: ConceptsWhereInput
  }

  export type ConceptsUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: ConceptsWhereInput
    data: XOR<ConceptsUpdateWithoutPurchasesOrExpensesInput, ConceptsUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type ConceptsUpdateWithoutPurchasesOrExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    classificationType?: ClassificationTypeUpdateOneRequiredWithoutConceptsNestedInput
    invoiceType?: InvoiceTypeUpdateOneRequiredWithoutConceptsNestedInput
    author?: UsersUpdateOneRequiredWithoutConceptsNestedInput
  }

  export type ConceptsUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    invoiceTypeId?: StringFieldUpdateOperationsInput | string
    classificationTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type TaxPayerTypesUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<TaxPayerTypesUpdateWithoutPurchasesOrExpensesInput, TaxPayerTypesUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<TaxPayerTypesCreateWithoutPurchasesOrExpensesInput, TaxPayerTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: TaxPayerTypesWhereInput
  }

  export type TaxPayerTypesUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: TaxPayerTypesWhereInput
    data: XOR<TaxPayerTypesUpdateWithoutPurchasesOrExpensesInput, TaxPayerTypesUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type TaxPayerTypesUpdateWithoutPurchasesOrExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPayerTypesUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsMethodsUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<PaymentsMethodsUpdateWithoutPurchasesOrExpensesInput, PaymentsMethodsUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<PaymentsMethodsCreateWithoutPurchasesOrExpensesInput, PaymentsMethodsUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: PaymentsMethodsWhereInput
  }

  export type PaymentsMethodsUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: PaymentsMethodsWhereInput
    data: XOR<PaymentsMethodsUpdateWithoutPurchasesOrExpensesInput, PaymentsMethodsUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type PaymentsMethodsUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsMethodsUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NcfsTypesUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<NcfsTypesUpdateWithoutPurchasesOrExpensesInput, NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: NcfsTypesWhereInput
  }

  export type NcfsTypesUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: NcfsTypesWhereInput
    data: XOR<NcfsTypesUpdateWithoutPurchasesOrExpensesInput, NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type NcfsTypesUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serial?: SerialUpdateOneRequiredWithoutNcfsTypesNestedInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUpdateManyWithoutNcfAffectTypeNestedInput
  }

  export type NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    serialId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUncheckedUpdateManyWithoutNcfAffectTypeNestedInput
  }

  export type NcfsTypesUpsertWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    update: XOR<NcfsTypesUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput, NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput>
    create: XOR<NcfsTypesCreateWithoutPurchasesOrExpensesOfNcfAffectedInput, NcfsTypesUncheckedCreateWithoutPurchasesOrExpensesOfNcfAffectedInput>
    where?: NcfsTypesWhereInput
  }

  export type NcfsTypesUpdateToOneWithWhereWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    where?: NcfsTypesWhereInput
    data: XOR<NcfsTypesUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput, NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput>
  }

  export type NcfsTypesUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serial?: SerialUpdateOneRequiredWithoutNcfsTypesNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutNcfTypeNestedInput
  }

  export type NcfsTypesUncheckedUpdateWithoutPurchasesOrExpensesOfNcfAffectedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    serialId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutNcfTypeNestedInput
  }

  export type RetentionTaxUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<RetentionTaxUpdateWithoutPurchasesOrExpensesInput, RetentionTaxUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<RetentionTaxCreateWithoutPurchasesOrExpensesInput, RetentionTaxUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: RetentionTaxWhereInput
  }

  export type RetentionTaxUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: RetentionTaxWhereInput
    data: XOR<RetentionTaxUpdateWithoutPurchasesOrExpensesInput, RetentionTaxUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type RetentionTaxUpdateWithoutPurchasesOrExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetentionTaxUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetentionIsrUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<RetentionIsrUpdateWithoutPurchasesOrExpensesInput, RetentionIsrUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<RetentionIsrCreateWithoutPurchasesOrExpensesInput, RetentionIsrUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: RetentionIsrWhereInput
  }

  export type RetentionIsrUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: RetentionIsrWhereInput
    data: XOR<RetentionIsrUpdateWithoutPurchasesOrExpensesInput, RetentionIsrUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type RetentionIsrUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetentionIsrUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostTaxStatusUpsertWithoutPurchasesOrExpensesInput = {
    update: XOR<CostTaxStatusUpdateWithoutPurchasesOrExpensesInput, CostTaxStatusUncheckedUpdateWithoutPurchasesOrExpensesInput>
    create: XOR<CostTaxStatusCreateWithoutPurchasesOrExpensesInput, CostTaxStatusUncheckedCreateWithoutPurchasesOrExpensesInput>
    where?: CostTaxStatusWhereInput
  }

  export type CostTaxStatusUpdateToOneWithWhereWithoutPurchasesOrExpensesInput = {
    where?: CostTaxStatusWhereInput
    data: XOR<CostTaxStatusUpdateWithoutPurchasesOrExpensesInput, CostTaxStatusUncheckedUpdateWithoutPurchasesOrExpensesInput>
  }

  export type CostTaxStatusUpdateWithoutPurchasesOrExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostTaxStatusUncheckedUpdateWithoutPurchasesOrExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesOrExpensesCreateWithoutTaxPayerTypeInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutTaxPayerTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput>
  }

  export type PurchasesOrExpensesCreateManyTaxPayerTypeInputEnvelope = {
    data: PurchasesOrExpensesCreateManyTaxPayerTypeInput | PurchasesOrExpensesCreateManyTaxPayerTypeInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedUpdateWithoutTaxPayerTypeInput>
    create: XOR<PurchasesOrExpensesCreateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerTypeInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutTaxPayerTypeInput, PurchasesOrExpensesUncheckedUpdateWithoutTaxPayerTypeInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerTypeInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerTypeInput>
  }

  export type ConceptsCreateWithoutInvoiceTypeInput = {
    name: string
    classificationType: ClassificationTypeCreateNestedOneWithoutConceptsInput
    author: UsersCreateNestedOneWithoutConceptsInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutConceptInput
  }

  export type ConceptsUncheckedCreateWithoutInvoiceTypeInput = {
    id?: number
    name: string
    authorId: string
    classificationTypeId: number
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptsCreateOrConnectWithoutInvoiceTypeInput = {
    where: ConceptsWhereUniqueInput
    create: XOR<ConceptsCreateWithoutInvoiceTypeInput, ConceptsUncheckedCreateWithoutInvoiceTypeInput>
  }

  export type ConceptsCreateManyInvoiceTypeInputEnvelope = {
    data: ConceptsCreateManyInvoiceTypeInput | ConceptsCreateManyInvoiceTypeInput[]
    skipDuplicates?: boolean
  }

  export type ConceptsUpsertWithWhereUniqueWithoutInvoiceTypeInput = {
    where: ConceptsWhereUniqueInput
    update: XOR<ConceptsUpdateWithoutInvoiceTypeInput, ConceptsUncheckedUpdateWithoutInvoiceTypeInput>
    create: XOR<ConceptsCreateWithoutInvoiceTypeInput, ConceptsUncheckedCreateWithoutInvoiceTypeInput>
  }

  export type ConceptsUpdateWithWhereUniqueWithoutInvoiceTypeInput = {
    where: ConceptsWhereUniqueInput
    data: XOR<ConceptsUpdateWithoutInvoiceTypeInput, ConceptsUncheckedUpdateWithoutInvoiceTypeInput>
  }

  export type ConceptsUpdateManyWithWhereWithoutInvoiceTypeInput = {
    where: ConceptsScalarWhereInput
    data: XOR<ConceptsUpdateManyMutationInput, ConceptsUncheckedUpdateManyWithoutInvoiceTypeInput>
  }

  export type PurchasesOrExpensesCreateWithoutPaymentMethodInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutPaymentMethodInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PurchasesOrExpensesCreateManyPaymentMethodInputEnvelope = {
    data: PurchasesOrExpensesCreateManyPaymentMethodInput | PurchasesOrExpensesCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<PurchasesOrExpensesCreateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutPaymentMethodInput, PurchasesOrExpensesUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type SerialCreateWithoutNcfsTypesInput = {
    id: number
    code: string
  }

  export type SerialUncheckedCreateWithoutNcfsTypesInput = {
    id: number
    code: string
  }

  export type SerialCreateOrConnectWithoutNcfsTypesInput = {
    where: SerialWhereUniqueInput
    create: XOR<SerialCreateWithoutNcfsTypesInput, SerialUncheckedCreateWithoutNcfsTypesInput>
  }

  export type PurchasesOrExpensesCreateWithoutNcfTypeInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutNcfTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput>
  }

  export type PurchasesOrExpensesCreateManyNcfTypeInputEnvelope = {
    data: PurchasesOrExpensesCreateManyNcfTypeInput | PurchasesOrExpensesCreateManyNcfTypeInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesCreateWithoutNcfAffectTypeInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutNcfAffectTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput>
  }

  export type PurchasesOrExpensesCreateManyNcfAffectTypeInputEnvelope = {
    data: PurchasesOrExpensesCreateManyNcfAffectTypeInput | PurchasesOrExpensesCreateManyNcfAffectTypeInput[]
    skipDuplicates?: boolean
  }

  export type SerialUpsertWithoutNcfsTypesInput = {
    update: XOR<SerialUpdateWithoutNcfsTypesInput, SerialUncheckedUpdateWithoutNcfsTypesInput>
    create: XOR<SerialCreateWithoutNcfsTypesInput, SerialUncheckedCreateWithoutNcfsTypesInput>
    where?: SerialWhereInput
  }

  export type SerialUpdateToOneWithWhereWithoutNcfsTypesInput = {
    where?: SerialWhereInput
    data: XOR<SerialUpdateWithoutNcfsTypesInput, SerialUncheckedUpdateWithoutNcfsTypesInput>
  }

  export type SerialUpdateWithoutNcfsTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type SerialUncheckedUpdateWithoutNcfsTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedUpdateWithoutNcfTypeInput>
    create: XOR<PurchasesOrExpensesCreateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfTypeInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutNcfTypeInput, PurchasesOrExpensesUncheckedUpdateWithoutNcfTypeInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutNcfTypeInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutNcfTypeInput>
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutNcfAffectTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedUpdateWithoutNcfAffectTypeInput>
    create: XOR<PurchasesOrExpensesCreateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedCreateWithoutNcfAffectTypeInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutNcfAffectTypeInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutNcfAffectTypeInput, PurchasesOrExpensesUncheckedUpdateWithoutNcfAffectTypeInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutNcfAffectTypeInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutNcfAffectTypeInput>
  }

  export type PurchasesOrExpensesCreateWithoutRetentionTaxInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutRetentionTaxInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput>
  }

  export type PurchasesOrExpensesCreateManyRetentionTaxInputEnvelope = {
    data: PurchasesOrExpensesCreateManyRetentionTaxInput | PurchasesOrExpensesCreateManyRetentionTaxInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionTaxInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedUpdateWithoutRetentionTaxInput>
    create: XOR<PurchasesOrExpensesCreateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionTaxInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionTaxInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutRetentionTaxInput, PurchasesOrExpensesUncheckedUpdateWithoutRetentionTaxInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionTaxInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionTaxInput>
  }

  export type PurchasesOrExpensesCreateWithoutRetentionIsrInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutRetentionIsrInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput>
  }

  export type PurchasesOrExpensesCreateManyRetentionIsrInputEnvelope = {
    data: PurchasesOrExpensesCreateManyRetentionIsrInput | PurchasesOrExpensesCreateManyRetentionIsrInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutRetentionIsrInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedUpdateWithoutRetentionIsrInput>
    create: XOR<PurchasesOrExpensesCreateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedCreateWithoutRetentionIsrInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutRetentionIsrInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutRetentionIsrInput, PurchasesOrExpensesUncheckedUpdateWithoutRetentionIsrInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutRetentionIsrInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionIsrInput>
  }

  export type PurchasesOrExpensesCreateWithoutCostTaxStatusInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    taxPayer: TaxPayerCreateNestedOneWithoutPurchasesOrExpensesInput
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutCostTaxStatusInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput>
  }

  export type PurchasesOrExpensesCreateManyCostTaxStatusInputEnvelope = {
    data: PurchasesOrExpensesCreateManyCostTaxStatusInput | PurchasesOrExpensesCreateManyCostTaxStatusInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutCostTaxStatusInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedUpdateWithoutCostTaxStatusInput>
    create: XOR<PurchasesOrExpensesCreateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedCreateWithoutCostTaxStatusInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutCostTaxStatusInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutCostTaxStatusInput, PurchasesOrExpensesUncheckedUpdateWithoutCostTaxStatusInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutCostTaxStatusInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutCostTaxStatusInput>
  }

  export type PurchasesOrExpensesCreateWithoutTaxPayerInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
    author: UsersCreateNestedOneWithoutPurchasesOrExpensesInput
    concept: ConceptsCreateNestedOneWithoutPurchasesOrExpensesInput
    taxPayerType: TaxPayerTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    paymentMethod: PaymentsMethodsCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfType: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesInput
    ncfAffectType?: NcfsTypesCreateNestedOneWithoutPurchasesOrExpensesOfNcfAffectedInput
    retentionTax?: RetentionTaxCreateNestedOneWithoutPurchasesOrExpensesInput
    retentionIsr?: RetentionIsrCreateNestedOneWithoutPurchasesOrExpensesInput
    costTaxStatus?: CostTaxStatusCreateNestedOneWithoutPurchasesOrExpensesInput
  }

  export type PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateOrConnectWithoutTaxPayerInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    create: XOR<PurchasesOrExpensesCreateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput>
  }

  export type PurchasesOrExpensesCreateManyTaxPayerInputEnvelope = {
    data: PurchasesOrExpensesCreateManyTaxPayerInput | PurchasesOrExpensesCreateManyTaxPayerInput[]
    skipDuplicates?: boolean
  }

  export type RequestsCreateWithoutTaxPayerInput = {
    id?: string
    requestNum?: number
    email: string
    createdAt?: Date | string
    status: RequestStatusCreateNestedOneWithoutRequestsInput
    Documents?: DocumentsCreateNestedManyWithoutRequestInput
  }

  export type RequestsUncheckedCreateWithoutTaxPayerInput = {
    id?: string
    requestNum?: number
    email: string
    createdAt?: Date | string
    requestStatusId: number
    Documents?: DocumentsUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestsCreateOrConnectWithoutTaxPayerInput = {
    where: RequestsWhereUniqueInput
    create: XOR<RequestsCreateWithoutTaxPayerInput, RequestsUncheckedCreateWithoutTaxPayerInput>
  }

  export type RequestsCreateManyTaxPayerInputEnvelope = {
    data: RequestsCreateManyTaxPayerInput | RequestsCreateManyTaxPayerInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutTaxPayerInput = {
    id?: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    Concepts?: ConceptsCreateNestedManyWithoutAuthorInput
    PurchasesOrExpenses?: PurchasesOrExpensesCreateNestedManyWithoutAuthorInput
  }

  export type UsersUncheckedCreateWithoutTaxPayerInput = {
    id?: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
    Concepts?: ConceptsUncheckedCreateNestedManyWithoutAuthorInput
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UsersCreateOrConnectWithoutTaxPayerInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutTaxPayerInput, UsersUncheckedCreateWithoutTaxPayerInput>
  }

  export type UsersCreateManyTaxPayerInputEnvelope = {
    data: UsersCreateManyTaxPayerInput | UsersCreateManyTaxPayerInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesOrExpensesUpsertWithWhereUniqueWithoutTaxPayerInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    update: XOR<PurchasesOrExpensesUpdateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedUpdateWithoutTaxPayerInput>
    create: XOR<PurchasesOrExpensesCreateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedCreateWithoutTaxPayerInput>
  }

  export type PurchasesOrExpensesUpdateWithWhereUniqueWithoutTaxPayerInput = {
    where: PurchasesOrExpensesWhereUniqueInput
    data: XOR<PurchasesOrExpensesUpdateWithoutTaxPayerInput, PurchasesOrExpensesUncheckedUpdateWithoutTaxPayerInput>
  }

  export type PurchasesOrExpensesUpdateManyWithWhereWithoutTaxPayerInput = {
    where: PurchasesOrExpensesScalarWhereInput
    data: XOR<PurchasesOrExpensesUpdateManyMutationInput, PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerInput>
  }

  export type RequestsUpsertWithWhereUniqueWithoutTaxPayerInput = {
    where: RequestsWhereUniqueInput
    update: XOR<RequestsUpdateWithoutTaxPayerInput, RequestsUncheckedUpdateWithoutTaxPayerInput>
    create: XOR<RequestsCreateWithoutTaxPayerInput, RequestsUncheckedCreateWithoutTaxPayerInput>
  }

  export type RequestsUpdateWithWhereUniqueWithoutTaxPayerInput = {
    where: RequestsWhereUniqueInput
    data: XOR<RequestsUpdateWithoutTaxPayerInput, RequestsUncheckedUpdateWithoutTaxPayerInput>
  }

  export type RequestsUpdateManyWithWhereWithoutTaxPayerInput = {
    where: RequestsScalarWhereInput
    data: XOR<RequestsUpdateManyMutationInput, RequestsUncheckedUpdateManyWithoutTaxPayerInput>
  }

  export type UsersUpsertWithWhereUniqueWithoutTaxPayerInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutTaxPayerInput, UsersUncheckedUpdateWithoutTaxPayerInput>
    create: XOR<UsersCreateWithoutTaxPayerInput, UsersUncheckedCreateWithoutTaxPayerInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutTaxPayerInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutTaxPayerInput, UsersUncheckedUpdateWithoutTaxPayerInput>
  }

  export type UsersUpdateManyWithWhereWithoutTaxPayerInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutTaxPayerInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    passwordChangeMode?: BoolFilter<"Users"> | boolean
    enabled?: BoolFilter<"Users"> | boolean
    createdAt?: DateTimeFilter<"Users"> | Date | string
  }

  export type DocumentsCreateWithoutDocumentTypeInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    createdAt?: Date | string
    request: RequestsCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentsUncheckedCreateWithoutDocumentTypeInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    createdAt?: Date | string
    requestId: string
  }

  export type DocumentsCreateOrConnectWithoutDocumentTypeInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutDocumentTypeInput, DocumentsUncheckedCreateWithoutDocumentTypeInput>
  }

  export type DocumentsCreateManyDocumentTypeInputEnvelope = {
    data: DocumentsCreateManyDocumentTypeInput | DocumentsCreateManyDocumentTypeInput[]
    skipDuplicates?: boolean
  }

  export type DocumentsUpsertWithWhereUniqueWithoutDocumentTypeInput = {
    where: DocumentsWhereUniqueInput
    update: XOR<DocumentsUpdateWithoutDocumentTypeInput, DocumentsUncheckedUpdateWithoutDocumentTypeInput>
    create: XOR<DocumentsCreateWithoutDocumentTypeInput, DocumentsUncheckedCreateWithoutDocumentTypeInput>
  }

  export type DocumentsUpdateWithWhereUniqueWithoutDocumentTypeInput = {
    where: DocumentsWhereUniqueInput
    data: XOR<DocumentsUpdateWithoutDocumentTypeInput, DocumentsUncheckedUpdateWithoutDocumentTypeInput>
  }

  export type DocumentsUpdateManyWithWhereWithoutDocumentTypeInput = {
    where: DocumentsScalarWhereInput
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyWithoutDocumentTypeInput>
  }

  export type ConceptsCreateManyAuthorInput = {
    id?: number
    name: string
    invoiceTypeId: string
    classificationTypeId: number
  }

  export type PurchasesOrExpensesCreateManyAuthorInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type ConceptsUpdateWithoutAuthorInput = {
    name?: StringFieldUpdateOperationsInput | string
    classificationType?: ClassificationTypeUpdateOneRequiredWithoutConceptsNestedInput
    invoiceType?: InvoiceTypeUpdateOneRequiredWithoutConceptsNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    invoiceTypeId?: StringFieldUpdateOperationsInput | string
    classificationTypeId?: IntFieldUpdateOperationsInput | number
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    invoiceTypeId?: StringFieldUpdateOperationsInput | string
    classificationTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesOrExpensesUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type NcfsTypesCreateManySerialInput = {
    id: string
    name: string
    createdAt?: Date | string
  }

  export type NcfsTypesUpdateWithoutSerialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutNcfTypeNestedInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUpdateManyWithoutNcfAffectTypeNestedInput
  }

  export type NcfsTypesUncheckedUpdateWithoutSerialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutNcfTypeNestedInput
    PurchasesOrExpensesOfNcfAffected?: PurchasesOrExpensesUncheckedUpdateManyWithoutNcfAffectTypeNestedInput
  }

  export type NcfsTypesUncheckedUpdateManyWithoutSerialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptsCreateManyClassificationTypeInput = {
    id?: number
    name: string
    authorId: string
    invoiceTypeId: string
  }

  export type ConceptsUpdateWithoutClassificationTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    invoiceType?: InvoiceTypeUpdateOneRequiredWithoutConceptsNestedInput
    author?: UsersUpdateOneRequiredWithoutConceptsNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsUncheckedUpdateWithoutClassificationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    invoiceTypeId?: StringFieldUpdateOperationsInput | string
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsUncheckedUpdateManyWithoutClassificationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    invoiceTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchasesOrExpensesCreateManyConceptInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RequestsCreateManyStatusInput = {
    id?: string
    requestNum?: number
    username: string
    email: string
    createdAt?: Date | string
  }

  export type RequestsUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxPayer?: TaxPayerUpdateOneRequiredWithoutRequestsNestedInput
    Documents?: DocumentsUpdateManyWithoutRequestNestedInput
  }

  export type RequestsUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Documents?: DocumentsUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestsUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentsCreateManyRequestInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    documentTypeId: number
    createdAt?: Date | string
  }

  export type DocumentsUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentType?: DocumentTypeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentsUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    documentTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesOrExpensesCreateManyTaxPayerTypeInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutTaxPayerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutTaxPayerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ConceptsCreateManyInvoiceTypeInput = {
    id?: number
    name: string
    authorId: string
    classificationTypeId: number
  }

  export type ConceptsUpdateWithoutInvoiceTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    classificationType?: ClassificationTypeUpdateOneRequiredWithoutConceptsNestedInput
    author?: UsersUpdateOneRequiredWithoutConceptsNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsUncheckedUpdateWithoutInvoiceTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    classificationTypeId?: IntFieldUpdateOperationsInput | number
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptsUncheckedUpdateManyWithoutInvoiceTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    classificationTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesOrExpensesCreateManyPaymentMethodInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesCreateManyNcfTypeInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesCreateManyNcfAffectTypeInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutNcfTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutNcfTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutNcfTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutNcfAffectTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutNcfAffectTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutNcfAffectTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesCreateManyRetentionTaxInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutRetentionTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutRetentionTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesCreateManyRetentionIsrInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutRetentionIsrInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutRetentionIsrInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutRetentionIsrInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesCreateManyCostTaxStatusInput = {
    id?: string
    rncOrId: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type PurchasesOrExpensesUpdateWithoutCostTaxStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxPayer?: TaxPayerUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutCostTaxStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutCostTaxStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    rncOrId?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesCreateManyTaxPayerInput = {
    id?: string
    ncf: string
    ncfAffected?: string | null
    issueDate: Date | string
    retentionDate?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    tax: Decimal | DecimalJsLike | number | string
    costTax?: Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId: number
    paymentsMethodsId: string
    ncfsTypesId: string
    ncfsAffectTypeId?: string | null
    retentionTaxId?: number | null
    retentionIsrId?: string | null
    costTaxStatusId?: number | null
    conceptId: number
    authorId: string
    updatedAt?: Date | string | null
    createdAt?: Date | string
    netAmount?: Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: Decimal | DecimalJsLike | number | string | null
    netToPaid?: Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: Decimal | DecimalJsLike | number | string | null
    manual?: boolean | null
  }

  export type RequestsCreateManyTaxPayerInput = {
    id?: string
    requestNum?: number
    email: string
    createdAt?: Date | string
    requestStatusId: number
  }

  export type UsersCreateManyTaxPayerInput = {
    id?: string
    password: string
    email: string
    passwordChangeMode?: boolean
    enabled?: boolean
    createdAt?: Date | string
  }

  export type PurchasesOrExpensesUpdateWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    author?: UsersUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    concept?: ConceptsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    taxPayerType?: TaxPayerTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    paymentMethod?: PaymentsMethodsUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfType?: NcfsTypesUpdateOneRequiredWithoutPurchasesOrExpensesNestedInput
    ncfAffectType?: NcfsTypesUpdateOneWithoutPurchasesOrExpensesOfNcfAffectedNestedInput
    retentionTax?: RetentionTaxUpdateOneWithoutPurchasesOrExpensesNestedInput
    retentionIsr?: RetentionIsrUpdateOneWithoutPurchasesOrExpensesNestedInput
    costTaxStatus?: CostTaxStatusUpdateOneWithoutPurchasesOrExpensesNestedInput
  }

  export type PurchasesOrExpensesUncheckedUpdateWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PurchasesOrExpensesUncheckedUpdateManyWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ncf?: StringFieldUpdateOperationsInput | string
    ncfAffected?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPayerTypesId?: IntFieldUpdateOperationsInput | number
    paymentsMethodsId?: StringFieldUpdateOperationsInput | string
    ncfsTypesId?: StringFieldUpdateOperationsInput | string
    ncfsAffectTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    retentionTaxId?: NullableIntFieldUpdateOperationsInput | number | null
    retentionIsrId?: NullableStringFieldUpdateOperationsInput | string | null
    costTaxStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptId?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionTaxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retentionIsrValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netToPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxForOvertaking?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    manual?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RequestsUpdateWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: RequestStatusUpdateOneRequiredWithoutRequestsNestedInput
    Documents?: DocumentsUpdateManyWithoutRequestNestedInput
  }

  export type RequestsUncheckedUpdateWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestStatusId?: IntFieldUpdateOperationsInput | number
    Documents?: DocumentsUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestsUncheckedUpdateManyWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestNum?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type UsersUpdateWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concepts?: ConceptsUpdateManyWithoutAuthorNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUpdateManyWithoutAuthorNestedInput
  }

  export type UsersUncheckedUpdateWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concepts?: ConceptsUncheckedUpdateManyWithoutAuthorNestedInput
    PurchasesOrExpenses?: PurchasesOrExpensesUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutTaxPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordChangeMode?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentsCreateManyDocumentTypeInput = {
    id?: string
    fileName: string
    downloadURL: string
    fileFormatType: string
    createdAt?: Date | string
    requestId: string
  }

  export type DocumentsUpdateWithoutDocumentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: RequestsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentsUncheckedUpdateWithoutDocumentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentsUncheckedUpdateManyWithoutDocumentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    downloadURL?: StringFieldUpdateOperationsInput | string
    fileFormatType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SerialCountOutputTypeDefaultArgs instead
     */
    export type SerialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SerialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassificationTypeCountOutputTypeDefaultArgs instead
     */
    export type ClassificationTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassificationTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptsCountOutputTypeDefaultArgs instead
     */
    export type ConceptsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RequestStatusCountOutputTypeDefaultArgs instead
     */
    export type RequestStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RequestStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RequestsCountOutputTypeDefaultArgs instead
     */
    export type RequestsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RequestsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaxPayerTypesCountOutputTypeDefaultArgs instead
     */
    export type TaxPayerTypesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaxPayerTypesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceTypeCountOutputTypeDefaultArgs instead
     */
    export type InvoiceTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentsMethodsCountOutputTypeDefaultArgs instead
     */
    export type PaymentsMethodsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentsMethodsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NcfsTypesCountOutputTypeDefaultArgs instead
     */
    export type NcfsTypesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NcfsTypesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RetentionTaxCountOutputTypeDefaultArgs instead
     */
    export type RetentionTaxCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RetentionTaxCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RetentionIsrCountOutputTypeDefaultArgs instead
     */
    export type RetentionIsrCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RetentionIsrCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostTaxStatusCountOutputTypeDefaultArgs instead
     */
    export type CostTaxStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostTaxStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaxPayerCountOutputTypeDefaultArgs instead
     */
    export type TaxPayerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaxPayerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentTypeCountOutputTypeDefaultArgs instead
     */
    export type DocumentTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersDefaultArgs instead
     */
    export type UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SerialDefaultArgs instead
     */
    export type SerialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SerialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassificationTypeDefaultArgs instead
     */
    export type ClassificationTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassificationTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptsDefaultArgs instead
     */
    export type ConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RequestStatusDefaultArgs instead
     */
    export type RequestStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RequestStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RequestsDefaultArgs instead
     */
    export type RequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RequestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentsDefaultArgs instead
     */
    export type DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchasesOrExpensesDefaultArgs instead
     */
    export type PurchasesOrExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchasesOrExpensesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaxPayerTypesDefaultArgs instead
     */
    export type TaxPayerTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaxPayerTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceTypeDefaultArgs instead
     */
    export type InvoiceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentsMethodsDefaultArgs instead
     */
    export type PaymentsMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentsMethodsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NcfsTypesDefaultArgs instead
     */
    export type NcfsTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NcfsTypesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RetentionTaxDefaultArgs instead
     */
    export type RetentionTaxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RetentionTaxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RetentionIsrDefaultArgs instead
     */
    export type RetentionIsrArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RetentionIsrDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostTaxStatusDefaultArgs instead
     */
    export type CostTaxStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostTaxStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaxPayerDefaultArgs instead
     */
    export type TaxPayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaxPayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentTypeDefaultArgs instead
     */
    export type DocumentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailVerificationsDefaultArgs instead
     */
    export type EmailVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailVerificationsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}